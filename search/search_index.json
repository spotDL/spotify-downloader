{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#spotdl-v4","title":"spotDL v4","text":"<p>Download your Spotify playlists and songs along with album art and metadata</p> <p> </p> <p>A new and improved version of spotDL: still the fastest, easiest and most accurate command-line music downloader</p> <p>Read the documentation on ReadTheDocs!</p>"},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Visual C++ 2019 redistributable (on Windows)</li> <li>Python 3.7 or above (added to PATH)</li> </ul> <p>YouTube Music must be available in your country for spotDL to work. This is because we use YouTube Music to filter search results. You can check if YouTube Music is available in your country, by visiting YouTube Music.</p>"},{"location":"#installation","title":"Installation","text":"<p>Refer to our Installation Guide for more details</p> <ul> <li>Python (Recommended)</li> <li>spotDL can be installed by running <code>pip install spotdl</code>. <p>On some systems you might have to change <code>pip</code> to <code>pip3</code>.</p> </li> </ul>"},{"location":"#other-options","title":"Other options","text":"<ul> <li>Prebuilt Executable</li> <li>You can download the latest version from the     Releases Tab</li> <li>On Termux</li> <li><code>curl -L https://raw.githubusercontent.com/spotDL/spotify-downloader/master/scripts/termux.sh | sh</code></li> <li>Arch</li> <li>There is an Arch User Repository (AUR) package for     spotDL.</li> <li>Docker</li> <li> <p>Build image:</p> <pre><code>docker build -t spotdl .\n</code></pre> </li> <li> <p>Launch container with spotDL parameters (see section below). You need to create mapped     volume to access song files</p> <pre><code>docker run --rm -v $(pwd):/music spotdl download [trackUrl]\n</code></pre> </li> </ul>"},{"location":"#installing-ffmpeg","title":"Installing FFmpeg","text":"<p>If using FFmpeg only for spotDL, you can install FFmpeg to your local directory. <code>spotdl --download-ffmpeg</code> will download FFmpeg to your spotDL installation directory.</p> <p>We recommend the above option, but if you want to install FFmpeg system-wide,</p> <ul> <li>Windows Tutorial</li> <li>OSX - <code>brew install ffmpeg</code></li> <li>Linux - <code>sudo apt install ffmpeg</code> or use your distro's package manager</li> </ul>"},{"location":"#usage","title":"Usage","text":"<p>To get started right away:</p> <pre><code>spotdl download [urls]\n</code></pre> <p>To start the Web UI:</p> <pre><code>spotdl web\n</code></pre> <p>You can run spotDL as a package if running it as a script doesn't work:</p> <pre><code>python -m spotdl [urls]\n</code></pre>"},{"location":"#further-information-can-be-found-in-our-documentation","title":"Further information can be found in our documentation","text":"<p>Read the documentation on ReadTheDocs!</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Interested in contributing? Check out our CONTRIBUTING.md to find resources around contributing along with a guide on how to set up a development environment.</p>"},{"location":"#license","title":"License","text":"<p>This project is Licensed under the MIT License.</p>"},{"location":"CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes, and learning from   the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address, without their   explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at spotdladmins@googlegroups.com. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"CONTRIBUTING/","title":"Contributing","text":""},{"location":"CONTRIBUTING/#contributing-to-spotdl","title":"Contributing to spotdl","text":"<p>First off, thanks for taking the time to contribute! \u2764\ufe0f</p> <p>All types of contributions are encouraged and valued. See the Table of Contents for different ways to help and details about how this project handles them. Please make sure to read the relevant section before making your contribution. It will make it a lot easier for us maintainers and smooth out the experience for everyone involved. The community looks forward to your contributions. \ud83c\udf89</p> <p>And if you like the project, but just don't have time to contribute, that's fine. There are other easy ways to support the project and show your appreciation, which we would also be very happy about:</p> <ul> <li>Star the project</li> <li>Tweet about it</li> <li>Refer this project in your project's readme</li> <li>Mention the project at local meetups and tell your friends/colleagues</li> </ul>"},{"location":"CONTRIBUTING/#table-of-contents","title":"Table of Contents","text":"<ul> <li>I Have a Question</li> <li>I Want To Contribute</li> <li>Reporting Bugs</li> <li>Suggesting Enhancements</li> <li>Linting, Formatting and Type-checking</li> <li>Python Documentation</li> <li>Overview of the Project Structure</li> <li>Join The Project Team</li> </ul>"},{"location":"CONTRIBUTING/#i-have-a-question","title":"I Have a Question","text":"<p>If you want to ask a question, we assume that you have read the available Documentation.</p> <p>Before you ask a question, it is best to search for existing Issues that might help you. In case you have found a suitable issue and still need clarification, you can write your question in this issue. It is also advisable to search the internet for answers first.</p> <p>If you then still feel the need to ask a question and need clarification, we recommend the following:</p> <ul> <li>Open an Issue.</li> <li>Provide as much context as you can about what you're running into.</li> <li>Provide project and platform versions (nodejs, npm, etc), depending on what seems relevant.</li> </ul> <p>We will then take care of the issue as soon as possible.</p>"},{"location":"CONTRIBUTING/#i-want-to-contribute","title":"I Want To Contribute","text":""},{"location":"CONTRIBUTING/#legal-notice","title":"Legal Notice","text":"<p>When contributing to this project, you must agree that you have authored 100% of the content, that you have the necessary rights to the content and that the content you contribute may be provided under the project license.</p>"},{"location":"CONTRIBUTING/#reporting-bugs","title":"Reporting Bugs","text":""},{"location":"CONTRIBUTING/#before-submitting-a-bug-report","title":"Before Submitting a Bug Report","text":"<p>A good bug report shouldn't leave others needing to chase you up for more information. Therefore, we ask you to investigate carefully, collect information and describe the issue in detail in your report. Please complete the following steps in advance to help us fix any potential bug as fast as possible.</p> <ul> <li>Make sure that you are using the latest version.</li> <li>Determine if your bug is really a bug and not an error on your side e.g. using incompatible   environment components/versions (Make sure that you have read the   documentation. If you are looking for   support, you might want to check this section).</li> <li>To see if other users have experienced (and potentially already solved) the same issue you   are having, check if there is not already a bug report existing for your bug or error in the   bug tracker.</li> <li>Also make sure to search the internet (including Stack Overflow) to see if users outside of   the GitHub community have discussed the issue.</li> <li>Collect information about the bug:</li> <li>Stack trace (Traceback)</li> <li>OS, Platform and Version (Windows, Linux, macOS, x86, ARM)</li> <li>Version of the interpreter, compiler, SDK, runtime environment, package manager, depending on   what seems relevant.</li> <li>Possibly your input and the output</li> <li>Can you reliably reproduce the issue? And can you also reproduce it with older versions?</li> </ul>"},{"location":"CONTRIBUTING/#how-do-i-submit-a-good-bug-report","title":"How Do I Submit a Good Bug Report?","text":"<p>You must never report security related issues, vulnerabilities or bugs to the issue tracker, or elsewhere in public. Instead sensitive bugs must be sent by discord to xnetcat#8144.</p> <p>We use GitHub issues to track bugs and errors. If you run into an issue with the project:</p> <ul> <li>Open an Issue. (Since we can't be   sure at this point whether it is a bug or not, we ask you not to talk about a bug yet and not   to label the issue.)</li> <li>Explain the behavior you would expect and the actual behavior.</li> <li>Please provide as much context as possible and describe the reproduction steps that someone   else can follow to recreate the issue on their own. This usually includes your code. For good   bug reports you should isolate the problem and create a reduced test case.</li> <li>Provide the information you collected in the previous section.</li> </ul> <p>Once it's filed:</p> <ul> <li>The project team will label the issue accordingly.</li> <li>A team member will try to reproduce the issue with your provided steps. If there are no   reproduction steps or no obvious way to reproduce the issue, the team will ask you for those   steps and mark the issue as <code>needs-repro</code>. Bugs with the <code>needs-repro</code> tag will not be   addressed until they are reproduced.</li> <li>If the team is able to reproduce the issue, it will be marked <code>needs-fix</code>, as well as   possibly other tags (such as <code>critical</code>), and the issue will be left to be   implemented by someone.</li> </ul>"},{"location":"CONTRIBUTING/#suggesting-enhancements","title":"Suggesting Enhancements","text":"<p>This section guides you through submitting an enhancement suggestion for spotdl, including completely new features and minor improvements to existing functionality. Following these guidelines will help maintainers and the community to understand your suggestion and find related suggestions.</p>"},{"location":"CONTRIBUTING/#before-submitting-an-enhancement","title":"Before Submitting an Enhancement","text":"<ul> <li>Make sure that you are using the latest version.</li> <li>Read the documentation carefully and find   out if the functionality is already covered, maybe by an individual configuration.</li> <li>Perform a search to see if the   enhancement has already been suggested. If it has, add a comment to the existing issue   instead of opening a new one.</li> <li>Find out whether your idea fits with the scope and aims of the project. It's up to you to   make a strong case to convince the project's developers of the merits of this feature. Keep   in mind that we want features that will be useful to the majority of our users and not just a   small subset. If you're just targeting a minority of users, consider writing an add-on/plugin   library.</li> </ul>"},{"location":"CONTRIBUTING/#how-do-i-submit-a-good-enhancement-suggestion","title":"How Do I Submit a Good Enhancement Suggestion?","text":"<p>Enhancement suggestions are tracked as GitHub issues.</p> <ul> <li>Use a clear and descriptive title for the issue to identify the suggestion.</li> <li>Provide a step-by-step description of the suggested enhancement in as many details as   possible.</li> <li>Describe the current behavior and explain which behavior you expected to see instead   and why. At this point you can also tell which alternatives do not work for you.</li> <li>You may want to include screenshots and animated GIFs which help you demonstrate the   steps or point out the part which the suggestion is related to. You can use   this tool to record GIFs on macOS and Windows, and   this tool or   this tool on Linux.       </li> <li>Explain why this enhancement would be useful to most spotdl users. You may also want to   point out the other projects that solved it better and which could serve as inspiration.</li> </ul>"},{"location":"CONTRIBUTING/#developing","title":"Developing","text":"<p>Fork the repository on Github and then clone it.</p> <pre><code>git clone [your username]/spotify-downloader\ncd spotify-downloader\n</code></pre> <p>Install poetry</p> <pre><code>pip install poetry\n</code></pre> <p>Then, to install spotDL in-place and editable, run the following</p> <pre><code>poetry install\n</code></pre> <p>All changes will now affect the poetry installation of the spotdl cli.</p>"},{"location":"CONTRIBUTING/#linting-formatting-and-type-checking","title":"Linting, Formatting and Type-checking","text":"<ul> <li>We use <code>pylint</code> for linting and expect a score above <code>9</code></li> </ul> <pre><code>pylint --limit-inference-results 0 --fail-under 9 ./spotdl\n</code></pre> <ul> <li>We use <code>black</code> for code formatting</li> </ul> <pre><code>black ./spotdl\n</code></pre> <ul> <li>We use <code>mypy</code> for type-checking and expect no errors at all</li> </ul> <p>To install type-stubs the first time around</p> <pre><code>mypy --ignore-missing-imports --follow-imports silent --install-types --non-interactive ./spotdl\n</code></pre> <pre><code>mypy ./spotdl\n</code></pre> <ul> <li>You can install these basic tools with</li> </ul> <pre><code>pip install --force-reinstall --upgrade mypy black pylint\n</code></pre>"},{"location":"CONTRIBUTING/#python-documentation","title":"Python Documentation","text":"<p>Any submitted code is expected to have accompanying documentation</p>"},{"location":"CONTRIBUTING/#mkdocs-generating-documentation","title":"mkdocs: generating documentation","text":"<ul> <li>We generate our documentation with <code>mkdocs</code></li> </ul> <pre><code>pip install mkdocs\n</code></pre> <p><code>mkdocs</code> requires that all development packages are installed</p> <pre><code>poetry install\n</code></pre> <p>generate docs with</p> <pre><code>mkdocs build --strict\n</code></pre> <p>view docs live-time while editing with</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"CONTRIBUTING/#docstring-formats","title":"DocString Formats","text":"<ul> <li>For functions</li> </ul> <pre><code>one-liner about functions purpose\n\n### Args (optional)\n- arg_name: description\n\n### Returns (optional)\n- return value description\n\n### Errors (only if there are known unhandled Errors/thrown Errors)\n- known errors\n\n### Notes (optional)\n- notes if any\n</code></pre> <ul> <li>For Classes</li> </ul> <pre><code>one-liner about class purpose\n\n### Attributes\n- attribute: description\n\n### Notes (optional)\n- notes if any\n</code></pre> <ul> <li>For modules/package <code>__init__</code></li> </ul> <pre><code>at max 3 lines about module/package purpose\n\noptional usage example for module/package preferably showcasing most commonly used functionality\n</code></pre>"},{"location":"CONTRIBUTING/#notes-about-docstrings","title":"Notes about docstrings","text":"<ul> <li>DocStrings are Inherited</li> </ul> <pre><code>class A:\n    def test(self):\n        \"\"\"Docstring for A.\"\"\"\n        pass\n\nclass B(A):\n    def test(self):\n        pass\n</code></pre>"},{"location":"CONTRIBUTING/#overview-of-the-project-structure","title":"Overview of the Project Structure","text":"sub-package purpose <code>utils</code> Contains commonly used functions <code>types</code> Custom data types used in the spotdl project <code>providers</code> Different Providers to obtain info (like song details) from <code>download</code> Download manager <code>console</code> Different user-facing operations like download, preload and web-ui <code>__init__</code> Contains spotdl class that simplifies the download process"},{"location":"CONTRIBUTING/#join-the-project-team","title":"Join The Project Team","text":""},{"location":"CONTRIBUTING/#attribution","title":"Attribution","text":"<p>This guide is based on the contributing-gen. Make your own!</p>"},{"location":"installation/","title":"spotDL Installation Guide","text":"<p>spotDL is a free and open source tool that downloads your Spotify playlists &amp; music</p> <p>The fastest, easiest, and most accurate command-line music downloader</p>"},{"location":"installation/#install-via-python","title":"Install via Python","text":"<p>This is our recommended installation method.</p> <p>If you are on Windows, Install Visual C++ Redistributible (link below) and then proceed to install Python &amp; FFmpeg</p>"},{"location":"installation/#prerequisites-to-spotdl","title":"Prerequisites to spotDL","text":"<ul> <li>Visual C++ 2019 redistributable   (on Windows)</li> <li>Python 3.7 or above (added to PATH)</li> <li>FFmpeg 4.2 or above (added to PATH)</li> </ul>"},{"location":"installation/#install-python-to-path","title":"Install Python to PATH","text":"<p>We recommend installing the latest version of Python</p> <p>When installing Python, ensure to select \"Add to PATH\".</p> <p></p>"},{"location":"installation/#installing-spotdl","title":"Installing spotDL","text":"<p>If you are not on Windows (e.g. OSX/UNIX), replace <code>pip</code> with <code>pip3</code> and <code>python</code> with <code>python3</code> in all commands.</p> <p>Firstly, open a terminal. On Windows: Command Prompt, OSX: \"Terminal\", *UNIX: Bash or Zsh.</p> <p>Verify you have installed Python correctly via <code>python -V</code>. Ensure you have v3.7 or greater.</p> <p>Next, install spotDL by typing the following</p> <pre><code>pip install spotdl\n</code></pre>"},{"location":"installation/#installing-ffmpeg","title":"Installing FFmpeg","text":"<p>If using FFmpeg only for spotDL, you can install FFmpeg to your local directory. <code>spotdl --download-ffmpeg</code> will download FFmpeg to your spotDL installation directory.</p> <p>We reccomend the above option, but if you want to install FFmpeg system-wide,</p> <ul> <li>Windows Tutorial</li> <li>OSX - <code>brew install ffmpeg</code></li> <li>Linux - <code>sudo apt install ffmpeg</code> or use your distro's package manager</li> </ul> <p>If you require further help, ask in our Discord Server</p> <p></p>"},{"location":"installation/#using-prebuilt-executable","title":"Using Prebuilt Executable","text":""},{"location":"installation/#download-the-executable","title":"Download the executable","text":"<p>You can download the latest version from from the Releases Tab</p>"},{"location":"installation/#running-web-ui","title":"Running Web UI","text":"<p>Web UI will start by default if no arguments are passed to the command line (after double-clicking for example)</p> <p></p>"},{"location":"installation/#running-the-cli","title":"Running the CLI","text":"<p>To use the command line interface just open your terminal and run <code>./spotdl-vX.X.X operation [urls]</code></p>"},{"location":"installation/#docker-setup","title":"Docker Setup","text":"<p>spotDL provides a Docker image.</p> <p>Install Docker: https://docs.docker.com/engine/installation/</p> <p>Install Docker Compose: https://docs.docker.com/compose/install/</p> <p>Docker documentation: https://docs.docker.com/</p>"},{"location":"installation/#built-in-docker-image","title":"Built-in Docker Image","text":"<ul> <li>Build docker image <code>docker build -t spotdl .</code></li> <li>List spotdl options: <code>docker run --rm spotdl --help</code></li> <li>Download a song:   <code>docker run --rm -v $(pwd):/music spotdl download https://open.spotify.com/track/0VjIjW4GlUZAMYd2vXMi3b</code></li> </ul>"},{"location":"installation/#docker-hub-image","title":"Docker Hub Image","text":"<ul> <li> <p>Pull docker image from Docker hub: <code>docker pull spotdl/spotify-downloader</code></p> </li> <li> <p>Download a song using Docker image:   <code>docker run --rm -v $(pwd):/music spotdl/spotify-downloader download https://open.spotify.com/track/0VjIjW4GlUZAMYd2vXMi3b</code></p> </li> <li> <p>Create a Docker container</p> </li> </ul> <pre><code>docker create \\\n  --name=spotdl \\\n  -v &lt;path to data&gt;:/music \\\n  spotdl/spotify-downloader\n</code></pre>"},{"location":"installation/#docker-compose","title":"Docker Compose","text":"<ul> <li>Create a container using Docker Compose: <code>docker-compose up --no-start</code></li> <li>Download a song using Docker compose:   <code>docker-compose run --rm spotdl download https://open.spotify.com/track/0VjIjW4GlUZAMYd2vXMi3b</code></li> </ul>"},{"location":"installation/#other-installation-methods","title":"Other Installation Methods","text":""},{"location":"installation/#termux","title":"Termux","text":"<p>We have a dedicated Termux installation script <code>curl -L https://raw.githubusercontent.com/spotDL/spotify-downloader/master/scripts/termux.sh | sh</code></p>"},{"location":"installation/#arch-user-repository-aur-package","title":"Arch User Repository (AUR) package","text":"<p>You can find the AUR Package here</p>"},{"location":"installation/#where-does-spotdl-download-songs","title":"Where does spotDL download songs?","text":"<p>spotDL downloads files to the folder where you ran spotDL from.</p> <p>Open pwsh/powershell/cmd/terminal/similar in the folder you want files to download to, or cd to desired folder.</p> <p>Windows Shortcut: Navigate to the folder you want the files to download to. <code>SHIFT + RIGHT CLICK</code>, then select \"Open PowerShell window here\"</p> <p></p>"},{"location":"installation/#we-have-a-public-discord-server-at-discordggxca23pwjwy","title":"We have a public Discord server at discord.gg/xCa23pwJWY!","text":""},{"location":"troubleshooting/","title":"Troubleshooting / FAQ Guide","text":"<p>As common issues or questions are encountered solutions will be added to this guide.</p> 'spotdl' is not recognized <p>Python/(site packages) is not added to PATH correctly. You need to install Python from https://www.python.org/downloads/</p> <p>Or you are using python from microsoft store. If so uninstall it and restart cmd. If this doesn't work reinstall python.</p> spotdl: command not found <p>If you see this error after installing spotdl, that means that the bin (Binaries) folder is not on <code>$PATH</code></p> pkg_resources.DistributionNotFound <p>Sometimes not all packages are installed but are required by yt-dlp for example: <code>brotli</code> or <code>websockets</code></p> HTTP Error 404 <p>https://github.com/plamere/spotipy/issues/795#issuecomment-1100321148</p> ssl.SSLError: [SSL: CERTIFICATE_VERIFY_FAILED] <p>https://stackoverflow.com/questions/27835619/urllib-and-ssl-certificate-verify-failed-error</p> RecursionError <p>https://github.com/spotDL/spotify-downloader/issues/1493</p> RuntimeWarning <p>This happens when running spotdl using <code>python -m</code>.</p> Not found '_raw_ecb.so' <p>This error is specific for M1 Macs only.</p> <p>https://discord.com/channels/771628785447337985/871006150357823498 https://discord.com/channels/771628785447337985/939475659238043738</p>"},{"location":"troubleshooting/#error-message","title":"Error message","text":"<pre><code>'spotdl' is not recognized as an internal or external command,\noperable program or batch file.\n</code></pre>"},{"location":"troubleshooting/#solution","title":"Solution","text":"<p>Ensure to add to PATH when installing: </p>"},{"location":"troubleshooting/#solution_1","title":"Solution","text":""},{"location":"troubleshooting/#bashrc","title":"<code>.bashrc</code>","text":"<p>Add <code>export PATH=~/.local/bin:$PATH</code> at the bottom of <code>~/.bashrc</code></p> <p>Then run <code>source ~/.bashrc</code></p>"},{"location":"troubleshooting/#zshrc","title":"<code>.zshrc</code>","text":"<p>Add <code>export PATH=~/.local/bin:$PATH</code> at the bottom of <code>~/.zshrc</code> Then run <code>source ~/.zshrc</code></p>"},{"location":"troubleshooting/#error-message_1","title":"Error Message","text":"<p><code>pkg_resources.DistributionNotFound: The 'websockets' distribution was not found and is required by yt-dlp</code></p>"},{"location":"troubleshooting/#solution_2","title":"Solution","text":"<p><code>pip install brotli websockets yt-dlp -U</code></p>"},{"location":"troubleshooting/#error-message_2","title":"Error Message","text":"<p><code>HTTP Error for GET to URL with Params: {} returned 404 due to None</code></p>"},{"location":"troubleshooting/#solution_3","title":"Solution","text":"<p>Update spotdl to the latest version which contains workaround.</p> <p><code>pip install -U spotdl</code></p>"},{"location":"troubleshooting/#error-message_3","title":"Error Message","text":"<p><code>urllib.error.URLError: &lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:847)&gt;</code></p>"},{"location":"troubleshooting/#solution_4","title":"Solution","text":"<p>https://stackoverflow.com/questions/27835619/urllib-and-ssl-certificate-verify-failed-error</p>"},{"location":"troubleshooting/#error-message_4","title":"Error Message","text":"<p><code>RecursionError: maximum recursion depth exceeded</code></p>"},{"location":"troubleshooting/#solution_5","title":"Solution","text":"<p>Update spotdl</p> <p><code>pip install spotdl -U</code></p>"},{"location":"troubleshooting/#error-message_5","title":"Error Message","text":"<pre><code>RuntimeWarning: 'spotdl.__main__' found in sys.modules after import of package 'spotdl',\nbut prior to execution of 'spotdl.__main__'; this may result in unpredictable behaviour\nwarn(RuntimeWarning(msg))\n</code></pre>"},{"location":"troubleshooting/#solution_6","title":"Solution","text":"<p>You can ignore this error or just run spotdl directly</p>"},{"location":"troubleshooting/#error-message_6","title":"Error Message","text":"<pre><code>aise OSError(\"Cannot load native module '%s': %s\" % (name, \", \".join(attempts)))\nOSError: Cannot load native module 'Cryptodome.Cipher._raw_ecb': Not found '_raw_ecb.cpython-39-darwin.so',\nCannot load '_raw_ecb.abi3.so': dlopen(/opt/homebrew/lib/python3.9/site-packages/Cryptodome/Util/../Cipher/_raw_ecb.abi3.so, 6): no suitable image found.  Did find:\n/opt/homebrew/lib/python3.9/site-packages/Cryptodome/Util/../Cipher/_raw_ecb.abi3.so: mach-o, but wrong architecture\n/opt/homebrew/lib/python3.9/site-packages/Cryptodome/Cipher/_raw_ecb.abi3.so: mach-o, but wrong architecture, Not found '_raw_ecb.so'\n</code></pre>"},{"location":"troubleshooting/#solution_7","title":"Solution","text":"<p>Possible solutions:</p> <p>https://discord.com/channels/771628785447337985/871006150357823498 https://discord.com/channels/771628785447337985/939475659238043738</p>"},{"location":"usage/","title":"spotDL usage examples","text":""},{"location":"usage/#downloading","title":"Downloading","text":"Song <p>To download a song, run</p> <pre><code>spotdl download [trackUrl]\n</code></pre> <p>example:</p> <pre><code>spotdl download https://open.spotify.com/track/0VjIjW4GlUZAMYd2vXMi3b\n</code></pre> Album <p>To download an album, run</p> <pre><code>spotdl download [albumUrl]\n</code></pre> <p>example:</p> <pre><code>spotdl download https://open.spotify.com/album/4yP0hdKOZPNshxUOjY0cZj\n</code></pre> Playlist <p>To download a playlist, run</p> <pre><code>spotdl download [playlistUrl]\n</code></pre> <p>example:</p> <pre><code>spotdl download https://open.spotify.com/playlist/37i9dQZF1E8UXBoz02kGID\n</code></pre> Artist <p>To download all songs from an artist run</p> <pre><code>spotdl download [artistUrl]\n</code></pre> <p>example:</p> <pre><code>spotdl download https://open.spotify.com/artist/1Xyo4u8uXC1ZmMpatF05PJ\n</code></pre> Search <p>To search for and download a song, run, with quotation marks</p> <pre><code>spotdl download '[songQuery]'\n</code></pre> <p>example:</p> <pre><code>spotdl download 'The Weeknd - Blinding Lights'\n</code></pre> YouTube link with Spotify metadata <p>To download YouTube video with metadata from Spotify, run</p> <p>Noting the quote <code>\"</code> are required</p> <pre><code>spotdl download \"YouTubeURL|SpotifyURL\"\n</code></pre> <p>example:</p> <pre><code>spotdl download \"https://www.youtube.com/watch?v=XXYlFuWEuKI|https://open.spotify.com/track/0VjIjW4GlUZAMYd2vXMi3b?si=b5c0790edc8f4904\"\n</code></pre> <p>You can queue up multiple download tasks by separating the arguments with spaces</p> <pre><code>spotdl download [songQuery1] [albumUrl] [songQuery2] ... (order does not matter)\n</code></pre> <p>example:</p> <pre><code>spotdl download 'The Weeknd - Blinding Lights' https://open.spotify.com/playlist/37i9dQZF1E8UXBoz02kGID ...\n</code></pre>"},{"location":"usage/#syncing","title":"Syncing","text":"<p>Sync function for the console. Keep local files up to date with playlists/albums/etc. This will download new songs and remove the ones that are no longer present in the playlists/albums/etc</p> Initialise Synchronisation <p>To create the sync file run</p> <pre><code>spotdl sync [query] --save-file [fileName]\n</code></pre> <p>example:</p> <pre><code>spotdl sync https://open.spotify.com/playlist/37i9dQZF1E8UXBoz02kGID --save-file 'the-weeknd.sync.spotdl'\n</code></pre> <p>Note: The sync file has to end with .spotdl</p> Syncing <p>To sync the songs run</p> <pre><code>spotdl sync [fileName]\n</code></pre> <p>example:</p> <pre><code>spotdl sync 'the-weeknd.sync.spotdl'\n</code></pre>"},{"location":"usage/#saving","title":"Saving","text":"<p>Saves the songs metadata to a file for further use.</p> <pre><code>spotdl save [query] --save-file [fileName]\n</code></pre> <p>example:</p> <pre><code>spotdl save 'The Weeknd - Blinding Lights' --save-file 'the-weeknd.spotdl'\n</code></pre> Preloading <p>Preload the download url to speed up the download process.</p> <pre><code>spotdl save [query] --save-file [fileName] --preload\n</code></pre> <p>example:</p> <pre><code>spotdl save 'The Weeknd - Blinding Lights' --save-file 'the-weeknd.spotdl' --preload\n</code></pre>"},{"location":"usage/#web-ui-user-interface","title":"Web UI (User Interface)","text":"<p>To start the web UI, run</p> <pre><code>spotdl web\n</code></pre>"},{"location":"usage/#config-file","title":"Config file","text":""},{"location":"usage/#config-file-location","title":"Config file location","text":"<p>The config file is located at <code>C:\\Users\\user\\.spotdl\\config.json</code> or <code>~/.spotdl/config.json</code> under linux</p> <p>Note: If you want to use XDG_DATA_HOME directory, run <code>mkdir $XDG_DATA_HOME/spotdl</code>, next time you run spotdl it will be automatically used.</p>"},{"location":"usage/#generate-a-config-file","title":"Generate a config file","text":"<p>To generate a config file, run</p> <pre><code>spotdl --generate-config\n</code></pre> <p>Note: This will overwrite the existing config file.</p>"},{"location":"usage/#loading-config","title":"Loading config","text":"<p>Config file gets loaded automatically if it already exists, or if you've passed <code>--config</code> flag</p> <p>If you don't want config to load automatically change <code>load_config</code> option in config file to false</p> <pre><code>{\n\"load_config\": false\n}\n</code></pre>"},{"location":"usage/#default-config","title":"Default config","text":"<pre><code>{\n\"load_config\": true,\n\"log_level\": \"INFO\",\n\"simple_tui\": false,\n\"cache_path\": \"C:\\\\Users\\\\username\\\\.spotdl\\\\.spotipy\",\n\"audio_providers\": [\n\"youtube-music\"\n],\n\"lyrics_providers\": [\n\"genius\",\n\"azlyrics\"\n\"musixmatch\",\n],\n\"ffmpeg\": \"ffmpeg\",\n\"bitrate\": null,\n\"ffmpeg_args\": null,\n\"format\": \"mp3\",\n\"save_file\": null,\n\"m3u\": null,\n\"output\": \"{artists} - {title}.{output-ext}\",\n\"overwrite\": \"skip\",\n\"client_id\": \"5f573c9620494bae87890c0f08a60293\",\n\"client_secret\": \"212476d9b0f3472eaa762d90b19b0ba8\",\n\"auth_token\": null,\n\"user_auth\": false,\n\"search_query\": null,\n\"filter_results\": true,\n\"threads\": 4,\n\"no_cache\": false,\n\"cookie_file\": null,\n\"headless\": false,\n\"restrict\": false,\n\"print_errors\": false,\n\"sponsor_block\": false,\n\"preload\": false,\n\"archive\": null,\n\"playlist_numbering\": false\n}\n</code></pre>"},{"location":"usage/#cli-command-line-interface","title":"CLI (Command Line Interface)","text":""},{"location":"usage/#command-line-options","title":"Command line options","text":"<pre><code>options:\n  -h, --help            show this help message and exit\n\nMain options:\n  {download,save,web,sync,meta}\n                        The operation to perform.\n                        download: Download the songs to the disk and embed metadata.\n                        save: Saves the songs metadata to a file for further use.\n                        web: Starts a web interface to simplify the download process.\n                        sync: Removes songs that are no longer present, downloads new ones\n                        meta: Update your audio files with metadata\n  query                 Spotify URL for a song/playlist/album/artist/etc. to download. For album searching, include 'album:' and optional 'artist:' tags (ie. 'album:the album name' or 'artist:the artist album: the album').\n                        For manual audio matching, you can use the format 'YouTubeURL|SpotifyURL'\n  --audio [{youtube,youtube-music} ...]\n                        The audio provider to use. You can provide more than one for fallback.\n  --lyrics [{genius,musixmatch,azlyrics} ...]\n                        The lyrics provider to use. You can provide more than one for fallback.\n  --config              Use the config file to download songs. It's located under C:\\Users\\user\\.spotdl\\config.json or ~/.spotdl/config.json under linux\n  --search-query SEARCH_QUERY\n                        The search query to use, available variables: {title}, {artists}, {artist}, {album}, {album-artist}, {genre}, {disc-number}, {disc-count}, {duration}, {year}, {original-date}, {track-number},\n                        {tracks-count}, {isrc}, {track-id}, {publisher}, {list-length}, {list-position}, {list-name}, {output-ext}\n  --dont-filter-results\n                        Disable filtering results.\n\nSpotify options:\n  --user-auth           Login to Spotify using OAuth.\n  --client-id CLIENT_ID\n                        The client id to use when logging in to Spotify.\n  --client-secret CLIENT_SECRET\n                        The client secret to use when logging in to Spotify.\n  --auth-token AUTH_TOKEN\n                        The authorisation token to use directly to log in to Spotify.\n  --cache-path CACHE_PATH\n                        The path where spotipy cache file will be stored.\n  --no-cache            Disable caching (both requests and token).\n  --cookie-file COOKIE_FILE\n                        Path to cookies file.\n\nFFmpeg options:\n  --ffmpeg FFMPEG       The ffmpeg executable to use.\n  --threads THREADS     The number of threads to use when downloading songs.\n  --bitrate {8k,16k,24k,32k,40k,48k,64k,80k,96k,112k,128k,160k,192k,224k,256k,320k,0,1,2,3,4,5,6,7,8,9}\n                        The constant/variable bitrate to use for the output file. Values from 0 to 9 are variable bitrates.\n  --ffmpeg-args FFMPEG_ARGS\n                        Additional ffmpeg arguments passed as a string.\n  --preserve-original-audio\n                        Preserve the original audio stream in case of m4a and opus files. This option might overwrite the bitrate option. Adding additional ffmpeg arguments might make this option useless.\n\nOutput options:\n  --format {mp3,flac,ogg,opus,m4a}\n                        The format to download the song in.\n  --save-file SAVE_FILE\n                        The file to save/load the songs data from/to. It has to end with .spotdl. If combined with the download operation, it will save the songs data to the file. Required for save/preload/sync\n  --preload             Preload the download url to speed up the download process.\n  --output OUTPUT       Specify the downloaded file name format, available variables: {title}, {artists}, {artist}, {album}, {album-artist}, {genre}, {disc-number}, {disc-count}, {duration}, {year}, {original-date}, {track-\n                        number}, {tracks-count}, {isrc}, {track-id}, {publisher}, {list-length}, {list-position}, {list-name}, {output-ext}\n  --m3u [M3U]           Name of the m3u file to save the songs to. Defaults to {list[0]}.m3u If you want to generate a m3u for each list in the query use {list-name}, If you want to generate a m3u file based on the first\n                        list in the query use {list[0]}, (0 is the first list in the query, 1 is the second, etc. songs don't count towards the list number)\n  --overwrite {skip,metadata,force}\n                        Overwrite existing files.\n  --restrict            Restrict filenames to ASCII only\n  --print-errors        Print errors (wrong songs, failed downloads etc) on exit, useful for long playlist\n  --sponsor-block       Use the sponsor block to download songs from yt/ytm.\n  --archive ARCHIVE     Specify the file name for an archive of already downloaded songs\n  --playlist-numbering  Sets each track in a playlist to have the playlist's name as its album, and album art as the playlist's icon\n\nWeb options:\n  --host HOST           The host to use for the web server.\n  --port PORT           The port to run the web server on.\n  --keep-alive          Keep the web server alive even when no clients are connected.\n  --allowed-origins [ALLOWED_ORIGINS ...]\n                        The allowed origins for the web server.\n\nMisc options:\n  --log-level {CRITICAL,FATAL,ERROR,WARN,WARNING,INFO,DEBUG,NOTSET}\n                        Select log level.\n  --simple-tui          Use a simple tui.\n  --headless            Run in headless mode.\n\nOther options:\n  --download-ffmpeg     Download ffmpeg to spotdl directory.\n  --generate-config     Generate a config file. This will overwrite current config if present.\n  --check-for-updates   Check for new version.\n  --profile             Run in profile mode. Useful for debugging.\n  --version, -v         Show the version number and exit.\n</code></pre>"},{"location":"reference/","title":"__init__","text":"<p>Init module for spotdl. This module contains the main entry point for spotdl. And Spotdl class</p>"},{"location":"reference/#spotdl.Spotdl","title":"<code>Spotdl(client_id, client_secret, user_auth=False, cache_path=None, no_cache=False, headless=False, audio_providers=None, lyrics_providers=None, ffmpeg='ffmpeg', bitrate=None, ffmpeg_args=None, output_format='mp3', threads=4, output='.', save_file=None, overwrite='skip', cookie_file=None, filter_results=True, search_query=None, log_level='INFO', simple_tui=False, loop=None, restrict=False, print_errors=False, sponsor_block=False, preserve_original_audio=False)</code>","text":"<p>Spotdl class, which simplifies the process of downloading songs from Spotify.</p> <pre><code>from spotdl import Spotdl\n\nspotdl = Spotdl(client_id='your-client-id', client_secret='your-client-secret')\n\nsongs = spotdl.search(['joji - test drive',\n    'https://open.spotify.com/track/4cOdK2wGLETKBW3PvgPWqT'])\n\nresults = spotdl.download_songs(songs)\nsong, path = spotd.download(songs[0])\n</code></pre>"},{"location":"reference/#spotdl.Spotdl--arguments","title":"Arguments","text":"<ul> <li>client_id: Spotify client id</li> <li>client_secret: Spotify client secret</li> <li>user_auth: If true, user will be prompted to authenticate</li> <li>cache_path: Path to cache directory</li> <li>no_cache: If true, no cache will be used</li> <li>headless: If true, no browser will be opened</li> <li>audio_providers: The audio providers to use.</li> <li>lyrics_providers: The lyrics providers to use.</li> <li>ffmpeg: The ffmpeg executable to use.</li> <li>bitrate: The constant/variable bitrate to use.</li> <li>ffmpeg_args: The ffmpeg arguments to use.</li> <li>output_format: The output format to use.</li> <li>threads: The number of threads to use.</li> <li>output: The output directory to use.</li> <li>save_file: The save file to use when saving/loading song metadata.</li> <li>overwrite: The overwrite mode to use (force/skip).</li> <li>cookie_file: The cookie file to use for yt-dlp.</li> <li>filter_results: Whether to filter results.</li> <li>search_query: The search query to use.</li> <li>log_level: The log level to use.</li> <li>simple_tui: Whether to use simple tui.</li> <li>loop: The event loop to use.</li> <li>restrict: Whether to restrict the filename to ASCII characters.</li> <li>print_errors: Whether to print errors on exit.</li> <li>sponsor_block: Whether to remove sponsor segments using sponsor block postprocessor.</li> <li>preserve_original_audio: Whether to preserve the original audio file.</li> </ul>"},{"location":"reference/#spotdl.Spotdl--notes","title":"Notes","text":"<ul> <li><code>search-query</code> uses the same format as <code>output</code>.</li> </ul> Source code in <code>spotdl/__init__.py</code> <pre><code>def __init__(\n    self,\n    client_id: str,\n    client_secret: str,\n    user_auth: bool = False,\n    cache_path: Optional[str] = None,\n    no_cache: bool = False,\n    headless: bool = False,\n    audio_providers: Optional[List[str]] = None,\n    lyrics_providers: Optional[List[str]] = None,\n    ffmpeg: str = \"ffmpeg\",\n    bitrate: Optional[str] = None,\n    ffmpeg_args: Optional[str] = None,\n    output_format: str = \"mp3\",\n    threads: int = 4,\n    output: str = \".\",\n    save_file: Optional[str] = None,\n    overwrite: str = \"skip\",\n    cookie_file: Optional[str] = None,\n    filter_results: bool = True,\n    search_query: Optional[str] = None,\n    log_level: str = \"INFO\",\n    simple_tui: bool = False,\n    loop: Optional[asyncio.AbstractEventLoop] = None,\n    restrict: bool = False,\n    print_errors: bool = False,\n    sponsor_block: bool = False,\n    preserve_original_audio: bool = False,\n):\n\"\"\"\n    Initialize the Spotdl class\n\n    ### Arguments\n    - client_id: Spotify client id\n    - client_secret: Spotify client secret\n    - user_auth: If true, user will be prompted to authenticate\n    - cache_path: Path to cache directory\n    - no_cache: If true, no cache will be used\n    - headless: If true, no browser will be opened\n    - audio_providers: The audio providers to use.\n    - lyrics_providers: The lyrics providers to use.\n    - ffmpeg: The ffmpeg executable to use.\n    - bitrate: The constant/variable bitrate to use.\n    - ffmpeg_args: The ffmpeg arguments to use.\n    - output_format: The output format to use.\n    - threads: The number of threads to use.\n    - output: The output directory to use.\n    - save_file: The save file to use when saving/loading song metadata.\n    - overwrite: The overwrite mode to use (force/skip).\n    - cookie_file: The cookie file to use for yt-dlp.\n    - filter_results: Whether to filter results.\n    - search_query: The search query to use.\n    - log_level: The log level to use.\n    - simple_tui: Whether to use simple tui.\n    - loop: The event loop to use.\n    - restrict: Whether to restrict the filename to ASCII characters.\n    - print_errors: Whether to print errors on exit.\n    - sponsor_block: Whether to remove sponsor segments using sponsor block postprocessor.\n    - preserve_original_audio: Whether to preserve the original audio file.\n\n    ### Notes\n    - `search-query` uses the same format as `output`.\n    \"\"\"\n\n    if audio_providers is None:\n        audio_providers = [\"youtube-music\"]\n\n    if lyrics_providers is None:\n        lyrics_providers = [\"musixmatch\"]\n\n    # Initialize spotify client\n    SpotifyClient.init(\n        client_id=client_id,\n        client_secret=client_secret,\n        user_auth=user_auth,\n        cache_path=cache_path,\n        no_cache=no_cache,\n        open_browser=not headless,\n    )\n\n    # Initialize downloader\n    self.downloader = Downloader(\n        audio_providers=audio_providers,\n        lyrics_providers=lyrics_providers,\n        search_query=search_query,\n        ffmpeg=ffmpeg,\n        bitrate=bitrate,\n        ffmpeg_args=ffmpeg_args,\n        output_format=output_format,\n        threads=threads,\n        output=output,\n        save_file=save_file,\n        overwrite=overwrite,\n        cookie_file=cookie_file,\n        filter_results=filter_results,\n        log_level=log_level,\n        simple_tui=simple_tui,\n        loop=loop,\n        restrict=restrict,\n        print_errors=print_errors,\n        sponsor_block=sponsor_block,\n        preserve_original_audio=preserve_original_audio,\n    )\n</code></pre>"},{"location":"reference/#spotdl.Spotdl.download","title":"<code>download(song)</code>","text":"<p>Download and convert song to the output format.</p>"},{"location":"reference/#spotdl.Spotdl.download--arguments","title":"Arguments","text":"<ul> <li>song: Song object</li> </ul>"},{"location":"reference/#spotdl.Spotdl.download--returns","title":"Returns","text":"<ul> <li>A tuple containing the song and the path to the downloaded file if successful.</li> </ul> Source code in <code>spotdl/__init__.py</code> <pre><code>def download(self, song: Song) -&gt; Tuple[Song, Optional[Path]]:\n\"\"\"\n    Download and convert song to the output format.\n\n    ### Arguments\n    - song: Song object\n\n    ### Returns\n    - A tuple containing the song and the path to the downloaded file if successful.\n    \"\"\"\n\n    return self.downloader.download_song(song)\n</code></pre>"},{"location":"reference/#spotdl.Spotdl.download_songs","title":"<code>download_songs(songs)</code>","text":"<p>Download and convert songs to the output format.</p>"},{"location":"reference/#spotdl.Spotdl.download_songs--arguments","title":"Arguments","text":"<ul> <li>songs: List of Song objects</li> </ul>"},{"location":"reference/#spotdl.Spotdl.download_songs--returns","title":"Returns","text":"<ul> <li>A list of tuples containing the song and the path to the downloaded file if successful.</li> </ul> Source code in <code>spotdl/__init__.py</code> <pre><code>def download_songs(self, songs: List[Song]) -&gt; List[Tuple[Song, Optional[Path]]]:\n\"\"\"\n    Download and convert songs to the output format.\n\n    ### Arguments\n    - songs: List of Song objects\n\n    ### Returns\n    - A list of tuples containing the song and the path to the downloaded file if successful.\n    \"\"\"\n\n    return self.downloader.download_multiple_songs(songs)\n</code></pre>"},{"location":"reference/#spotdl.Spotdl.get_download_urls","title":"<code>get_download_urls(songs)</code>","text":"<p>Get the download urls for a list of songs.</p>"},{"location":"reference/#spotdl.Spotdl.get_download_urls--arguments","title":"Arguments","text":"<ul> <li>songs: List of Song objects</li> </ul>"},{"location":"reference/#spotdl.Spotdl.get_download_urls--returns","title":"Returns","text":"<ul> <li>A list of urls if successful.</li> </ul>"},{"location":"reference/#spotdl.Spotdl.get_download_urls--notes","title":"Notes","text":"<ul> <li>This function is multi-threaded.</li> </ul> Source code in <code>spotdl/__init__.py</code> <pre><code>def get_download_urls(self, songs: List[Song]) -&gt; List[Optional[str]]:\n\"\"\"\n    Get the download urls for a list of songs.\n\n    ### Arguments\n    - songs: List of Song objects\n\n    ### Returns\n    - A list of urls if successful.\n\n    ### Notes\n    - This function is multi-threaded.\n    \"\"\"\n\n    urls: List[Optional[str]] = []\n    with concurrent.futures.ThreadPoolExecutor(\n        max_workers=self.downloader.threads\n    ) as executor:\n        future_to_song = {\n            executor.submit(self.downloader.search, song): song for song in songs\n        }\n        for future in concurrent.futures.as_completed(future_to_song):\n            song = future_to_song[future]\n            try:\n                data, _ = future.result()\n                urls.append(data)\n            except Exception as exc:\n                self.downloader.progress_handler.error(\n                    f\"{song} generated an exception: {exc}\"\n                )\n\n    return urls\n</code></pre>"},{"location":"reference/#spotdl.Spotdl.search","title":"<code>search(query)</code>","text":"<p>Search for songs.</p>"},{"location":"reference/#spotdl.Spotdl.search--arguments","title":"Arguments","text":"<ul> <li>query: List of search queries</li> </ul>"},{"location":"reference/#spotdl.Spotdl.search--returns","title":"Returns","text":"<ul> <li>A list of Song objects</li> </ul>"},{"location":"reference/#spotdl.Spotdl.search--notes","title":"Notes","text":"<ul> <li>query can be a list of song titles, urls, uris</li> </ul> Source code in <code>spotdl/__init__.py</code> <pre><code>def search(self, query: List[str]) -&gt; List[Song]:\n\"\"\"\n    Search for songs.\n\n    ### Arguments\n    - query: List of search queries\n\n    ### Returns\n    - A list of Song objects\n\n    ### Notes\n    - query can be a list of song titles, urls, uris\n    \"\"\"\n\n    return parse_query(query, self.downloader.threads)\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>__init__</li> <li>utils<ul> <li>formatter</li> <li>web</li> <li>github</li> <li>archive</li> <li>m3u</li> <li>config</li> <li>metadata</li> <li>spotify</li> <li>search</li> <li>console</li> <li>arguments</li> <li>ffmpeg</li> </ul> </li> <li>download<ul> <li>downloader</li> <li>progress_handler</li> </ul> </li> <li>console<ul> <li>entry_point</li> <li>web</li> <li>download</li> <li>sync</li> <li>meta</li> <li>save</li> </ul> </li> <li>types<ul> <li>saved</li> <li>playlist</li> <li>artist</li> <li>song</li> <li>album</li> </ul> </li> <li>providers<ul> <li>lyrics<ul> <li>musixmatch</li> <li>genius</li> <li>base</li> <li>azlyrics</li> </ul> </li> <li>audio<ul> <li>youtube</li> <li>base</li> <li>ytmusic</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/console/","title":"console","text":"<p>Console module, contains the console entry point and different subcommands.</p>"},{"location":"reference/console/download/","title":"download","text":"<p>Download module for the console.</p>"},{"location":"reference/console/download/#spotdl.console.download.download","title":"<code>download(query, downloader, save_path=None, m3u_file=None, archive=None, **_)</code>","text":"<p>Find songs with the provided audio provider and save them to the disk.</p>"},{"location":"reference/console/download/#spotdl.console.download.download--arguments","title":"Arguments","text":"<ul> <li>query: list of strings to search for.</li> <li>downloader: Already initialized downloader instance.</li> <li>save_path: Path to save the songs to or None.</li> <li>m3u_file: Path to the m3u file to save the songs to.</li> <li>archive: Path to the archive file to save the songs to.</li> </ul> Source code in <code>spotdl/console/download.py</code> <pre><code>def download(\n    query: List[str],\n    downloader: Downloader,\n    save_path: Optional[Path] = None,\n    m3u_file: Optional[str] = None,\n    archive: Optional[str] = None,\n    **_\n) -&gt; None:\n\"\"\"\n    Find songs with the provided audio provider and save them to the disk.\n\n    ### Arguments\n    - query: list of strings to search for.\n    - downloader: Already initialized downloader instance.\n    - save_path: Path to save the songs to or None.\n    - m3u_file: Path to the m3u file to save the songs to.\n    - archive: Path to the archive file to save the songs to.\n    \"\"\"\n\n    # Parse the query\n    songs = get_simple_songs(query)\n\n    url_archive: Archive = Archive()\n    if archive:\n        url_archive.load(archive)\n        songs = [song for song in songs if song.url not in url_archive]\n\n    results = downloader.download_multiple_songs(songs)\n\n    if archive:\n        for result in results:\n            if result[1]:\n                url_archive.add(result[0].url)\n\n        url_archive.save(archive)\n\n    if m3u_file:\n        song_list = [song for song, _ in results]\n        gen_m3u_files(\n            query,\n            m3u_file,\n            song_list,\n            downloader.output,\n            downloader.output_format,\n            False,\n        )\n\n    if save_path:\n        # Save the songs to a file\n        with open(save_path, \"w\", encoding=\"utf-8\") as save_file:\n            json.dump(\n                [song.json for song, _ in results],\n                save_file,\n                indent=4,\n                ensure_ascii=False,\n            )\n</code></pre>"},{"location":"reference/console/entry_point/","title":"entry_point","text":"<p>Module that holds the entry point for the console.</p>"},{"location":"reference/console/entry_point/#spotdl.console.entry_point.console_entry_point","title":"<code>console_entry_point()</code>","text":"<p>Wrapper around <code>entry_point</code> so we can profile the code</p> Source code in <code>spotdl/console/entry_point.py</code> <pre><code>def console_entry_point():\n\"\"\"\n    Wrapper around `entry_point` so we can profile the code\n    \"\"\"\n\n    if \"--profile\" in sys.argv:\n        with cProfile.Profile() as profile:\n            entry_point()\n\n        stats = pstats.Stats(profile)\n        stats.sort_stats(pstats.SortKey.TIME)\n\n        # Use snakeviz to visualize the profile\n        stats.dump_stats(\"spotdl.profile\")\n    else:\n        entry_point()\n</code></pre>"},{"location":"reference/console/entry_point/#spotdl.console.entry_point.entry_point","title":"<code>entry_point()</code>","text":"<p>Console entry point for spotdl. This is where the magic happens.</p> Source code in <code>spotdl/console/entry_point.py</code> <pre><code>def entry_point():\n\"\"\"\n    Console entry point for spotdl. This is where the magic happens.\n    \"\"\"\n\n    # Don't log too much\n    logging.getLogger(\"requests\").setLevel(logging.WARNING)\n    logging.getLogger(\"urllib3\").setLevel(logging.WARNING)\n    logging.getLogger(\"spotipy\").setLevel(logging.NOTSET)\n    logging.getLogger(\"asyncio\").setLevel(logging.WARNING)\n\n    # Create a console\n    console = Console()\n\n    # Install rich traceback handler\n    install(show_locals=False, extra_lines=1)\n\n    # Create config file if it doesn't exist\n    if get_config_file().is_file() is False:\n        config_path = get_config_file()\n        with open(config_path, \"w\", encoding=\"utf-8\") as config_file:\n            json.dump(DEFAULT_CONFIG, config_file, indent=4)\n\n    if getattr(sys, \"frozen\", False) and len(sys.argv) == 1:\n        # If the application is frozen, we check for ffmpeg\n        # if it's not present download it create config file\n        if is_ffmpeg_installed() is False:\n            download_ffmpeg()\n\n    # Check if sys.argv contains an action\n    # If it does, we run the action and exit\n    for action_name, action in ACTIONS.items():\n        if action_name in sys.argv:\n            action()\n            return None\n\n    # Parse the arguments\n    arguments = parse_arguments()\n\n    # Get the config file\n    # It will automatically load if the `load_config` is set to True\n    # in the config file\n    config = {}\n    if arguments.config or (\n        get_config_file().exists() and get_config().get(\"load_config\")\n    ):\n        config = get_config()\n\n    # Create settings dict\n    # Argument value has always the priority, then the config file\n    # value, and if neither are set, use default value\n    settings = {}\n    for key, default_value in DEFAULT_CONFIG.items():\n        argument_val = arguments.__dict__.get(key)\n        config_val = config.get(key)\n\n        if argument_val is not None:\n            settings[key] = argument_val\n        elif config_val is not None:\n            settings[key] = config_val\n        else:\n            settings[key] = default_value\n\n    # Check if ffmpeg is installed\n    if is_ffmpeg_installed(settings[\"ffmpeg\"]) is False:\n        raise FFmpegError(\n            \"FFmpeg is not installed. Please run `spotdl --download-ffmpeg` to install it, \"\n            \"or `spotdl --ffmpeg /path/to/ffmpeg` to specify the path to ffmpeg.\"\n        )\n\n    if \"youtube-music\" in settings[\"audio_providers\"]:\n        # Check if we are getting results from YouTube Music\n        ytm = YouTubeMusic(settings)\n        test_results = ytm.get_results(\"a\")\n        if len(test_results) == 0:\n            raise AudioProviderError(\n                \"Could not connect to YouTube Music API. Use a VPN or other audio provider.\"\n            )\n\n    # Initialize spotify client\n    SpotifyClient.init(\n        client_id=settings[\"client_id\"],\n        client_secret=settings[\"client_secret\"],\n        auth_token=settings[\"auth_token\"],\n        user_auth=settings[\"user_auth\"],\n        cache_path=settings[\"cache_path\"],\n        no_cache=settings[\"no_cache\"],\n        open_browser=not settings[\"headless\"],\n    )\n\n    # If the application is frozen start web ui\n    # or if the operation is `web`\n    if (\n        getattr(sys, \"frozen\", False)\n        and len(sys.argv) == 1\n        or arguments.operation == \"web\"\n    ):\n        # Start web ui\n        web(settings)\n\n        return None\n\n    # Check if save file is present and if it's valid\n    if isinstance(settings[\"save_file\"], str) and not settings[\"save_file\"].endswith(\n        \".spotdl\"\n    ):\n        raise DownloaderError(\"Save file has to end with .spotdl\")\n\n    if arguments.query and \"saved\" in arguments.query and not settings[\"user_auth\"]:\n        raise SpotifyError(\n            \"You must be logged in to use the saved query. \"\n            \"Log in by adding the --user-auth flag\"\n        )\n\n    # Initialize the downloader\n    # for download, load and preload operations\n    downloader = Downloader(\n        audio_providers=settings[\"audio_providers\"],\n        lyrics_providers=settings[\"lyrics_providers\"],\n        ffmpeg=settings[\"ffmpeg\"],\n        bitrate=settings[\"bitrate\"],\n        ffmpeg_args=settings[\"ffmpeg_args\"],\n        output_format=settings[\"format\"],\n        threads=settings[\"threads\"],\n        output=settings[\"output\"],\n        save_file=settings[\"save_file\"],\n        overwrite=settings[\"overwrite\"],\n        cookie_file=settings[\"cookie_file\"],\n        filter_results=settings[\"filter_results\"],\n        search_query=settings[\"search_query\"],\n        log_level=settings[\"log_level\"],\n        simple_tui=settings[\"simple_tui\"],\n        restrict=settings[\"restrict\"],\n        print_errors=settings[\"print_errors\"],\n        sponsor_block=settings[\"sponsor_block\"],\n        playlist_numbering=settings[\"playlist_numbering\"],\n        preserve_original_audio=settings[\"preserve_original_audio\"],\n    )\n\n    def graceful_exit(_signal, _frame):\n        downloader.progress_handler.close()\n        sys.exit(0)\n\n    signal.signal(signal.SIGINT, graceful_exit)\n    signal.signal(signal.SIGTERM, graceful_exit)\n\n    try:\n        # Pick the operation to perform\n        # based on the name and run it!\n\n        OPERATIONS[arguments.operation](\n            query=arguments.query,\n            save_path=settings[\"save_file\"],\n            preload=settings[\"preload\"],\n            downloader=downloader,\n            m3u_file=settings[\"m3u\"],\n            archive=settings[\"archive\"],\n        )\n\n    except Exception:\n        downloader.progress_handler.close()\n\n        console.print_exception(show_locals=False, extra_lines=1)\n\n        sys.exit(1)\n\n    downloader.progress_handler.close()\n\n    return None\n</code></pre>"},{"location":"reference/console/meta/","title":"meta","text":"<p>Sync Lyrics module for the console</p>"},{"location":"reference/console/meta/#spotdl.console.meta.meta","title":"<code>meta(query, downloader, **_)</code>","text":"<p>This function applies metadata to the selected songs based on the file name. If song already has metadata, missing metadata is added</p>"},{"location":"reference/console/meta/#spotdl.console.meta.meta--arguments","title":"Arguments","text":"<ul> <li>query: list of strings to search for.</li> <li>downloader: Already initialized downloader instance.</li> </ul>"},{"location":"reference/console/meta/#spotdl.console.meta.meta--notes","title":"Notes","text":"<ul> <li>This function is multi-threaded.</li> </ul> Source code in <code>spotdl/console/meta.py</code> <pre><code>def meta(query: List[str], downloader: Downloader, **_) -&gt; None:\n\"\"\"\n    This function applies metadata to the selected songs\n    based on the file name.\n    If song already has metadata, missing metadata is added\n\n    ### Arguments\n    - query: list of strings to search for.\n    - downloader: Already initialized downloader instance.\n\n    ### Notes\n    - This function is multi-threaded.\n    \"\"\"\n\n    # Create a list of all songs from all paths in query\n    paths: List[Path] = []\n    for path in query:\n        test_path = Path(path)\n        if not test_path.exists():\n            downloader.progress_handler.error(\"Path does not exist: \" + path)\n            continue\n\n        if test_path.is_dir():\n            for out_format in FFMPEG_FORMATS:\n                paths.extend(test_path.glob(f\"*.{out_format}\"))\n        elif test_path.is_file():\n            if test_path.suffix.split(\".\")[-1] not in FFMPEG_FORMATS:\n                downloader.progress_handler.error(\n                    \"File is not a supported audio format: \" + path\n                )\n                continue\n\n            paths.append(test_path)\n\n    def process_file(file: Path):\n        song_meta = get_song_metadata(file)\n\n        if (\n            song_meta\n            and song_meta[\"lyrics\"] is not None\n            and song_meta[\"title\"][0] != \"\"\n        ):\n            downloader.progress_handler.log(\"Song already has metadata: \" + file.name)\n            return None\n\n        # Check if we have metadata if not use spotify\n        # to get the metadata\n        if (\n            song_meta is None\n            or song_meta[\"title\"][0] == \"\"\n            or song_meta[\"tracknumber\"][0] == \"\"\n        ):\n            song = get_search_results(file.name.rsplit(\".\", 1)[0])[0]\n        else:\n            try:\n                song = create_empty_song(\n                    name=song_meta[\"title\"],\n                    artists=[\n                        artist.strip()\n                        for artist in song_meta[\"artist\"].strip().split(\"/\")\n                    ],\n                    album_name=song_meta[\"album\"],\n                    album_artist=song_meta[\"albumartist\"],\n                    genres=[song_meta[\"genre\"]],\n                    disc_number=int(song_meta[\"discnumber\"].split(\"/\")[0]),\n                    disc_count=int(song_meta[\"discnumber\"].split(\"/\")[1]),\n                    duration=int(song_meta[\"duration\"]),\n                    year=int(song_meta[\"year\"]),\n                    track_number=int(song_meta[\"tracknumber\"].split(\"/\")[0]),\n                    tracks_count=int(song_meta[\"tracknumber\"].split(\"/\")[1]),\n                    isrc=song_meta[\"isrc\"],\n                    publisher=song_meta[\"publisher\"],\n                    url=song_meta[\"url\"],\n                    copyright_text=song_meta[\"copyright\"],\n                )\n            except Exception:\n                song = get_search_results(file.name.rsplit(\".\", 1)[0])[0]\n\n        # Check if the song has lyric\n        # if not use downloader to find lyrics\n        if song_meta is None or song_meta.get(\"lyrics\") is None:\n            downloader.progress_handler.debug(\n                f\"Fetching lyrics for {song.display_name}\"\n            )\n            lyrics = downloader.search_lyrics(song)\n            if lyrics:\n                song.lyrics = lyrics\n                downloader.progress_handler.log(\n                    f\"No lyrics found for song: {song.display_name}\"\n                )\n\n        # Apply metadata to the song\n        embed_metadata(file, song, file.suffix.split(\".\")[-1])\n\n        downloader.progress_handler.log(f\"Applied metadata to {file.name}\")\n\n        return None\n\n    async def pool_worker(file_path: Path) -&gt; None:\n        async with downloader.semaphore:\n            # The following function calls blocking code, which would block whole event loop.\n            # Therefore it has to be called in a separate thread via ThreadPoolExecutor. This\n            # is not a problem, since GIL is released for the I/O operations, so it shouldn't\n            # hurt performance.\n            await downloader.loop.run_in_executor(\n                downloader.thread_executor, process_file, file_path\n            )\n\n    tasks = [pool_worker(path) for path in paths]\n\n    # call all task asynchronously, and wait until all are finished\n    downloader.loop.run_until_complete(downloader.aggregate_tasks(tasks))\n</code></pre>"},{"location":"reference/console/save/","title":"save","text":"<p>Save module for the console.</p>"},{"location":"reference/console/save/#spotdl.console.save.save","title":"<code>save(query, downloader, save_path, m3u_file=None, preload=False, **_)</code>","text":"<p>Save metadata from spotify to the disk.</p>"},{"location":"reference/console/save/#spotdl.console.save.save--arguments","title":"Arguments","text":"<ul> <li>query: list of strings to search for.</li> <li>downloader: Already initialized downloader instance.</li> <li>save_path: Path to save the songs to.</li> <li>m3u_file: Path to the m3u file to save the songs to.</li> <li>preload: If True, preload the songs.</li> </ul>"},{"location":"reference/console/save/#spotdl.console.save.save--notes","title":"Notes","text":"<ul> <li>This function is multi-threaded.</li> </ul> Source code in <code>spotdl/console/save.py</code> <pre><code>def save(\n    query: List[str],\n    downloader: Downloader,\n    save_path: Path,\n    m3u_file: Optional[str] = None,\n    preload: bool = False,\n    **_,\n) -&gt; None:\n\"\"\"\n    Save metadata from spotify to the disk.\n\n    ### Arguments\n    - query: list of strings to search for.\n    - downloader: Already initialized downloader instance.\n    - save_path: Path to save the songs to.\n    - m3u_file: Path to the m3u file to save the songs to.\n    - preload: If True, preload the songs.\n\n    ### Notes\n    - This function is multi-threaded.\n    \"\"\"\n\n    # Parse the query\n    songs = parse_query(query, downloader.threads)\n    save_data = [song.json for song in songs]\n\n    def process_song(song: Song):\n        try:\n            data, _ = downloader.search(song)\n            if data is None:\n                downloader.progress_handler.error(\n                    f\"Could not find a match for {song.display_name}\"\n                )\n\n                return None\n\n            downloader.progress_handler.log(\n                f\"Found url for {song.display_name}: {data}\"\n            )\n\n            return {**song.json, \"download_url\": data}\n        except Exception as exception:\n            downloader.progress_handler.error(\n                f\"{song} generated an exception: {exception}\"\n            )\n\n        return None\n\n    async def pool_worker(song: Song):\n        async with downloader.semaphore:\n            # The following function calls blocking code, which would block whole event loop.\n            # Therefore it has to be called in a separate thread via ThreadPoolExecutor. This\n            # is not a problem, since GIL is released for the I/O operations, so it shouldn't\n            # hurt performance.\n            return await downloader.loop.run_in_executor(\n                downloader.thread_executor, process_song, song\n            )\n\n    if preload:\n        tasks = [pool_worker(song) for song in songs]\n\n        # call all task asynchronously, and wait until all are finished\n        save_data = list(\n            downloader.loop.run_until_complete(downloader.aggregate_tasks(tasks))\n        )\n\n    # Save the songs to a file\n    with open(save_path, \"w\", encoding=\"utf-8\") as save_file:\n        json.dump(save_data, save_file, indent=4, ensure_ascii=False)\n\n    if m3u_file:\n        gen_m3u_files(\n            query, m3u_file, songs, downloader.output, downloader.output_format, False\n        )\n\n    downloader.progress_handler.log(\n        f\"Saved {len(save_data)} song{'s' if len(save_data) &gt; 1 else ''} to {save_path}\"\n    )\n</code></pre>"},{"location":"reference/console/sync/","title":"sync","text":"<p>Sync module for the console.</p>"},{"location":"reference/console/sync/#spotdl.console.sync.sync","title":"<code>sync(query, downloader, save_path=None, m3u_file=None, **_)</code>","text":"<p>Sync function for the console. It will download the songs and remove the ones that are no longer present in the playlists/albums/etc</p>"},{"location":"reference/console/sync/#spotdl.console.sync.sync--arguments","title":"Arguments","text":"<ul> <li>query: list of strings to search for.</li> <li>downloader: Already initialized downloader instance.</li> <li>save_path: Path to save the songs to.</li> <li>m3u_file: Path to the file to save the metadata to.</li> </ul> Source code in <code>spotdl/console/sync.py</code> <pre><code>def sync(\n    query: List[str],\n    downloader: Downloader,\n    save_path: Optional[Path] = None,\n    m3u_file: Optional[str] = None,\n    **_,\n) -&gt; None:\n\"\"\"\n    Sync function for the console.\n    It will download the songs and remove the ones that are no longer\n    present in the playlists/albums/etc\n\n\n    ### Arguments\n    - query: list of strings to search for.\n    - downloader: Already initialized downloader instance.\n    - save_path: Path to save the songs to.\n    - m3u_file: Path to the file to save the metadata to.\n    \"\"\"\n\n    downloader.save_file = None\n\n    # Query and save file\n    # Create initial sync file\n    if query and save_path:\n        if any(req for req in query if req.endswith(\".spotdl\")):\n            # If the query contains a .spotdl file, and we are about to create\n            # .spotdl file, raise an error.\n            raise ValueError(\n                \"Cannot create a sync file with a .spotdl file in the query.\"\n            )\n\n        # Parse the query\n        songs_list = parse_query(query, downloader.threads)\n\n        # Create sync file\n        with open(save_path, \"w\", encoding=\"utf-8\") as save_file:\n            json.dump(\n                {\n                    \"type\": \"sync\",\n                    \"query\": query,\n                    \"songs\": [song.json for song in songs_list],\n                },\n                save_file,\n                indent=4,\n                ensure_ascii=False,\n            )\n\n        # Perform initial download\n        downloader.download_multiple_songs(songs_list)\n\n        # Create m3u file\n        if m3u_file:\n            gen_m3u_files(\n                query,\n                m3u_file,\n                songs_list,\n                downloader.output,\n                downloader.output_format,\n                False,\n            )\n\n        return None\n\n    # If the query is a single file, download it\n    if len(query) == 1 and query[0].endswith(\".spotdl\") and not save_path:\n        # Load the sync file\n        with open(query[0], \"r\", encoding=\"utf-8\") as sync_file:\n            sync_data = json.load(sync_file)\n\n        # Verify the sync file\n        if sync_data.get(\"type\") != \"sync\":\n            raise ValueError(\"Sync file is not a valid sync file.\")\n\n        # Parse the query\n        new_songs = parse_query(sync_data[\"query\"], downloader.threads)\n        new_files = [\n            create_file_name(song, downloader.output, downloader.output_format)\n            for song in new_songs\n        ]\n\n        # Get all the old files based on the songs from sync file\n        old_songs = [Song.from_dict(song) for song in sync_data[\"songs\"]]\n        old_files = [\n            create_file_name(song, downloader.output, downloader.output_format)\n            for song in old_songs\n        ]\n\n        # Get all files that are no longer in the song lists\n        to_delete = set(old_files) - set(new_files)\n\n        # Get all files that are new and have to be downloaded\n        to_download = []\n        for song in new_songs:\n            song_path = create_file_name(\n                song, downloader.output, downloader.output_format\n            )\n\n            # Skip the songs that are already downloaded\n            if Path(song_path).exists():\n                # Add the song to the to_download list\n                # if overwrite is set to force\n                if downloader.overwrite == \"force\":\n                    downloader.progress_handler.log(f\"Overwriting {song.display_name}\")\n                    to_download.append(song)\n            else:\n                # Add the song to the to_download list\n                to_download.append(song)\n\n        downloader.progress_handler.log(\n            f\"Found {len(to_download)} songs to download and {len(to_delete)} files to delete.\"\n        )\n\n        # Delete all files that are no longer in the song lists\n        for file in to_delete:\n            if file.exists():\n                file.unlink()\n                downloader.progress_handler.log(f\"Removed {file}\")\n            else:\n                downloader.progress_handler.debug(f\"{file} does not exist.\")\n\n        # Create m3u file\n        if m3u_file:\n            gen_m3u_files(\n                sync_data[\"query\"],\n                m3u_file,\n                new_songs,\n                downloader.output,\n                downloader.output_format,\n                False,\n            )\n\n        # Write the new sync file\n        with open(query[0], \"w\", encoding=\"utf-8\") as save_file:\n            json.dump(\n                {\n                    \"type\": \"sync\",\n                    \"query\": sync_data[\"query\"],\n                    \"songs\": [song.json for song in new_songs],\n                },\n                save_file,\n                indent=4,\n                ensure_ascii=False,\n            )\n\n        if len(to_download) == 0:\n            downloader.progress_handler.log(\"Nothing to do...\")\n            return None\n\n        downloader.download_multiple_songs(to_download)\n\n        return None\n\n    raise ValueError(\n        \"Wrong combination of arguments. \"\n        \"Either provide a query and a save path. Or a single sync file in the query\"\n    )\n</code></pre>"},{"location":"reference/console/web/","title":"web","text":"<p>Web module for the console.</p>"},{"location":"reference/console/web/#spotdl.console.web.web","title":"<code>web(settings)</code>","text":"<p>Run the web server.</p>"},{"location":"reference/console/web/#spotdl.console.web.web--arguments","title":"Arguments","text":"<ul> <li>settings: Settings dictionary, based on the <code>SettingsModel</code> class.</li> </ul> Source code in <code>spotdl/console/web.py</code> <pre><code>def web(settings: Dict[str, Any]):\n\"\"\"\n    Run the web server.\n\n    ### Arguments\n    - settings: Settings dictionary, based on the `SettingsModel` class.\n    \"\"\"\n\n    # Download web app from GitHub\n    print(\"Updating web app\")\n    web_app_dir = str(get_spotdl_path().absolute())\n    download_github_dir(\n        \"https://github.com/spotdl/web-ui/tree/master/dist\",\n        output_dir=web_app_dir,\n    )\n\n    # Apply the fix for mime types\n    fix_mime_types()\n\n    # Set up the app loggers\n    uvicorn_logger = logging.getLogger(\"uvicorn\")\n    uvicorn_logger.propagate = False\n\n    spotipy_logger = logging.getLogger(\"spotipy\")\n    spotipy_logger.setLevel(logging.NOTSET)\n\n    # Initialize the web server settings\n    app_state.settings = settings\n    app_state.logger = uvicorn_logger\n    app_state.loop = (\n        asyncio.new_event_loop()\n        if sys.platform != \"win32\"\n        else asyncio.ProactorEventLoop()  # type: ignore\n    )\n\n    app_state.downloader = Downloader(\n        audio_providers=settings[\"audio_providers\"],\n        lyrics_providers=settings[\"lyrics_providers\"],\n        ffmpeg=settings[\"ffmpeg\"],\n        bitrate=settings[\"bitrate\"],\n        ffmpeg_args=settings[\"ffmpeg_args\"],\n        output_format=settings[\"format\"],\n        threads=settings[\"threads\"],\n        output=settings[\"output\"],\n        save_file=settings[\"save_file\"],\n        overwrite=settings[\"overwrite\"],\n        cookie_file=settings[\"cookie_file\"],\n        filter_results=settings[\"filter_results\"],\n        search_query=settings[\"search_query\"],\n        log_level=settings[\"log_level\"],\n        simple_tui=True,\n        restrict=settings[\"restrict\"],\n        print_errors=settings[\"print_errors\"],\n        sponsor_block=settings[\"sponsor_block\"],\n        loop=app_state.loop,\n        preserve_original_audio=settings[\"preserve_original_audio\"],\n    )\n\n    app_state.api = FastAPI(\n        title=\"spotDL\",\n        description=\"Download music from Spotify\",\n        version=__version__,\n        dependencies=[Depends(get_current_state)],\n    )\n\n    app_state.api.include_router(router)\n\n    # Add the CORS middleware\n    app_state.api.add_middleware(\n        CORSMiddleware,\n        allow_origins=ALLOWED_ORIGINS + settings[\"allowed_origins\"]\n        if settings[\"allowed_origins\"]\n        else ALLOWED_ORIGINS,\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n\n    # Add the static files\n    app_state.api.mount(\n        \"/\",\n        SPAStaticFiles(directory=web_app_dir + \"/dist\", html=True),\n        name=\"static\",\n    )\n\n    config = Config(\n        app=app_state.api,\n        host=settings[\"host\"],\n        port=settings[\"port\"],\n        workers=1,\n        log_level=NAME_TO_LEVEL[settings[\"log_level\"]],\n        loop=app_state.loop,  # type: ignore\n    )\n\n    app_state.server = Server(config)\n\n    # Open the web browser\n    webbrowser.open(f\"http://{settings['host']}:{settings['port']}/\")\n\n    # Start the web server\n    app_state.loop.run_until_complete(app_state.server.serve())\n</code></pre>"},{"location":"reference/download/","title":"download","text":"<p>Download module that holds the downloader and progress handler classes.</p>"},{"location":"reference/download/downloader/","title":"downloader","text":"<p>Downloader module, this is where all the downloading pre/post processing happens etc.</p>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader","title":"<code>Downloader(audio_providers=None, lyrics_providers=None, ffmpeg='ffmpeg', bitrate=None, ffmpeg_args=None, output_format='mp3', threads=4, output='.', save_file=None, overwrite='skip', cookie_file=None, filter_results=True, search_query=None, log_level='INFO', simple_tui=False, restrict=False, print_errors=False, sponsor_block=False, loop=None, playlist_numbering=False, preserve_original_audio=False)</code>","text":"<p>Downloader class, this is where all the downloading pre/post processing happens etc. It handles the downloading/moving songs, multthreading, metadata embedding etc.</p>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader--arguments","title":"Arguments","text":"<ul> <li>audio_provider: Audio providers to use.</li> <li>lyrics_provider: The lyrics providers to use.</li> <li>ffmpeg: The ffmpeg executable to use.</li> <li>bitrate: The bitrate to use.</li> <li>ffmpeg_args: The ffmpeg arguments to use.</li> <li>output_format: The output format to use.</li> <li>threads: The number of threads to use.</li> <li>output: The output directory to use.</li> <li>save_file: The save file to use when saving/loading song metadata.</li> <li>overwrite: The overwrite mode to use (force/skip).</li> <li>cookie_file: The cookie file to use for yt-dlp.</li> <li>filter_results: Whether to filter results.</li> <li>search_query: The search query to use.</li> <li>log_level: The log level to use.</li> <li>simple_tui: Whether to use simple tui.</li> <li>loop: The event loop to use.</li> <li>restrict: Whether to restrict the filename to ASCII characters.</li> <li>print_errors: Whether to print errors on exit.</li> <li>sponsor_block: Whether to remove sponsor segments using sponsor block postprocessor.</li> <li>playlist_numbering: Whether to convert tracks in a playlist into an album</li> <li>preserve_original_audio: Whether to preserve the original audio file</li> </ul>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader--notes","title":"Notes","text":"<ul> <li><code>search-query</code> uses the same format as <code>output</code>.</li> <li>if <code>audio_provider</code> or <code>lyrics_provider</code> is a list, then if no match is found,     the next provider in the list will be used.</li> </ul> Source code in <code>spotdl/download/downloader.py</code> <pre><code>def __init__(\n    self,\n    audio_providers: Optional[List[str]] = None,\n    lyrics_providers: Optional[List[str]] = None,\n    ffmpeg: str = \"ffmpeg\",\n    bitrate: Optional[str] = None,\n    ffmpeg_args: Optional[str] = None,\n    output_format: str = \"mp3\",\n    threads: int = 4,\n    output: str = \".\",\n    save_file: Optional[str] = None,\n    overwrite: str = \"skip\",\n    cookie_file: Optional[str] = None,\n    filter_results: bool = True,\n    search_query: Optional[str] = None,\n    log_level: str = \"INFO\",\n    simple_tui: bool = False,\n    restrict: bool = False,\n    print_errors: bool = False,\n    sponsor_block: bool = False,\n    loop: Optional[asyncio.AbstractEventLoop] = None,\n    playlist_numbering: bool = False,\n    preserve_original_audio: bool = False,\n):\n\"\"\"\n    Initialize the Downloader class.\n\n    ### Arguments\n    - audio_provider: Audio providers to use.\n    - lyrics_provider: The lyrics providers to use.\n    - ffmpeg: The ffmpeg executable to use.\n    - bitrate: The bitrate to use.\n    - ffmpeg_args: The ffmpeg arguments to use.\n    - output_format: The output format to use.\n    - threads: The number of threads to use.\n    - output: The output directory to use.\n    - save_file: The save file to use when saving/loading song metadata.\n    - overwrite: The overwrite mode to use (force/skip).\n    - cookie_file: The cookie file to use for yt-dlp.\n    - filter_results: Whether to filter results.\n    - search_query: The search query to use.\n    - log_level: The log level to use.\n    - simple_tui: Whether to use simple tui.\n    - loop: The event loop to use.\n    - restrict: Whether to restrict the filename to ASCII characters.\n    - print_errors: Whether to print errors on exit.\n    - sponsor_block: Whether to remove sponsor segments using sponsor block postprocessor.\n    - playlist_numbering: Whether to convert tracks in a playlist into an album\n    - preserve_original_audio: Whether to preserve the original audio file\n\n    ### Notes\n    - `search-query` uses the same format as `output`.\n    - if `audio_provider` or `lyrics_provider` is a list, then if no match is found,\n        the next provider in the list will be used.\n    \"\"\"\n\n    if audio_providers is None:\n        audio_providers = [\"youtube-music\"]\n\n    if lyrics_providers is None:\n        lyrics_providers = [\"musixmatch\"]\n\n    audio_providers_classes: List[Type[AudioProvider]] = []\n    lyrics_providers_classes: List[Type[LyricsProvider]] = []\n\n    for provider in audio_providers:\n        new_audio_provider = AUDIO_PROVIDERS.get(provider)\n        if new_audio_provider is None:\n            raise DownloaderError(f\"Invalid audio provider: {provider}\")\n\n        audio_providers_classes.append(new_audio_provider)\n\n    if len(audio_providers_classes) == 0:\n        raise DownloaderError(\n            \"No audio providers specified. Please specify at least one.\"\n        )\n\n    for provider in lyrics_providers:\n        new_lyrics_provider = LYRICS_PROVIDERS.get(provider)\n        if new_lyrics_provider is None:\n            raise DownloaderError(f\"Invalid lyrics provider: {provider}\")\n\n        lyrics_providers_classes.append(new_lyrics_provider)\n\n    self.loop = loop or (\n        asyncio.new_event_loop()\n        if sys.platform != \"win32\"\n        else asyncio.ProactorEventLoop()  # type: ignore\n    )\n\n    if loop is None:\n        asyncio.set_event_loop(self.loop)\n\n    # semaphore is required to limit concurrent asyncio executions\n    self.semaphore = asyncio.Semaphore(threads)\n\n    # thread pool executor is used to run blocking (CPU-bound) code from a thread\n    self.thread_executor = concurrent.futures.ThreadPoolExecutor(\n        max_workers=threads\n    )\n\n    # If ffmpeg is the default value and it's not installed\n    # try to use the spotdl's ffmpeg\n    if ffmpeg == \"ffmpeg\" and shutil.which(\"ffmpeg\") is None:\n        ffmpeg_exec = get_ffmpeg_path()\n        if ffmpeg_exec is None:\n            raise DownloaderError(\"ffmpeg is not installed\")\n\n        ffmpeg = str(ffmpeg_exec.absolute())\n\n    self.output = output\n    self.output_format = output_format\n    self.save_file = save_file\n    self.threads = threads\n    self.cookie_file = cookie_file\n    self.overwrite = overwrite\n    self.search_query = search_query\n    self.filter_results = filter_results\n    self.ffmpeg = ffmpeg\n    self.bitrate = bitrate\n    self.ffmpeg_args = ffmpeg_args\n    self.restrict = restrict\n    self.print_errors = print_errors\n    self.errors: List[str] = []\n    self.sponsor_block = sponsor_block\n    self.audio_providers_classes = audio_providers_classes\n    self.progress_handler = ProgressHandler(NAME_TO_LEVEL[log_level], simple_tui)\n    self.playlist_numbering = playlist_numbering\n    self.preserve_original_audio = preserve_original_audio\n\n    self.lyrics_providers: List[LyricsProvider] = []\n    for lyrics_provider_class in lyrics_providers_classes:\n        self.lyrics_providers.append(lyrics_provider_class())\n\n    self.progress_handler.debug(\"Downloader initialized\")\n</code></pre>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.aggregate_tasks","title":"<code>aggregate_tasks(tasks)</code>  <code>staticmethod</code> <code>async</code>","text":"<p>Aggregate the futures and return the results</p> Source code in <code>spotdl/download/downloader.py</code> <pre><code>@staticmethod\nasync def aggregate_tasks(tasks):\n\"\"\"\n    Aggregate the futures and return the results\n    \"\"\"\n\n    return await asyncio.gather(*(task for task in tasks))\n</code></pre>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.download_multiple_songs","title":"<code>download_multiple_songs(songs)</code>","text":"<p>Download multiple songs to the temp directory.</p>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.download_multiple_songs--arguments","title":"Arguments","text":"<ul> <li>songs: The songs to download.</li> </ul>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.download_multiple_songs--returns","title":"Returns","text":"<ul> <li>list of tuples with the song and the path to the downloaded file if successful.</li> </ul> Source code in <code>spotdl/download/downloader.py</code> <pre><code>def download_multiple_songs(\n    self, songs: List[Song]\n) -&gt; List[Tuple[Song, Optional[Path]]]:\n\"\"\"\n    Download multiple songs to the temp directory.\n\n    ### Arguments\n    - songs: The songs to download.\n\n    ### Returns\n    - list of tuples with the song and the path to the downloaded file if successful.\n    \"\"\"\n\n    self.progress_handler.set_song_count(len(songs))\n\n    tasks = [self.pool_download(song) for song in songs]\n\n    # call all task asynchronously, and wait until all are finished\n    results = list(self.loop.run_until_complete(self.aggregate_tasks(tasks)))\n\n    if self.print_errors:\n        for error in self.errors:\n            self.progress_handler.error(error)\n\n    if self.save_file:\n        with open(self.save_file, \"w\", encoding=\"utf-8\") as save_file:\n            json.dump([song.json for song, _ in results], save_file, indent=4)\n\n    return results\n</code></pre>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.download_song","title":"<code>download_song(song)</code>","text":"<p>Download a single song.</p>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.download_song--arguments","title":"Arguments","text":"<ul> <li>song: The song to download.</li> </ul>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.download_song--returns","title":"Returns","text":"<ul> <li>tuple with the song and the path to the downloaded file if successful.</li> </ul> Source code in <code>spotdl/download/downloader.py</code> <pre><code>def download_song(self, song: Song) -&gt; Tuple[Song, Optional[Path]]:\n\"\"\"\n    Download a single song.\n\n    ### Arguments\n    - song: The song to download.\n\n    ### Returns\n    - tuple with the song and the path to the downloaded file if successful.\n    \"\"\"\n\n    self.progress_handler.set_song_count(1)\n\n    results = self.download_multiple_songs([song])\n\n    return results[0]\n</code></pre>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.pool_download","title":"<code>pool_download(song)</code>  <code>async</code>","text":"<p>Run asynchronous task in a pool to make sure that all processes.</p>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.pool_download--arguments","title":"Arguments","text":"<ul> <li>song: The song to download.</li> </ul>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.pool_download--returns","title":"Returns","text":"<ul> <li>tuple with the song and the path to the downloaded file if successful.</li> </ul>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.pool_download--notes","title":"Notes","text":"<ul> <li>This method calls <code>self.search_and_download</code> in a new thread.</li> </ul> Source code in <code>spotdl/download/downloader.py</code> <pre><code>async def pool_download(self, song: Song) -&gt; Tuple[Song, Optional[Path]]:\n\"\"\"\n    Run asynchronous task in a pool to make sure that all processes.\n\n    ### Arguments\n    - song: The song to download.\n\n    ### Returns\n    - tuple with the song and the path to the downloaded file if successful.\n\n    ### Notes\n    - This method calls `self.search_and_download` in a new thread.\n    \"\"\"\n\n    # tasks that cannot acquire semaphore will wait here until it's free\n    # only certain amount of tasks can acquire the semaphore at the same time\n    async with self.semaphore:\n        # The following function calls blocking code, which would block whole event loop.\n        # Therefore it has to be called in a separate thread via ThreadPoolExecutor. This\n        # is not a problem, since GIL is released for the I/O operations, so it shouldn't\n        # hurt performance.\n        return await self.loop.run_in_executor(\n            self.thread_executor, self.search_and_download, song\n        )\n</code></pre>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search","title":"<code>search(song)</code>","text":"<p>Search for a song using all available providers.</p>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search--arguments","title":"Arguments","text":"<ul> <li>song: The song to search for.</li> </ul>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search--returns","title":"Returns","text":"<ul> <li>tuple with download url and audio provider if successful.</li> </ul> Source code in <code>spotdl/download/downloader.py</code> <pre><code>def search(self, song: Song) -&gt; Tuple[str, AudioProvider]:\n\"\"\"\n    Search for a song using all available providers.\n\n    ### Arguments\n    - song: The song to search for.\n\n    ### Returns\n    - tuple with download url and audio provider if successful.\n    \"\"\"\n\n    audio_providers: List[AudioProvider] = []\n    for audio_provider_class in self.audio_providers_classes:\n        audio_providers.append(\n            audio_provider_class(\n                output_format=self.output_format,\n                cookie_file=self.cookie_file,\n                search_query=self.search_query,\n                filter_results=self.filter_results,\n            )\n        )\n\n    for audio_provider in audio_providers:\n        url = audio_provider.search(song)\n        if url:\n            return url, audio_provider\n\n        self.progress_handler.debug(\n            f\"{audio_provider.name} failed to find {song.display_name}\"\n        )\n\n    raise LookupError(f\"No results found for song: {song.display_name}\")\n</code></pre>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search_and_download","title":"<code>search_and_download(song)</code>","text":"<p>Search for the song and download it.</p>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search_and_download--arguments","title":"Arguments","text":"<ul> <li>song: The song to download.</li> </ul>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search_and_download--returns","title":"Returns","text":"<ul> <li>tuple with the song and the path to the downloaded file if successful.</li> </ul>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search_and_download--notes","title":"Notes","text":"<ul> <li>This function is synchronous.</li> </ul> Source code in <code>spotdl/download/downloader.py</code> <pre><code>def search_and_download(self, song: Song) -&gt; Tuple[Song, Optional[Path]]:\n\"\"\"\n    Search for the song and download it.\n\n    ### Arguments\n    - song: The song to download.\n\n    ### Returns\n    - tuple with the song and the path to the downloaded file if successful.\n\n    ### Notes\n    - This function is synchronous.\n    \"\"\"\n\n    # Check if we have all the metadata\n    # and that the song object is not a placeholder\n    # If it's None extract the current metadata\n    # And reinitialize the song object\n    if song.name is None and song.url:\n        song = reinit_song(song, self.playlist_numbering)\n\n    # Find song lyrics and add them to the song object\n    lyrics = self.search_lyrics(song)\n    if lyrics is None:\n        self.progress_handler.debug(\n            f\"No lyrics found for {song.display_name}, \"\n            \"lyrics providers: \"\n            f\"{', '.join([lprovider.name for lprovider in self.lyrics_providers])}\"\n        )\n    else:\n        song.lyrics = lyrics\n\n    # Initalize the progress tracker\n    display_progress_tracker = self.progress_handler.get_new_tracker(song)\n\n    # Create the output file path\n    output_file = create_file_name(song, self.output, self.output_format)\n    temp_folder = get_temp_path()\n\n    # Restrict the filename if needed\n    if self.restrict is True:\n        output_file = restrict_filename(output_file)\n\n    # If the file already exists and we don't want to overwrite it,\n    # we can skip the download\n    if output_file.exists() and self.overwrite == \"skip\":\n        self.progress_handler.log(f\"Skipping {song.display_name}\")\n        display_progress_tracker.notify_download_skip()\n        return song, None\n\n    if output_file.exists() and self.overwrite == \"metadata\":\n        embed_metadata(\n            output_file=output_file, song=song, file_format=self.output_format\n        )\n\n        self.progress_handler.log(f\"Updated metadata for {song.display_name}\")\n        display_progress_tracker.notify_complete()\n\n        return song, output_file\n\n    # Don't skip if the file exists and overwrite is set to force\n    if output_file.exists() and self.overwrite == \"force\":\n        self.progress_handler.debug(f\"Overwriting {song.display_name}\")\n\n    # Create the output directory if it doesn't exist\n    output_file.parent.mkdir(parents=True, exist_ok=True)\n\n    try:\n        if song.download_url is None:\n            download_url, audio_provider = self.search(song)\n        else:\n            # If the song object already has a download url\n            # we can skip the search, and just reinitialize the base\n            # audio provider to download the song\n            download_url = song.download_url\n            audio_provider = AudioProvider(\n                output_format=self.output_format,\n                cookie_file=self.cookie_file,\n                search_query=self.search_query,\n                filter_results=self.filter_results,\n            )\n\n        self.progress_handler.debug(\n            f\"Downloading {song.display_name} using {download_url}, \"\n            f\"audio provider: {audio_provider.name}\"\n        )\n\n        # Add progress hook to the audio provider\n        audio_provider.audio_handler.add_progress_hook(\n            display_progress_tracker.yt_dlp_progress_hook\n        )\n\n        # Download the song using yt-dlp\n        download_info = audio_provider.get_download_metadata(\n            download_url, download=True\n        )\n\n        temp_file = Path(\n            temp_folder / f\"{download_info['id']}.{download_info['ext']}\"\n        )\n\n        if download_info is None:\n            self.progress_handler.debug(\n                f\"No download info found for {song.display_name}, url: {download_url}\"\n            )\n\n            raise LookupError(\n                f\"yt-dlp failed to get metadata for: {song.name} - {song.artist}\"\n            )\n\n        display_progress_tracker.notify_download_complete()\n\n        bitrate: Optional[str] = (\n            self.bitrate if self.bitrate else f\"{int(download_info['abr'])}k\"\n        )\n\n        # Ignore the bitrate if the preserve original audio\n        # option is set to true\n        if self.preserve_original_audio:\n            bitrate = None\n\n        success, result = convert(\n            input_file=temp_file,\n            output_file=output_file,\n            ffmpeg=self.ffmpeg,\n            output_format=self.output_format,\n            bitrate=bitrate,\n            ffmpeg_args=self.ffmpeg_args,\n            progress_handler=display_progress_tracker.ffmpeg_progress_hook,\n        )\n\n        # Remove the temp file\n        if temp_file.exists():\n            try:\n                temp_file.unlink()\n            except (PermissionError, OSError) as exc:\n                self.progress_handler.debug(\n                    f\"Could not remove temp file: {temp_file}, error: {exc}\"\n                )\n\n                raise DownloaderError(\n                    f\"Could not remove temp file: {temp_file}, possible duplicate song\"\n                ) from exc\n\n        if not success and result:\n            # If the conversion failed and there is an error message\n            # create a file with the error message\n            # and save it in the errors directory\n            # raise an exception with file path\n            file_name = (\n                get_errors_path()\n                / f\"ffmpeg_error_{datetime.datetime.now().strftime('%Y-%m-%d-%H-%M-%S')}.txt\"\n            )\n\n            error_message = \"\"\n            for key, value in result.items():\n                error_message += f\"### {key}:\\n{str(value).strip()}\\n\\n\"\n\n            with open(file_name, \"w\", encoding=\"utf-8\") as error_path:\n                error_path.write(error_message)\n\n            # Remove the file that failed to convert\n            if output_file.exists():\n                output_file.unlink()\n\n            raise FFmpegError(\n                f\"Failed to convert {song.display_name}, \"\n                f\"you can find error here: {str(file_name.absolute())}\"\n            )\n\n        download_info[\"filepath\"] = str(output_file)\n\n        # Set the song's download url\n        if song.download_url is None:\n            song.download_url = download_url\n\n        display_progress_tracker.notify_conversion_complete()\n\n        # SponsorBlock post processor\n        if self.sponsor_block:\n            # Initialize the sponsorblock post processor\n            post_processor = SponsorBlockPP(\n                audio_provider.audio_handler, SPONSOR_BLOCK_CATEGORIES\n            )\n\n            # Run the post processor to get the sponsor segments\n            _, download_info = post_processor.run(download_info)\n            chapters = download_info[\"sponsorblock_chapters\"]\n\n            # If there are sponsor segments, remove them\n            if len(chapters) &gt; 0:\n                self.progress_handler.log(\n                    f\"Removing {len(chapters)} sponsor segments for {song.display_name}\"\n                )\n\n                # Initialize the modify chapters post processor\n                modify_chapters = ModifyChaptersPP(\n                    audio_provider.audio_handler,\n                    remove_sponsor_segments=SPONSOR_BLOCK_CATEGORIES,\n                )\n\n                # Run the post processor to remove the sponsor segments\n                # this returns a list of files to delete\n                files_to_delete, download_info = modify_chapters.run(download_info)\n\n                # Delete the files that were created by the post processor\n                for file_to_delete in files_to_delete:\n                    Path(file_to_delete).unlink()\n\n        try:\n            embed_metadata(output_file, song, self.output_format)\n        except Exception as exception:\n            raise MetadataError(\n                \"Failed to embed metadata to the song\"\n            ) from exception\n\n        display_progress_tracker.notify_complete()\n\n        self.progress_handler.log(\n            f'Downloaded \"{song.display_name}\": {song.download_url}'\n        )\n\n        return song, output_file\n    except (Exception, UnicodeEncodeError) as exception:\n        if isinstance(exception, UnicodeEncodeError):\n            exception_cause = exception\n            exception = DownloaderError(\n                \"You may need to add PYTHONIOENCODING=utf-8 to your environment\"\n            )\n\n            exception.__cause__ = exception_cause\n\n        display_progress_tracker.notify_error(\n            traceback.format_exc(), exception, True\n        )\n        self.errors.append(\n            f\"{song.url} - {exception.__class__.__name__}: {exception}\"\n        )\n        return song, None\n</code></pre>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search_lyrics","title":"<code>search_lyrics(song)</code>","text":"<p>Search for lyrics using all available providers.</p>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search_lyrics--arguments","title":"Arguments","text":"<ul> <li>song: The song to search for.</li> </ul>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search_lyrics--returns","title":"Returns","text":"<ul> <li>lyrics if successful else None.</li> </ul> Source code in <code>spotdl/download/downloader.py</code> <pre><code>def search_lyrics(self, song: Song) -&gt; Optional[str]:\n\"\"\"\n    Search for lyrics using all available providers.\n\n    ### Arguments\n    - song: The song to search for.\n\n    ### Returns\n    - lyrics if successful else None.\n    \"\"\"\n\n    for lyrics_provider in self.lyrics_providers:\n        lyrics = lyrics_provider.get_lyrics(song.name, song.artists)\n        if lyrics:\n            self.progress_handler.debug(\n                f\"Found lyrics for {song.display_name} on {lyrics_provider.name}\"\n            )\n            return lyrics\n\n        self.progress_handler.debug(\n            f\"{lyrics_provider.name} failed to find lyrics \"\n            f\"for {song.display_name}\"\n        )\n\n    return None\n</code></pre>"},{"location":"reference/download/downloader/#spotdl.download.downloader.DownloaderError","title":"<code>DownloaderError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Base class for all exceptions related to downloaders.</p>"},{"location":"reference/download/progress_handler/","title":"progress_handler","text":"<p>Module that holds the ProgressHandler class and Song Tracker class.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler","title":"<code>ProgressHandler(log_level=INFO, simple_tui=False, update_callback=None)</code>","text":"<p>Class for handing the progress of a download, including the progress bar.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler--arguments","title":"Arguments","text":"<ul> <li>log_level: The log level to use.</li> <li>simple_tui: Whether or not to use the simple TUI.</li> <li>update_callback: A callback to call when the progress bar is updated.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def __init__(\n    self,\n    log_level: int = INFO,\n    simple_tui: bool = False,\n    update_callback: Optional[Callable[[Any, str], None]] = None,\n):\n\"\"\"\n    Initialize the progress handler.\n\n    ### Arguments\n    - log_level: The log level to use.\n    - simple_tui: Whether or not to use the simple TUI.\n    - update_callback: A callback to call when the progress bar is updated.\n    \"\"\"\n\n    self.songs: List[Song] = []\n    self.song_count: int = 0\n    self.overall_progress = 0\n    self.overall_total = 100\n    self.overall_completed_tasks = 0\n    self.update_callback = update_callback\n    self.previous_overall = self.overall_completed_tasks\n\n    if log_level not in LEVEL_TO_NAME:\n        raise ProgressHandlerError(f\"Invalid log level: {log_level}\")\n\n    self.log_level = log_level\n    self.simple_tui = simple_tui\n    self.quiet = self.log_level &lt; 10\n    self.overall_task_id: Optional[TaskID] = None\n\n    if not self.simple_tui:\n        # Change color system if \"legacy\" windows terminal to prevent wrong colors displaying\n        self.is_legacy = detect_legacy_windows()\n\n        # dumb_terminals automatically handled by rich. Color system is too but it is incorrect\n        # for legacy windows ... so no color for y'all.\n        self.console = Console(\n            theme=THEME, color_system=\"truecolor\" if not self.is_legacy else None\n        )\n\n        self.rich_progress_bar = Progress(\n            SizedTextColumn(\n                \"[white]{task.description}\",\n                overflow=\"ellipsis\",\n                width=int(self.console.width / 3),\n            ),\n            SizedTextColumn(\n                \"{task.fields[message]}\", width=18, style=\"nonimportant\"\n            ),\n            BarColumn(bar_width=None, finished_style=\"green\"),\n            \"[progress.percentage]{task.percentage:&gt;3.0f}%\",\n            TimeRemainingColumn(),\n            console=self.console,\n            # Normally when you exit the progress context manager (or call stop())\n            # the last refreshed display remains in the terminal with the cursor on\n            # the following line. You can also make the progress display disappear on\n            # exit by setting transient=True on the Progress constructor\n            transient=self.is_legacy,\n        )\n\n        # Basically a wrapper for rich's: with ... as ...\n        self.rich_progress_bar.__enter__()\n    else:\n        logging.basicConfig(\n            format=\"%(asctime)s - %(levelname)s - %(message)s\",\n            datefmt=\"%H:%M:%S\",\n            level=self.log_level,\n        )\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.add_song","title":"<code>add_song(song)</code>","text":"<p>Adds a song to the list of songs.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.add_song--arguments","title":"Arguments","text":"<ul> <li>song: The song to add.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def add_song(self, song: Song) -&gt; None:\n\"\"\"\n    Adds a song to the list of songs.\n\n    ### Arguments\n    - song: The song to add.\n    \"\"\"\n\n    self.songs.append(song)\n    self.set_song_count(len(self.songs))\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.close","title":"<code>close()</code>","text":"<p>Close the Tui Progress Handler.</p> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"\n    Close the Tui Progress Handler.\n    \"\"\"\n\n    if not self.simple_tui:\n        self.rich_progress_bar.stop()\n    else:\n        logging.shutdown()\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.debug","title":"<code>debug(message)</code>","text":"<p>Debug message.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.debug--arguments","title":"Arguments","text":"<ul> <li>message: The message to log.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def debug(self, message: str) -&gt; None:\n\"\"\"\n    Debug message.\n\n    ### Arguments\n    - message: The message to log.\n    \"\"\"\n\n    if not self.simple_tui:\n        if self.log_level &gt; DEBUG:\n            return\n\n        self.rich_progress_bar.console.print(f\"[blue]{message}\")\n    else:\n        logging.debug(message)\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.error","title":"<code>error(message)</code>","text":"<p>Error message.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.error--arguments","title":"Arguments","text":"<ul> <li>message: The message to log.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def error(self, message: str) -&gt; None:\n\"\"\"\n    Error message.\n\n    ### Arguments\n    - message: The message to log.\n    \"\"\"\n\n    if not self.simple_tui:\n        if self.log_level &gt; ERROR:\n            return\n\n        self.rich_progress_bar.console.print(f\"[red]{message}\")\n    else:\n        logging.error(message)\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.get_new_tracker","title":"<code>get_new_tracker(song)</code>","text":"<p>Get a new progress tracker.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.get_new_tracker--arguments","title":"Arguments","text":"<ul> <li>song: The song to track.</li> </ul>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.get_new_tracker--returns","title":"Returns","text":"<ul> <li>A new progress tracker.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def get_new_tracker(self, song: Song) -&gt; \"SongTracker\":\n\"\"\"\n    Get a new progress tracker.\n\n    ### Arguments\n    - song: The song to track.\n\n    ### Returns\n    - A new progress tracker.\n    \"\"\"\n\n    return SongTracker(self, song)\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.log","title":"<code>log(message)</code>","text":"<p>Log message.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.log--arguments","title":"Arguments","text":"<ul> <li>message: The message to log.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def log(self, message: str) -&gt; None:\n\"\"\"\n    Log message.\n\n    ### Arguments\n    - message: The message to log.\n    \"\"\"\n\n    if not self.simple_tui:\n        if self.log_level &gt; INFO:\n            return\n\n        self.rich_progress_bar.console.print(f\"[green]{message}\")\n    else:\n        logging.info(message)\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.set_song_count","title":"<code>set_song_count(count)</code>","text":"<p>Set the number of songs to download.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.set_song_count--arguments","title":"Arguments","text":"<ul> <li>count: The number of songs to download.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def set_song_count(self, count: int) -&gt; None:\n\"\"\"\n    Set the number of songs to download.\n\n    ### Arguments\n    - count: The number of songs to download.\n    \"\"\"\n\n    self.song_count = count\n    self.overall_total = 100 * count\n\n    if not self.simple_tui:\n        if self.song_count &gt; 4:\n            self.overall_task_id = self.rich_progress_bar.add_task(\n                description=\"Total\",\n                message=(\n                    f\"{self.overall_completed_tasks}/{int(self.overall_total / 100)} \"\n                    \"complete\"\n                ),\n                total=self.overall_total,\n                visible=(not self.quiet),\n            )\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.set_songs","title":"<code>set_songs(songs)</code>","text":"<p>Sets the list of songs to be downloaded.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.set_songs--arguments","title":"Arguments","text":"<ul> <li>songs: The list of songs to download.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def set_songs(self, songs: List[Song]) -&gt; None:\n\"\"\"\n    Sets the list of songs to be downloaded.\n\n    ### Arguments\n    - songs: The list of songs to download.\n    \"\"\"\n\n    self.songs = songs\n    self.set_song_count(len(songs))\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.update_overall","title":"<code>update_overall()</code>","text":"<p>Update the overall progress bar.</p> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def update_overall(self) -&gt; None:\n\"\"\"\n    Update the overall progress bar.\n    \"\"\"\n\n    if not self.simple_tui:\n        # If the overall progress bar exists\n        if self.overall_task_id is not None:\n            self.rich_progress_bar.update(\n                self.overall_task_id,\n                message=f\"{self.overall_completed_tasks}/\"\n                f\"{int(self.overall_total / 100)} \"\n                \"complete\",\n                completed=self.overall_progress,\n            )\n    else:\n        if self.previous_overall != self.overall_completed_tasks:\n            logging.info(\n                \"%s/%s complete\", self.overall_completed_tasks, self.song_count\n            )\n            self.previous_overall = self.overall_completed_tasks\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.warn","title":"<code>warn(message)</code>","text":"<p>Warning message.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.warn--arguments","title":"Arguments","text":"<ul> <li>message: The message to log.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def warn(self, message: str) -&gt; None:\n\"\"\"\n    Warning message.\n\n    ### Arguments\n    - message: The message to log.\n    \"\"\"\n\n    if not self.simple_tui:\n        if self.log_level &gt; WARNING:\n            return\n\n        self.rich_progress_bar.console.print(f\"[yellow]{message}\")\n    else:\n        logging.warning(message)\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandlerError","title":"<code>ProgressHandlerError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Base class for all exceptions raised by ProgressHandler subclasses.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SizedTextColumn","title":"<code>SizedTextColumn(text_format, style='none', justify='left', markup=True, highlighter=None, overflow=None, width=20)</code>","text":"<p>         Bases: <code>ProgressColumn</code></p> <p>Custom sized text column based on the Rich library.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SizedTextColumn--arguments","title":"Arguments","text":"<ul> <li>text_format: The format string to use for the text.</li> <li>style: The style to use for the text.</li> <li>justify: The justification to use for the text.</li> <li>markup: Whether or not the text should be rendered as markup.</li> <li>highlighter: A Highlighter to use for highlighting the text.</li> <li>overflow: The overflow method to use for truncating the text.</li> <li>width: The maximum width of the text.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def __init__(\n    self,\n    text_format: str,\n    style: StyleType = \"none\",\n    justify: JustifyMethod = \"left\",\n    markup: bool = True,\n    highlighter: Optional[Highlighter] = None,\n    overflow: Optional[OverflowMethod] = None,\n    width: int = 20,\n) -&gt; None:\n\"\"\"\n    A column containing text.\n\n    ### Arguments\n    - text_format: The format string to use for the text.\n    - style: The style to use for the text.\n    - justify: The justification to use for the text.\n    - markup: Whether or not the text should be rendered as markup.\n    - highlighter: A Highlighter to use for highlighting the text.\n    - overflow: The overflow method to use for truncating the text.\n    - width: The maximum width of the text.\n    \"\"\"\n\n    self.text_format = text_format\n    self.justify: JustifyMethod = justify\n    self.style = style\n    self.markup = markup\n    self.highlighter = highlighter\n    self.overflow: Optional[OverflowMethod] = overflow\n    self.width = width\n    super().__init__()\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SizedTextColumn.render","title":"<code>render(task)</code>","text":"<p>Render the Column.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SizedTextColumn.render--arguments","title":"Arguments","text":"<ul> <li>task: The Task to render.</li> </ul>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SizedTextColumn.render--returns","title":"Returns","text":"<ul> <li>A Text object.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def render(self, task: Task) -&gt; Text:\n\"\"\"\n    Render the Column.\n\n    ### Arguments\n    - task: The Task to render.\n\n    ### Returns\n    - A Text object.\n    \"\"\"\n\n    _text = self.text_format.format(task=task)\n    if self.markup:\n        text = Text.from_markup(_text, style=self.style, justify=self.justify)\n    else:\n        text = Text(_text, style=self.style, justify=self.justify)\n    if self.highlighter:\n        self.highlighter.highlight(text)\n\n    text.truncate(max_width=self.width, overflow=self.overflow, pad=True)\n    return text\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker","title":"<code>SongTracker(parent, song)</code>","text":"<p>Class to track the progress of a song.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker--arguments","title":"Arguments","text":"<ul> <li>parent: The parent Tui Progress Handler.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def __init__(self, parent, song: Song) -&gt; None:\n\"\"\"\n    Initialize the Tui Song Tracker.\n\n    ### Arguments\n    - parent: The parent Tui Progress Handler.\n    \"\"\"\n\n    self.parent: \"ProgressHandler\" = parent\n    self.song = song\n\n    # Clean up the song name\n    # from weird unicode characters\n    self.song_name = \"\".join(\n        char\n        for char in self.song.name\n        if char not in [chr(i) for i in range(769, 880)]\n    )\n\n    self.progress: int = 0\n    self.old_progress: int = 0\n    self.status = \"\"\n\n    if not self.parent.simple_tui:\n        self.task_id = self.parent.rich_progress_bar.add_task(\n            description=song.display_name,\n            message=\"Download Started\",\n            total=100,\n            completed=self.progress,\n            start=False,\n            visible=(not self.parent.quiet),\n        )\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.ffmpeg_progress_hook","title":"<code>ffmpeg_progress_hook(progress)</code>","text":"<p>Updates the progress.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.ffmpeg_progress_hook--arguments","title":"Arguments","text":"<ul> <li>progress: The progress to update to.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def ffmpeg_progress_hook(self, progress: int) -&gt; None:\n\"\"\"\n    Updates the progress.\n\n    ### Arguments\n    - progress: The progress to update to.\n    \"\"\"\n\n    if not self.parent.simple_tui:\n        self.progress = 50 + int(progress * 0.45)\n    else:\n        self.progress = 50\n\n    self.update(\"Converting\")\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_complete","title":"<code>notify_complete(status='Done')</code>","text":"<p>Notifies the progress handler that the song has been downloaded and converted.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_complete--arguments","title":"Arguments","text":"<ul> <li>status: The status to display.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def notify_complete(self, status=\"Done\") -&gt; None:\n\"\"\"\n    Notifies the progress handler that the song has been downloaded and converted.\n\n    ### Arguments\n    - status: The status to display.\n    \"\"\"\n\n    self.progress = 100\n    self.update(status)\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_conversion_complete","title":"<code>notify_conversion_complete(status='Embedding metadata')</code>","text":"<p>Notifies the progress handler that the song has been converted.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_conversion_complete--arguments","title":"Arguments","text":"<ul> <li>status: The status to display.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def notify_conversion_complete(self, status=\"Embedding metadata\") -&gt; None:\n\"\"\"\n    Notifies the progress handler that the song has been converted.\n\n    ### Arguments\n    - status: The status to display.\n    \"\"\"\n\n    self.progress = 95\n    self.update(status)\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_download_complete","title":"<code>notify_download_complete(status='Converting')</code>","text":"<p>Notifies the progress handler that the song has been downloaded.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_download_complete--arguments","title":"Arguments","text":"<ul> <li>status: The status to display.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def notify_download_complete(self, status=\"Converting\") -&gt; None:\n\"\"\"\n    Notifies the progress handler that the song has been downloaded.\n\n    ### Arguments\n    - status: The status to display.\n    \"\"\"\n\n    self.progress = 50\n    self.update(status)\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_download_skip","title":"<code>notify_download_skip(status='Skipped')</code>","text":"<p>Notifies the progress handler that the song has been skipped.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_download_skip--arguments","title":"Arguments","text":"<ul> <li>status: The status to display.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def notify_download_skip(self, status=\"Skipped\") -&gt; None:\n\"\"\"\n    Notifies the progress handler that the song has been skipped.\n\n    ### Arguments\n    - status: The status to display.\n    \"\"\"\n\n    self.progress = 100\n    self.update(status)\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_error","title":"<code>notify_error(message, traceback, finish=False)</code>","text":"<p>Logs an error message.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_error--arguments","title":"Arguments","text":"<ul> <li>message: The message to log.</li> <li>traceback: The traceback of the error.</li> <li>finish: Whether to finish the task.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def notify_error(\n    self, message: str, traceback: Exception, finish: bool = False\n) -&gt; None:\n\"\"\"\n    Logs an error message.\n\n    ### Arguments\n    - message: The message to log.\n    - traceback: The traceback of the error.\n    - finish: Whether to finish the task.\n    \"\"\"\n\n    self.update(\"Error\")\n    if finish:\n        self.progress = 100\n\n    self.parent.debug(message)\n    self.parent.error(f\"{traceback.__class__.__name__}: {traceback}\")\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.update","title":"<code>update(message='')</code>","text":"<p>Called at every event.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.update--arguments","title":"Arguments","text":"<ul> <li>message: The message to display.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def update(self, message=\"\"):\n\"\"\"\n    Called at every event.\n\n    ### Arguments\n    - message: The message to display.\n    \"\"\"\n\n    self.status = message\n\n    # The change in progress since last update\n    delta = self.progress - self.old_progress\n\n    if not self.parent.simple_tui:\n        # Update the progress bar\n        # `start_task` called everytime to ensure progress is remove from indeterminate state\n        self.parent.rich_progress_bar.start_task(self.task_id)\n        self.parent.rich_progress_bar.update(\n            self.task_id,\n            description=self.song.display_name,\n            message=message,\n            completed=self.progress,\n        )\n\n        # If task is complete\n        if self.progress == 100 or message == \"Error\":\n            self.parent.overall_completed_tasks += 1\n            self.parent.rich_progress_bar.remove_task(self.task_id)\n    else:\n        # If task is complete\n        if self.progress == 100 or message == \"Error\":\n            self.parent.overall_completed_tasks += 1\n        if delta:\n            self.parent.log(f\"{self.song.name} - {self.song.artist}: {message}\")\n\n    # Update the overall progress bar\n    if self.parent.song_count == self.parent.overall_completed_tasks:\n        self.parent.overall_progress = self.parent.song_count * 100\n    else:\n        self.parent.overall_progress += delta\n\n    self.parent.update_overall()\n    self.old_progress = self.progress\n\n    if self.parent.update_callback:\n        self.parent.update_callback(self, message)\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.yt_dlp_progress_hook","title":"<code>yt_dlp_progress_hook(data)</code>","text":"<p>Updates the progress.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.yt_dlp_progress_hook--arguments","title":"Arguments","text":"<ul> <li>progress: The progress to update to.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def yt_dlp_progress_hook(self, data: Dict[str, Any]) -&gt; None:\n\"\"\"\n    Updates the progress.\n\n    ### Arguments\n    - progress: The progress to update to.\n    \"\"\"\n\n    if data[\"status\"] == \"downloading\":\n        file_bytes = data[\"total_bytes\"]\n        downloaded_bytes = data[\"downloaded_bytes\"]\n\n        if self.parent.simple_tui:\n            self.progress = 50\n        elif file_bytes and downloaded_bytes:\n            self.progress = downloaded_bytes / file_bytes * 50\n\n        self.update(\"Downloading\")\n</code></pre>"},{"location":"reference/providers/","title":"providers","text":"<p>Different types of data providers for spotdl.</p>"},{"location":"reference/providers/audio/","title":"audio","text":"<p>Audio providers for spotdl.</p>"},{"location":"reference/providers/audio/base/","title":"base","text":"<p>Base audio provider module.</p>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider","title":"<code>AudioProvider(output_format='mp3', cookie_file=None, search_query=None, filter_results=True)</code>","text":"<p>Base class for all other providers. Provides some common functionality. Handles the yt-dlp audio handler.</p>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider--arguments","title":"Arguments","text":"<ul> <li>output_directory: The directory to save the downloaded songs to.</li> <li>output_format: The format to save the downloaded songs in.</li> <li>cookie_file: The path to a file containing cookies to be used by YTDL.</li> <li>search_query: The query to use when searching for songs.</li> <li>filter_results: Whether to filter results.</li> </ul>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider--errors","title":"Errors","text":"<ul> <li>raises <code>NotImplementedError</code> if self.name is not set.</li> </ul> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def __init__(\n    self,\n    output_format: str = \"mp3\",\n    cookie_file: Optional[str] = None,\n    search_query: Optional[str] = None,\n    filter_results: bool = True,\n) -&gt; None:\n\"\"\"\n    Base class for audio providers.\n\n    ### Arguments\n    - output_directory: The directory to save the downloaded songs to.\n    - output_format: The format to save the downloaded songs in.\n    - cookie_file: The path to a file containing cookies to be used by YTDL.\n    - search_query: The query to use when searching for songs.\n    - filter_results: Whether to filter results.\n\n    ### Errors\n    - raises `NotImplementedError` if self.name is not set.\n    \"\"\"\n\n    self.output_format = output_format\n    self.cookie_file = cookie_file\n    self.search_query = search_query\n    self.filter_results = filter_results\n\n    if self.output_format == \"m4a\":\n        ytdl_format = \"bestaudio[ext=m4a]/bestaudio/best\"\n    elif self.output_format == \"opus\":\n        ytdl_format = \"bestaudio[ext=webm]/bestaudio/best\"\n    else:\n        ytdl_format = \"bestaudio\"\n\n    self.audio_handler = YoutubeDL(\n        {\n            \"format\": ytdl_format,\n            \"quiet\": True,\n            \"no_warnings\": True,\n            \"encoding\": \"UTF-8\",\n            \"logger\": YTDLLogger(),\n            \"cookiefile\": self.cookie_file,\n            \"outtmpl\": f\"{get_temp_path()}/%(id)s.%(ext)s\",\n            \"retries\": 5,\n        }\n    )\n</code></pre>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Get the name of the provider.</p>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.name--returns","title":"Returns","text":"<ul> <li>The name of the provider.</li> </ul>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.get_download_metadata","title":"<code>get_download_metadata(url, download=False)</code>","text":"<p>Get metadata for a download using yt-dlp.</p>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.get_download_metadata--arguments","title":"Arguments","text":"<ul> <li>url: The url to get metadata for.</li> </ul>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.get_download_metadata--returns","title":"Returns","text":"<ul> <li>A dictionary containing the metadata.</li> </ul> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def get_download_metadata(self, url: str, download: bool = False) -&gt; Dict:\n\"\"\"\n    Get metadata for a download using yt-dlp.\n\n    ### Arguments\n    - url: The url to get metadata for.\n\n    ### Returns\n    - A dictionary containing the metadata.\n    \"\"\"\n\n    try:\n\n        data = self.audio_handler.extract_info(url, download=download)\n\n        if data:\n            return data\n    except Exception as exception:\n        raise AudioProviderError(f\"YT-DLP download error - {url}\") from exception\n\n    raise AudioProviderError(f\"No metadata found for the provided url {url}\")\n</code></pre>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.get_results","title":"<code>get_results(search_term, **kwargs)</code>","text":"<p>Get results from audio provider.</p>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.get_results--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to use.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.get_results--returns","title":"Returns","text":"<ul> <li>A list of results.</li> </ul> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def get_results(self, search_term: str, **kwargs):\n\"\"\"\n    Get results from audio provider.\n\n    ### Arguments\n    - search_term: The search term to use.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - A list of results.\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.order_results","title":"<code>order_results(results, song)</code>","text":"<p>Order results.</p>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.order_results--arguments","title":"Arguments","text":"<ul> <li>results: The results to order.</li> <li>song: The song to order for.</li> </ul>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.order_results--returns","title":"Returns","text":"<ul> <li>The ordered results.</li> </ul> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def order_results(self, results, song: Song):\n\"\"\"\n    Order results.\n\n    ### Arguments\n    - results: The results to order.\n    - song: The song to order for.\n\n    ### Returns\n    - The ordered results.\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.search","title":"<code>search(song)</code>","text":"<p>Search for a song and return best match.</p>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.search--arguments","title":"Arguments","text":"<ul> <li>song: The song to search for.</li> </ul>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.search--returns","title":"Returns","text":"<ul> <li>The url of the best match or None if no match was found.</li> </ul> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def search(self, song: Song) -&gt; Optional[str]:\n\"\"\"\n    Search for a song and return best match.\n\n    ### Arguments\n    - song: The song to search for.\n\n    ### Returns\n    - The url of the best match or None if no match was found.\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProviderError","title":"<code>AudioProviderError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Base class for all exceptions related to audio searching/downloading.</p>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.YTDLLogger","title":"<code>YTDLLogger</code>","text":"<p>Custom YT-dlp logger.</p>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.YTDLLogger.debug","title":"<code>debug(msg)</code>","text":"<p>YTDL uses this to print debug messages.</p> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def debug(self, msg):\n\"\"\"\n    YTDL uses this to print debug messages.\n    \"\"\"\n\n    pass  # pylint: disable=W0107\n</code></pre>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.YTDLLogger.error","title":"<code>error(msg)</code>","text":"<p>YTDL uses this to print errors.</p> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def error(self, msg):\n\"\"\"\n    YTDL uses this to print errors.\n    \"\"\"\n\n    raise AudioProviderError(msg)\n</code></pre>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.YTDLLogger.warning","title":"<code>warning(msg)</code>","text":"<p>YTDL uses this to print warnings.</p> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def warning(self, msg):\n\"\"\"\n    YTDL uses this to print warnings.\n    \"\"\"\n\n    pass  # pylint: disable=W0107\n</code></pre>"},{"location":"reference/providers/audio/youtube/","title":"youtube","text":"<p>Youtube module for downloading and searching songs.</p>"},{"location":"reference/providers/audio/youtube/#spotdl.providers.audio.youtube.YouTube","title":"<code>YouTube</code>","text":"<p>         Bases: <code>AudioProvider</code></p> <p>YouTube audio provider class</p>"},{"location":"reference/providers/audio/youtube/#spotdl.providers.audio.youtube.YouTube.get_results","title":"<code>get_results(search_term, *_args, **_kwargs)</code>  <code>staticmethod</code>","text":"<p>Get results from YouTube</p>"},{"location":"reference/providers/audio/youtube/#spotdl.providers.audio.youtube.YouTube.get_results--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to search for.</li> <li>args: Unused.</li> <li>kwargs: Unused.</li> </ul>"},{"location":"reference/providers/audio/youtube/#spotdl.providers.audio.youtube.YouTube.get_results--returns","title":"Returns","text":"<ul> <li>A list of YouTube results if found, None otherwise.</li> </ul> Source code in <code>spotdl/providers/audio/youtube.py</code> <pre><code>@staticmethod\ndef get_results(\n    search_term: str, *_args, **_kwargs\n) -&gt; Optional[List[PyTube]]:  # pylint: disable=W0221\n\"\"\"\n    Get results from YouTube\n\n    ### Arguments\n    - search_term: The search term to search for.\n    - args: Unused.\n    - kwargs: Unused.\n\n    ### Returns\n    - A list of YouTube results if found, None otherwise.\n    \"\"\"\n\n    return Search(search_term).results\n</code></pre>"},{"location":"reference/providers/audio/youtube/#spotdl.providers.audio.youtube.YouTube.order_results","title":"<code>order_results(results, song)</code>","text":"<p>Filter results based on the song's metadata.</p>"},{"location":"reference/providers/audio/youtube/#spotdl.providers.audio.youtube.YouTube.order_results--arguments","title":"Arguments","text":"<ul> <li>results: The results to order.</li> <li>song: The song to order for.</li> </ul>"},{"location":"reference/providers/audio/youtube/#spotdl.providers.audio.youtube.YouTube.order_results--returns","title":"Returns","text":"<ul> <li>The ordered results.</li> </ul> Source code in <code>spotdl/providers/audio/youtube.py</code> <pre><code>def order_results(\n    self, results: List[PyTube], song: Song\n) -&gt; Dict[str, Tuple[float, int]]:\n\"\"\"\n    Filter results based on the song's metadata.\n\n    ### Arguments\n    - results: The results to order.\n    - song: The song to order for.\n\n    ### Returns\n    - The ordered results.\n    \"\"\"\n\n    # Assign an overall avg match value to each result\n    links_with_match_value: Dict[str, Tuple[float, int]] = {}\n\n    # Slugify song title\n    slug_song_name = slugify(song.name)\n    slug_song_main_artist = slugify(song.artist)\n    slug_song_artists = slugify(\", \".join(song.artists))\n    slug_song_title = slugify(\n        create_song_title(song.name, song.artists)\n        if not self.search_query\n        else create_search_query(song, self.search_query, False, None, True)\n    )\n\n    # DEBUG CODE\n    # print(f\"#############################\")\n    # print(f\"slug_song_name: {slug_song_name}\")\n    # print(f\"slug_song_main_artist: {slug_song_main_artist}\")\n    # print(f\"slug_song_title: {slug_song_title}\")\n    # print(f\"slug_song_duration: {song.duration}\")\n    # print(f\"slug_song_artists: {slug_song_artists}\")\n    # print(f\"#############################\")\n\n    for result in results:\n        # Skip results without id\n        if result.video_id is None:\n            continue\n\n        # Slugify result title\n        slug_result_name = slugify(result.title)\n        slug_result_channel = slugify(result.author)\n\n        # check for common words in result name\n        sentence_words = slug_song_name.split(\"-\")\n        common_word = any(\n            word != \"\" and word in slug_result_name for word in sentence_words\n        )\n\n        # print(\"-----------------------------\")\n        # print(f\"sentence_words: {sentence_words}\")\n        # print(f\"common_word: {common_word}\")\n        # print(f\"result link: {result.watch_url}\")\n        # print(f\"result duration: {result.length}\")\n        # print(f\"slug_result_name: {slug_result_name}\")\n        # print(f\"slug_result_channel: {slug_result_channel}\")\n        # print(\"-----------------------------\")\n\n        # skip results that have no common words in their name\n        if not common_word:\n            continue\n\n        # Find artist match\n        artist_match = fuzz.ratio(\n            f\"{slug_song_artists}-{slug_song_name}\", slug_result_name\n        )\n\n        # print(f\"first artist match: {artist_match}\")\n\n        if artist_match &lt; 70:\n            # Try to use channel name instead\n            # with the main artist name\n            main_artist_match = fuzz.ratio(\n                slug_song_main_artist, slug_result_channel\n            )\n\n            slug_main_artist = slug_song_main_artist.replace(\"-\", \"\")\n\n            main_artist_match = slug_main_artist in [\n                slug_result_name.replace(\"-\", \"\"),\n                slug_result_channel.replace(\"-\", \"\"),\n            ]\n\n            # print(f\"main_artist_match: {main_artist_match}\")\n\n            # If the main artist name is in the channel name\n            # we add 30% to the artist match\n            if main_artist_match:\n                artist_match += 30\n                # print(f\"new artist_match: {artist_match}\")\n\n        # skip results with artist match lower than 70%\n        if artist_match &lt; 70:\n            # print(f\"! artist match lower than 70% {artist_match}, skipping\")\n            continue\n\n        # print(f\"final artist_match: {artist_match}\")\n\n        # Calculate name match\n        test_str1 = slug_result_name\n        test_str2 = slug_song_title\n\n        # check if the artist is in the song name\n        # but not in the result name\n        # if it is, we add the artist to the result name\n        for artist in song.artists:\n            slug_song_artist = slugify(artist)\n            if slug_song_artist in test_str2 and not slug_song_artist in test_str1:\n                test_str1 += f\"-{slug_song_artist}\"\n\n        # same thing for for song name\n        for artist in song.artists:\n            slug_result_artist = slugify(artist)\n            if (\n                slug_result_artist in test_str1\n                and not slug_result_artist in test_str2\n            ):\n                test_str2 += f\"-{slug_result_artist}\"\n\n        # calculate the name match\n        name_match = fuzz.ratio(test_str1, test_str2)\n\n        # Drop results with name match lower than 50%\n        if name_match &lt; 50:\n            # print(\"! name_match &lt; 50, skipping\")\n            continue\n\n        # print(f\"name_match: {name_match}\")\n\n        # Calculate time match\n        time_match = 100 - (\n            ((result.length - song.duration) ** 2) / song.duration * 100\n        )\n\n        # print(f\"time_match: {time_match}\")\n\n        # Drop results with time match lower than 50%\n        if time_match &lt; 50:\n            # print(\"! time_match &lt; 50, skipping\")\n            continue\n\n        average_match = (artist_match + name_match + time_match) / 3\n\n        # print(f\"average_match: {average_match}\")\n\n        # the results along with the avg Match\n        links_with_match_value[result.watch_url] = (average_match, result.views)\n\n    return links_with_match_value\n</code></pre>"},{"location":"reference/providers/audio/youtube/#spotdl.providers.audio.youtube.YouTube.search","title":"<code>search(song)</code>","text":"<p>Search for a video on YouTube.</p>"},{"location":"reference/providers/audio/youtube/#spotdl.providers.audio.youtube.YouTube.search--arguments","title":"Arguments","text":"<ul> <li>song: The song to search for.</li> </ul>"},{"location":"reference/providers/audio/youtube/#spotdl.providers.audio.youtube.YouTube.search--returns","title":"Returns","text":"<ul> <li>The url of the best match or None if no match was found.</li> </ul> Source code in <code>spotdl/providers/audio/youtube.py</code> <pre><code>def search(self, song: Song) -&gt; Optional[str]:\n\"\"\"\n    Search for a video on YouTube.\n\n    ### Arguments\n    - song: The song to search for.\n\n    ### Returns\n    - The url of the best match or None if no match was found.\n    \"\"\"\n\n    if self.search_query:\n        search_query = create_search_query(\n            song, self.search_query, False, None, True\n        )\n    else:\n        # if isrc is not None then we try to find song with it\n        if song.isrc:\n            isrc_results = self.get_results(song.isrc)\n\n            if isrc_results:\n                isrc_result = self.order_results(isrc_results, song)\n                if len(isrc_result) == 1:\n                    isrc_link, (isrc_score, _) = isrc_result.popitem()\n\n                    if isrc_score &gt; 90:\n                        # print(f\"# RETURN URL - {isrc_link} - isrc score\")\n                        return isrc_link\n\n                # print(f\"No results for ISRC: {song.isrc}\")\n\n        search_query = create_song_title(song.name, song.artists).lower()\n\n    # Query YTM by songs only first, this way if we get correct result on the first try\n    # we don't have to make another request to ytmusic api that could result in us\n    # getting rate limited sooner\n    results = self.get_results(search_query)\n\n    if results is None:\n        return None\n\n    if self.filter_results:\n        # Order results\n        ordered_results = self.order_results(results, song)\n    else:\n        ordered_results = {results[0].watch_url: (100.0, 9_000_000_000)}\n\n    # No matches found\n    if len(ordered_results) == 0:\n        return None\n\n    result_items = list(ordered_results.items())\n\n    # Sort results by highest score\n    sorted_results = sorted(result_items, key=lambda x: x[1], reverse=True)\n\n    last_simlar_index = 1\n    best_score, _ = sorted_results[0][1]\n\n    # Get few results with score close to the best score\n    for index, (_, (score, _)) in enumerate(sorted_results):\n        if (best_score - score) &gt; 8:\n            last_simlar_index = index\n            break\n\n    # Get the best results from the similar results\n    best_results = sorted_results[:last_simlar_index]\n\n    # If we have only one result, return it\n    if len(best_results) == 1:\n        # print(f\"# RETURN URL - {sorted_results[0][0]} - sorted, no best results\")\n        return sorted_results[0][0]\n\n    # print(f\"# best results: {best_results}\")\n\n    # If we have more than one result,\n    # return the one with the highest score\n    # and most views\n    views_data = [best_result[1][1] for best_result in best_results]\n\n    # print(f\"# views_data: {views_data}\")\n\n    best_result = best_results[views_data.index(max(views_data))]\n\n    # print(f\"# RETURN URL - {best_result[0]} - sorted, best results\")\n    return best_result[0]\n</code></pre>"},{"location":"reference/providers/audio/ytmusic/","title":"ytmusic","text":"<p>YTMusic module for downloading and searching songs.</p>"},{"location":"reference/providers/audio/ytmusic/#spotdl.providers.audio.ytmusic.YouTubeMusic","title":"<code>YouTubeMusic(*args, **kwargs)</code>","text":"<p>         Bases: <code>AudioProvider</code></p> <p>YouTube Music audio provider class</p>"},{"location":"reference/providers/audio/ytmusic/#spotdl.providers.audio.ytmusic.YouTubeMusic--arguments","title":"Arguments","text":"<ul> <li>args: Arguments passed to the <code>AudioProvider</code> class.</li> <li>kwargs: Keyword arguments passed to the <code>AudioProvider</code> class.</li> </ul> Source code in <code>spotdl/providers/audio/ytmusic.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n\"\"\"\n    Initialize the YouTube Music API\n\n    ### Arguments\n    - args: Arguments passed to the `AudioProvider` class.\n    - kwargs: Keyword arguments passed to the `AudioProvider` class.\n    \"\"\"\n\n    super().__init__(*args, **kwargs)\n    self.client = YTMusic()\n</code></pre>"},{"location":"reference/providers/audio/ytmusic/#spotdl.providers.audio.ytmusic.YouTubeMusic.get_best_match","title":"<code>get_best_match(results)</code>","text":"<p>Get the best match from the results using views and average match</p> Source code in <code>spotdl/providers/audio/ytmusic.py</code> <pre><code>def get_best_match(self, results: Dict[str, float]) -&gt; Tuple[str, float]:\n\"\"\"\n    Get the best match from the results\n    using views and average match\n    \"\"\"\n\n    result_items = list(results.items())\n\n    # Sort results by highest score\n    sorted_results = sorted(result_items, key=lambda x: x[1], reverse=True)\n\n    last_simlar_index = 1\n    best_score = sorted_results[0][1]\n\n    # Get few results with score close to the best score\n    for index, (_, score) in enumerate(sorted_results):\n        if (best_score - score) &gt; 8:\n            last_simlar_index = index\n            break\n\n    # print(f\"# last_simlar_index: {last_simlar_index}\")\n    # print(f\"# sorted_results: {sorted_results}\")\n\n    # Get the best results from the similar results\n    best_results = sorted_results[:last_simlar_index]\n\n    # If we have only one result, return it\n    if len(best_results) == 1:\n        # print(f\"# get_best_match URL - {sorted_results[0][0]} - only 1 result\")\n        return sorted_results[0][0], sorted_results[0][1]\n\n    # print(f\"# best results: {best_results}\")\n\n    # If we have more than one result,\n    # return the one with the highest score\n    # and most views\n    views_data = [\n        self.client.get_song(best_result[0].split(\"=\")[1])[\"videoDetails\"][\n            \"viewCount\"\n        ]\n        for best_result in best_results\n    ]\n\n    # print(f\"# views_data: {views_data}\")\n\n    best_result_index = views_data.index(str(max(map(int, views_data))))\n    best_result = best_results[best_result_index]\n\n    # print(f\"# get_best_match URL - {best_result[0]} - sorted by views\")\n    return best_result[0], best_result[1]\n</code></pre>"},{"location":"reference/providers/audio/ytmusic/#spotdl.providers.audio.ytmusic.YouTubeMusic.get_results","title":"<code>get_results(search_term, **kwargs)</code>","text":"<p>Get results from YouTube Music API and simplify them</p>"},{"location":"reference/providers/audio/ytmusic/#spotdl.providers.audio.ytmusic.YouTubeMusic.get_results--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to search for.</li> <li>kwargs: other keyword arguments passed to the <code>YTMusic.search</code> method.</li> </ul>"},{"location":"reference/providers/audio/ytmusic/#spotdl.providers.audio.ytmusic.YouTubeMusic.get_results--returns","title":"Returns","text":"<ul> <li>A list of simplified results (dicts)</li> </ul> Source code in <code>spotdl/providers/audio/ytmusic.py</code> <pre><code>def get_results(self, search_term: str, **kwargs) -&gt; List[Dict[str, Any]]:\n\"\"\"\n    Get results from YouTube Music API and simplify them\n\n    ### Arguments\n    - search_term: The search term to search for.\n    - kwargs: other keyword arguments passed to the `YTMusic.search` method.\n\n    ### Returns\n    - A list of simplified results (dicts)\n    \"\"\"\n\n    results = self.client.search(search_term, **kwargs)\n\n    # Simplify results\n    simplified_results = []\n    for result in results:\n        if result is None or result.get(\"videoId\") is None:\n            continue\n\n        artists_names = list(map(lambda a: a[\"name\"], result[\"artists\"]))\n\n        simplified_results.append(\n            {\n                \"name\": result[\"title\"],\n                \"type\": result[\"resultType\"],\n                \"link\": (\n                    f'https://{\"music\" if result[\"resultType\"] == \"song\" else \"www\"}'\n                    f\".youtube.com/watch?v={result['videoId']}\"\n                ),\n                \"album\": result.get(\"album\", {}).get(\"name\")\n                if result.get(\"album\")\n                else None,\n                \"duration\": parse_duration(result.get(\"duration\")),\n                \"artists\": \", \".join(artists_names),\n                \"artists_list\": artists_names,\n            }\n        )\n\n    return simplified_results\n</code></pre>"},{"location":"reference/providers/audio/ytmusic/#spotdl.providers.audio.ytmusic.YouTubeMusic.order_results","title":"<code>order_results(results, song, is_isrc=False)</code>","text":"<p>Filter results based on the song's metadata.</p>"},{"location":"reference/providers/audio/ytmusic/#spotdl.providers.audio.ytmusic.YouTubeMusic.order_results--arguments","title":"Arguments","text":"<ul> <li>results: The results to filter.</li> <li>song: The song to filter by.</li> <li>is_isrc: Whether the results are from an isrc search.</li> </ul>"},{"location":"reference/providers/audio/ytmusic/#spotdl.providers.audio.ytmusic.YouTubeMusic.order_results--returns","title":"Returns","text":"<ul> <li>A dict of filtered results.</li> </ul> Source code in <code>spotdl/providers/audio/ytmusic.py</code> <pre><code>def order_results(\n    self, results: List[Dict[str, Any]], song: Song, is_isrc: bool = False\n) -&gt; Dict[str, float]:\n\"\"\"\n    Filter results based on the song's metadata.\n\n    ### Arguments\n    - results: The results to filter.\n    - song: The song to filter by.\n    - is_isrc: Whether the results are from an isrc search.\n\n    ### Returns\n    - A dict of filtered results.\n    \"\"\"\n\n    # Slugify some variables\n    slug_song_name = slugify(song.name)\n    sentence_words = slug_song_name.split(\"-\")\n    slug_song_album_name = slugify(song.album_name)\n    slug_song_main_artist = slugify(song.artist)\n    slug_song_artists = slugify(\", \".join(song.artists))\n    slug_song_title = slugify(\n        create_song_title(song.name, song.artists)\n        if not self.search_query\n        else create_search_query(song, self.search_query, False, None, True)\n    )\n\n    # DEBUG CODE\n    # print(\"#############################\")\n    # print(f\"song.name: {song.name}\")\n    # print(f\"song.album_name: {song.album_name}\")\n    # print(f\"song.artist: {song.artist}\")\n    # print(f\"song.artists: {song.artists}\")\n    # print(f\"song.isrc: {song.isrc}\")\n    # print(f\"song.duration: {song.duration}\")\n    # print(f\"slug_song_name: {slug_song_name}\")\n    # print(f\"slug_song_album_name: {slug_song_album_name}\")\n    # print(f\"slug_song_main_artist: {slug_song_main_artist}\")\n    # print(f\"slug_song_artists: {slug_song_artists}\")\n    # print(f\"slug_song_title: {slug_song_title}\")\n    # print(f\"slug_song_duration: {song.duration}\")\n    # print(f\"slug_song_artists: {slug_song_artists}\")\n    # print(f\"sentence_words: {sentence_words}\")\n    # print(\"#############################\")\n\n    # Assign an overall avg match value to each result\n    links_with_match_value = {}\n    for result in results:\n        # Slugify result title\n        slug_result_name = slugify(result[\"name\"])\n        slug_result_artists = slugify(result[\"artists\"])\n        slug_result_album = (\n            slugify(result[\"album\"]) if result.get(\"album\") else None\n        )\n\n        # check for common words in result name\n        common_word = any(\n            word != \"\" and word in slug_result_name for word in sentence_words\n        )\n\n        test_str1 = slug_result_name\n        test_str2 = slug_song_name if result[\"type\"] == \"song\" else slug_song_title\n\n        # check if the artist is in the song name\n        # but not in the result name\n        # if it is, we add the artist to the result name\n        for artist in song.artists:\n            slug_song_artist = slugify(artist).replace(\"-\", \"\")\n            if slug_song_artist in test_str2.replace(\n                \"-\", \"\"\n            ) and slug_song_artist not in test_str1.replace(\"-\", \"\"):\n                test_str1 += f\"-{slug_song_artist}\"\n\n        # same thing for for song name\n        for artist in song.artists:\n            slug_result_artist = slugify(artist).replace(\"-\", \"\")\n            if slug_result_artist in test_str1.replace(\n                \"-\", \"\"\n            ) and slug_result_artist not in test_str2.replace(\"-\", \"\"):\n                test_str2 += f\"-{slug_result_artist}\"\n\n        test_str1_list = test_str1.split(\"-\")\n        test_str2_list = test_str2.split(\"-\")\n\n        test_str1_list.sort()\n        test_str2_list.sort()\n\n        test_str1 = \"-\".join(test_str1_list)\n        test_str2 = \"-\".join(test_str2_list)\n\n        # print(\"-----------------------------\")\n        # print(f\"sentence_words: {sentence_words}\")\n        # print(f\"common_word: {common_word}\")\n        # print(f\"result link: {result['link']}\")\n        # print(f\"result type: {result['type']}\")\n        # print(f\"result duration: {result['duration']}\")\n        # print(f\"result artists_list: {result['artists_list']}\")\n        # print(f\"slug_result_name: {slug_result_name}\")\n        # print(f\"slug_result_artists: {slug_result_artists}\")\n        # print(f\"slug_result_album: {slug_result_album}\")\n        # print(f\"test_str1: {test_str1}\")\n        # print(f\"test_str2: {test_str2}\")\n        # print(\"-----------------------------\")\n\n        # skip results that have no common words in their name\n        if not common_word:\n            continue\n\n        # initialize match value to 0\n        main_artist_match = 0.0\n\n        # check if artists list is not empty\n        # if it isn't perform initial match\n        # on the main artists\n        if result[\"artists_list\"]:\n            main_artist_match = fuzz.ratio(\n                slug_song_main_artist, slugify(result[\"artists_list\"][0])\n            )\n\n        # print(f\"? main_artist_match: {main_artist_match}\")\n\n        artist_match_number = main_artist_match\n        if len(song.artists) &gt; 1:\n            # match the song's artists with the result's artists\n\n            if len(song.artists) == len(result[\"artists_list\"]):\n                artists_match = fuzz.ratio(slug_song_artists, slug_result_artists)\n                # print(f\"exact artists_match: {artists_match}\")\n            else:\n                artists_match = artist_match_number\n                if (len(result[\"artists_list\"]) * 100) / len(\n                    song.artists\n                ) &gt; 60 and len(song.artists) &gt; 2:\n                    # Sort list1\n                    artist1_list = list(map(slugify, song.artists))\n                    artist1_list.sort()\n\n                    # Sort list2\n                    artist2_list = list(map(slugify, result[\"artists_list\"]))\n                    artist2_list.sort()\n\n                    # print(f\"artist1_list: {artist1_list}\")\n                    # print(f\"artist2_list: {artist2_list}\")\n\n                    list_map = {\n                        value: index for index, value in enumerate(artist2_list)\n                    }\n                    # print(f\"list_map: {list_map}\")\n\n                    # Sort list2 based on list1\n                    artist1_list = sorted(\n                        artist1_list,\n                        key=lambda x: list_map.get(x, -1),\n                        reverse=True,\n                    )\n\n                    # print(f\"artist1_list after sorting: {artist1_list}\")\n\n                    artists_match = 0.0\n                    for artist1, artist2 in zip_longest(artist1_list, artist2_list):\n                        artists_match += fuzz.ratio(artist1, artist2)\n\n                    artists_match = artists_match / len(artist1_list)\n\n                    # print(f\"artists_match: {artists_match}/{len(artist2_list)})\")\n\n            artist_match_number += artists_match\n\n        artist_match = artist_match_number / (2 if len(song.artists) &gt; 1 else 1)\n        # print(\"? first artist_match: \", artist_match)\n\n        # additional checks for results that are not songs\n        if artist_match &lt;= 50 and result[\"type\"] != \"song\":\n            # If we didn't find any artist match,\n            # we fallback to channel name match\n            channel_name_match = fuzz.ratio(\n                slugify(song.artist),\n                slug_result_artists,\n            )\n\n            if channel_name_match &gt; artist_match_number:\n                artist_match = channel_name_match\n                # print(\"? second artist_match: \", artist_match)\n\n            # If artist match is still too low,\n            # we fallback to matching all song artist names\n            # with the result's title\n            if artist_match &lt;= 50:\n                artist_title_match = 0.0\n                for artist in song.artists:\n                    slug_artist = slugify(artist).replace(\"-\", \"\")\n                    if slug_artist in slug_result_name.replace(\"-\", \"\"):\n                        artist_title_match += 1.0\n\n                artist_title_match = (artist_title_match / len(song.artists)) * 100\n                # print(f\"? artist_title_match: {artist_title_match}\")\n\n                if artist_title_match &gt; artist_match:\n                    artist_match = artist_title_match\n                    # print(\"? third artist_match: \", artist_match)\n\n        # additional checks for results that are songs\n        if artist_match &lt; 70 and result[\"type\"] == \"song\":\n            # Check if the song name is very similar to the result name\n            if (\n                fuzz.ratio(\n                    test_str1,\n                    test_str2,\n                )\n                &gt;= 75\n            ):\n                # If it is, we increase the artist match\n                artist_match += 10\n                # print(\"? song name artist_match: \", artist_match)\n\n                # if the result doesn't have the same number of artists but has\n                # the same main artist and similar name\n                # we add 25% to the artist match\n                if len(result[\"artists_list\"]) &lt; len(\n                    song.artists\n                ) and slug_song_main_artist.replace(\"-\", \"\") in [\n                    slug_result_artists.replace(\"-\", \"\"),\n                    slug_result_name.replace(\"-\", \"\"),\n                ]:\n                    artist_match += 25\n                    # print(\"? hacky artist_match: \", artist_match)\n\n            # Check if the song album name is very similar to the result album name\n            # if it is, we increase the artist match\n            if slug_result_album:\n                if fuzz.ratio(slug_result_album, slug_song_album_name) &gt;= 85:\n                    artist_match += 10\n                    # print(\"? album artist_match: \", artist_match)\n\n            # Check if other song artists are in the result name\n            # if they are, we increase the artist match\n            # (main artist is already checked, so we skip it)\n            artists_to_check = (\n                song.artists[1:] if main_artist_match &gt; 50 else song.artists\n            )\n            for artist in artists_to_check:\n                slug_song_artist = slugify(artist).replace(\"-\", \"\")\n                if slug_song_artist in test_str2.replace(\"-\", \"\"):\n                    artist_match += 15 if len(song.artists[1:]) &lt;= 2 else 10\n                    # print(\"? other artist artist_match: \", artist_match)\n\n            # if the artist match is still too low,\n            # we fallback to matching all song artist names\n            # with the result's title with rapidfuzz\n            if artist_match &lt;= 70:\n                # artists from title without title words\n                clean_title1 = [\n                    artist\n                    for artist in map(slugify, song.artists)\n                    if artist.replace(\"-\", \"\")\n                    not in slug_song_name.replace(\"-\", \"\")\n                ]\n\n                # artists from result name without title words\n                clean_title2 = [\n                    artist\n                    for artist in map(slugify, result[\"artists_list\"])\n                    if artist.replace(\"-\", \"\")\n                    not in slug_result_name.replace(\"-\", \"\")\n                ]\n\n                clean_title1.sort()\n                clean_title2.sort()\n\n                # print(f\"clean_title1: {clean_title1}\")\n                # print(f\"clean_title2: {clean_title2}\")\n\n                artist_title_match = fuzz.ratio(\n                    \"-\".join(clean_title1),\n                    \"-\".join(clean_title2),\n                )\n\n                if artist_title_match &gt; artist_match:\n                    artist_match = artist_title_match\n                    # print(\"? fourth artist_match: \", artist_match)\n\n        # print(\"? final artist_match: \", artist_match)\n\n        # skip results with artist match lower than 70%\n        if artist_match &lt; 70:\n            # print(\"! artist_match &lt; 70 - skipping\")\n            continue\n\n        # check if the artist match is higher than 100%\n        # if it is, we set it to 100% (this shouldn't happen)\n        artist_match = min(artist_match, 100)\n\n        # Calculate name match\n        if artist_match &gt;= 75:\n            name_match = fuzz.ratio(\n                test_str1,\n                test_str2,\n            )\n        else:\n            name_match = fuzz.ratio(\n                slug_result_name,\n                slug_song_name,\n            )\n\n        # Drop results with name match lower than 50%\n        # print(f\"name_match: {name_match}\")\n        if name_match &lt; 50:\n            # print(\"! name_match &lt; 50 - skipping\")\n            continue\n\n        # Find album match\n        album_match = 0.0\n\n        # Calculate album match only for songs\n        if result[\"type\"] == \"song\":\n            if slug_result_album:\n                album_match = fuzz.ratio(slug_result_album, slug_song_album_name)\n\n        # Calculate time match\n        delta = result[\"duration\"] - song.duration\n        non_match_value = (delta**2) / song.duration * 100\n        time_match = 100 - non_match_value\n\n        # print(f\"? time_match: {time_match}\")\n\n        # Calculate total match\n        average_match = (artist_match + name_match) / 2\n\n        # print(f\"? album_match: {album_match}\")\n        # print(f\"? time_match: {time_match}\")\n        # print(f\"? average_match (only artist and name): {average_match}\")\n\n        if (\n            result[\"type\"] == \"song\"\n            and slug_result_album\n            and average_match &gt; 80\n            and time_match &gt; 80\n        ):\n            # we are almost certain that this is the correct result\n            # so we add the album match to the average match\n            average_match = average_match + album_match / 2\n\n            # print(f\"? average_match with album_match: {average_match}\")\n\n        if time_match &lt; 50 and average_match &lt; 85:\n            # If the time match is lower than 50% and the average match is lower than 85%\n            # we skip the result\n            # print(\"! time_match &lt; 50 and average_match &lt; 85 - skipping\")\n            continue\n\n        if time_match &lt; 50 and not is_isrc:\n            # If the time match is lower than 50% but the average match is higher than 85%\n            # we add time match to the average match\n\n            # if the result is an isrc result\n            # or has really good average/album match\n            # we don't add time match\n            if average_match &lt; 85 and album_match &lt;= 75:\n                average_match = (average_match + time_match) / 2\n                # print(f\"? average_match with time_match, not isrc: {average_match}\")\n\n        # print(f\"? final average_match: {average_match}\")\n\n        # the results along with the avg Match\n        links_with_match_value[result[\"link\"]] = average_match\n\n    return links_with_match_value\n</code></pre>"},{"location":"reference/providers/audio/ytmusic/#spotdl.providers.audio.ytmusic.YouTubeMusic.search","title":"<code>search(song)</code>","text":"<p>Search for a song on YouTube Music.</p>"},{"location":"reference/providers/audio/ytmusic/#spotdl.providers.audio.ytmusic.YouTubeMusic.search--arguments","title":"Arguments","text":"<ul> <li>song: The song to search for.</li> </ul>"},{"location":"reference/providers/audio/ytmusic/#spotdl.providers.audio.ytmusic.YouTubeMusic.search--returns","title":"Returns","text":"<ul> <li>The url of the best match or None if no match was found.</li> </ul> Source code in <code>spotdl/providers/audio/ytmusic.py</code> <pre><code>def search(self, song: Song) -&gt; Optional[str]:\n\"\"\"\n    Search for a song on YouTube Music.\n\n    ### Arguments\n    - song: The song to search for.\n\n    ### Returns\n    - The url of the best match or None if no match was found.\n    \"\"\"\n\n    if self.search_query:\n        search_query = create_search_query(\n            song, self.search_query, False, None, True\n        )\n    else:\n        # search for song using isrc if it's available\n        if song.isrc:\n            isrc_results = self.get_results(\n                song.isrc, filter=\"songs\", ignore_spelling=True\n            )\n\n            if len(isrc_results) == 1:\n                isrc_result = self.order_results([isrc_results[0]], song, True)\n                if len(isrc_result) == 1:\n                    isrc_link, isrc_score = isrc_result.popitem()\n\n                    if isrc_score &gt; 90:\n                        # print(f\"# RETURN URL - {isrc_link} - isrc score\")\n                        return isrc_link\n\n            # print(f\"# no match found for isrc {song.name} - {song.isrc}\")\n\n        search_query = create_song_title(song.name, song.artists).lower()\n\n    # Query YTM by songs only first, this way if we get correct result on the first try\n    # we don't have to make another request\n    song_results = self.get_results(\n        search_query, filter=\"songs\", ignore_spelling=True\n    )\n\n    if self.filter_results:\n        # Order results\n        songs = self.order_results(song_results, song)\n    else:\n        songs = {}\n        if len(song_results) &gt; 0:\n            songs = {song_results[0][\"link\"]: 100.0}\n\n    # song type results are always more accurate than video type,\n    # so if we get score of 80 or above\n    # we are almost 100% sure that this is the correct link\n    if len(songs) != 0:\n        # get the result with highest score\n        best_url, best_score = self.get_best_match(songs)\n\n        if best_score &gt;= 80:\n            # print(f\"# RETURN URL - {best_url} - score &gt;= 80\")\n            return best_url\n\n    # We didn't find the correct song on the first try so now we get video type results\n    # add them to song_results, and get the result with highest score\n    video_results = self.get_results(\n        search_query, filter=\"videos\", ignore_spelling=True\n    )\n\n    if self.filter_results:\n        # Order video results\n        videos = self.order_results(video_results, song)\n    else:\n        videos = {}\n        if len(video_results) &gt; 0:\n            videos = {video_results[0][\"link\"]: 100.0}\n\n    # Merge songs and video results\n    results = {**songs, **videos}\n\n    # No matches found\n    if not results:\n        return None\n\n    # get the result with highest score\n    best_url, best_score = self.get_best_match(results)\n\n    # print(f\"# RETURN URL - {best_url} /w video results - score {best_score}\")\n\n    return best_url\n</code></pre>"},{"location":"reference/providers/lyrics/","title":"lyrics","text":"<p>Lyrics providers for spotdl.</p>"},{"location":"reference/providers/lyrics/azlyrics/","title":"azlyrics","text":"<p>AZLyrics lyrics module.</p>"},{"location":"reference/providers/lyrics/azlyrics/#spotdl.providers.lyrics.azlyrics.AzLyrics","title":"<code>AzLyrics()</code>","text":"<p>         Bases: <code>LyricsProvider</code></p> <p>AZLyrics lyrics provider class.</p> Source code in <code>spotdl/providers/lyrics/azlyrics.py</code> <pre><code>def __init__(self):\n    super().__init__()\n\n    self.session = requests.Session()\n    self.session.headers.update(self.headers)\n\n    # Not sure if this is needed\n    # but it doesn't hurt\n    self.session.get(\"https://www.azlyrics.com/\")\n\n    resp = self.session.get(\"https://www.azlyrics.com/geo.js\")\n\n    # extract value from js code\n    js_code = resp.text\n    start_index = js_code.find('value\"') + 9\n    end_index = js_code[start_index:].find('\");')\n\n    self.x_code = js_code[start_index : start_index + end_index]\n</code></pre>"},{"location":"reference/providers/lyrics/azlyrics/#spotdl.providers.lyrics.azlyrics.AzLyrics.get_lyrics","title":"<code>get_lyrics(name, artists, **_)</code>","text":"<p>Try to get lyrics from azlyrics</p>"},{"location":"reference/providers/lyrics/azlyrics/#spotdl.providers.lyrics.azlyrics.AzLyrics.get_lyrics--arguments","title":"Arguments","text":"<ul> <li>name: The name of the song.</li> <li>artists: The artists of the song.</li> </ul>"},{"location":"reference/providers/lyrics/azlyrics/#spotdl.providers.lyrics.azlyrics.AzLyrics.get_lyrics--returns","title":"Returns","text":"<ul> <li>The lyrics of the song or None if no lyrics were found.</li> </ul> Source code in <code>spotdl/providers/lyrics/azlyrics.py</code> <pre><code>def get_lyrics(self, name: str, artists: List[str], **_) -&gt; Optional[str]:\n\"\"\"\n    Try to get lyrics from azlyrics\n\n    ### Arguments\n    - name: The name of the song.\n    - artists: The artists of the song.\n\n    ### Returns\n    - The lyrics of the song or None if no lyrics were found.\n    \"\"\"\n\n    # Join every artist by comma in artists\n    artist_str = \", \".join(artist for artist in artists if artist)\n\n    params = {\n        \"q\": f\"{artist_str} - {name}\",\n        \"x\": self.x_code,\n    }\n\n    response = self.session.get(\n        \"https://search.azlyrics.com/search.php\", params=params\n    )\n    soup = BeautifulSoup(response.content, \"html.parser\")\n\n    td_tags = soup.find_all(\"td\")\n    if len(td_tags) == 0:\n        return None\n\n    result = td_tags[0]\n\n    a_tags = result.find_all(\"a\", href=True)\n    if len(a_tags) != 0:\n        lyrics_url = a_tags[0][\"href\"]\n    else:\n        return None\n\n    if lyrics_url.strip() == \"\":\n        return None\n\n    response = self.session.get(lyrics_url)\n    soup = BeautifulSoup(response.content, \"html.parser\")\n\n    # Find all divs that don't have a class\n    div_tags = soup.find_all(\"div\", class_=False, id_=False)\n\n    # Find the div with the longest text\n    lyrics_div = sorted(div_tags, key=lambda x: len(x.text))[-1]\n\n    # extract lyrics from div and clean it up\n    lyrics = lyrics_div.get_text().strip()\n\n    return lyrics\n</code></pre>"},{"location":"reference/providers/lyrics/base/","title":"base","text":"<p>Base module for all other lyrics providers.</p>"},{"location":"reference/providers/lyrics/base/#spotdl.providers.lyrics.base.LyricsProvider","title":"<code>LyricsProvider()</code>","text":"<p>Base class for all other lyrics providers.</p> Source code in <code>spotdl/providers/lyrics/base.py</code> <pre><code>def __init__(self):\n\"\"\"\n    Init the lyrics provider searchand set headers.\n    \"\"\"\n\n    self.headers = {\n        \"Connection\": \"keep-alive\",\n        \"Pragma\": \"no-cache\",\n        \"Cache-Control\": \"no-cache\",\n        \"sec-ch-ua\": '\"Chromium\";v=\"104\", \" Not A;Brand\";v=\"99\", \"Google Chrome\";v=\"104\"',\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 \"\n        \"(KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36\",\n        \"Accept\": \"*/*\",\n        \"Sec-Fetch-Site\": \"same-origin\",\n        \"Sec-Fetch-Mode\": \"cors\",\n        \"Sec-Fetch-Dest\": \"empty\",\n        \"Accept-Language\": \"en-US;q=0.8,en;q=0.7\",\n    }\n</code></pre>"},{"location":"reference/providers/lyrics/base/#spotdl.providers.lyrics.base.LyricsProvider.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Returns the name of the lyrics provider.</p>"},{"location":"reference/providers/lyrics/base/#spotdl.providers.lyrics.base.LyricsProvider.get_lyrics","title":"<code>get_lyrics(name, artists, **kwargs)</code>","text":"<p>Returns the lyrics for the given song.</p>"},{"location":"reference/providers/lyrics/base/#spotdl.providers.lyrics.base.LyricsProvider.get_lyrics--arguments","title":"Arguments","text":"<ul> <li>name: The name of the song.</li> <li>artists: The artists of the song.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/lyrics/base/#spotdl.providers.lyrics.base.LyricsProvider.get_lyrics--returns","title":"Returns","text":"<ul> <li>The lyrics of the song or None if no lyrics were found.</li> </ul> Source code in <code>spotdl/providers/lyrics/base.py</code> <pre><code>def get_lyrics(self, name: str, artists: List[str], **kwargs) -&gt; Optional[str]:\n\"\"\"\n    Returns the lyrics for the given song.\n\n    ### Arguments\n    - name: The name of the song.\n    - artists: The artists of the song.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - The lyrics of the song or None if no lyrics were found.\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/providers/lyrics/genius/","title":"genius","text":"<p>Genius Lyrics module.</p>"},{"location":"reference/providers/lyrics/genius/#spotdl.providers.lyrics.genius.Genius","title":"<code>Genius</code>","text":"<p>         Bases: <code>LyricsProvider</code></p> <p>Genius lyrics provider class.</p>"},{"location":"reference/providers/lyrics/genius/#spotdl.providers.lyrics.genius.Genius.get_lyrics","title":"<code>get_lyrics(name, artists, **_)</code>","text":"<p>Try to get lyrics from genius</p>"},{"location":"reference/providers/lyrics/genius/#spotdl.providers.lyrics.genius.Genius.get_lyrics--arguments","title":"Arguments","text":"<ul> <li>name: The name of the song.</li> <li>artists: The artists of the song.</li> </ul>"},{"location":"reference/providers/lyrics/genius/#spotdl.providers.lyrics.genius.Genius.get_lyrics--returns","title":"Returns","text":"<ul> <li>The lyrics of the song or None if no lyrics were found.</li> </ul> Source code in <code>spotdl/providers/lyrics/genius.py</code> <pre><code>def get_lyrics(self, name: str, artists: List[str], **_) -&gt; Optional[str]:\n\"\"\"\n    Try to get lyrics from genius\n\n    ### Arguments\n    - name: The name of the song.\n    - artists: The artists of the song.\n\n    ### Returns\n    - The lyrics of the song or None if no lyrics were found.\n    \"\"\"\n\n    try:\n        headers = {\n            \"Authorization\": \"Bearer \"\n            \"alXXDbPZtK1m2RrZ8I4k2Hn8Ahsd0Gh_o076HYvcdlBvmc0ULL1H8Z8xRlew5qaG\",\n        }\n\n        headers.update(self.headers)\n\n        artist_str = \", \".join(\n            artist for artist in artists if artist.lower() not in name.lower()\n        )\n\n        search_response = requests.get(\n            \"https://api.genius.com/search\",\n            params={\"q\": f\"{name} {artist_str}\"},\n            headers=headers,\n            timeout=10,\n        )\n\n        song_id = search_response.json()[\"response\"][\"hits\"][0][\"result\"][\"id\"]\n\n        song_response = requests.get(\n            f\"https://api.genius.com/songs/{song_id}\", headers=headers, timeout=10\n        )\n\n        song_url = song_response.json()[\"response\"][\"song\"][\"url\"]\n\n        counter = 0\n        soup = None\n        while counter &lt; 4:\n            genius_page_response = requests.get(\n                song_url, headers=self.headers, timeout=10\n            )\n\n            if not genius_page_response.ok:\n                counter += 1\n                continue\n\n            soup = BeautifulSoup(\n                genius_page_response.text.replace(\"&lt;br/&gt;\", \"\\n\"), \"html.parser\"\n            )\n\n            break\n\n        if soup is None:\n            return None\n\n        lyrics_div = soup.select_one(\"div.lyrics\")\n\n        if lyrics_div is not None:\n            return lyrics_div.get_text().strip()\n\n        lyrics_containers = soup.select(\"div[class^=Lyrics__Container]\")\n        lyrics = \"\\n\".join(con.get_text() for con in lyrics_containers)\n        return lyrics.strip()\n    except Exception:\n        return None\n</code></pre>"},{"location":"reference/providers/lyrics/musixmatch/","title":"musixmatch","text":"<p>MusixMatch lyrics provider.</p>"},{"location":"reference/providers/lyrics/musixmatch/#spotdl.providers.lyrics.musixmatch.MusixMatch","title":"<code>MusixMatch</code>","text":"<p>         Bases: <code>LyricsProvider</code></p> <p>MusixMatch lyrics provider class.</p>"},{"location":"reference/providers/lyrics/musixmatch/#spotdl.providers.lyrics.musixmatch.MusixMatch.get_lyrics","title":"<code>get_lyrics(name, artists, **kwargs)</code>","text":"<p>Try to get lyrics from musixmatch</p>"},{"location":"reference/providers/lyrics/musixmatch/#spotdl.providers.lyrics.musixmatch.MusixMatch.get_lyrics--arguments","title":"Arguments","text":"<ul> <li>name: The name of the song.</li> <li>artists: The artists of the song.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/lyrics/musixmatch/#spotdl.providers.lyrics.musixmatch.MusixMatch.get_lyrics--returns","title":"Returns","text":"<ul> <li>The lyrics of the song or None if no lyrics were found.</li> </ul> Source code in <code>spotdl/providers/lyrics/musixmatch.py</code> <pre><code>def get_lyrics(self, name: str, artists: List[str], **kwargs) -&gt; Optional[str]:\n\"\"\"\n    Try to get lyrics from musixmatch\n\n    ### Arguments\n    - name: The name of the song.\n    - artists: The artists of the song.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - The lyrics of the song or None if no lyrics were found.\n    \"\"\"\n\n    try:\n        track_search = kwargs.get(\"track_search\", False)\n\n        artists_str = \", \".join(\n            artist for artist in artists if artist.lower() not in name.lower()\n        )\n\n        # quote the query so that it's safe to use in a url\n        # e.g \"Au/Ra\" -&gt; \"Au%2FRa\"\n        query = quote(f\"{name} - {artists_str}\", safe=\"\")\n\n        # search the `tracks page` if track_search is True\n        if track_search:\n            query += \"/tracks\"\n\n        search_url = f\"https://www.musixmatch.com/search/{query}\"\n        search_resp = requests.get(search_url, headers=self.headers, timeout=10)\n\n        search_soup = BeautifulSoup(search_resp.text, \"html.parser\")\n        song_url_tag = search_soup.select_one(\"a[href^='/lyrics/']\")\n\n        # song_url_tag being None means no results were found on the\n        # All Results page, therefore, we use `track_search` to\n        # search the tracks page.\n        if song_url_tag is None:\n            # track_serach being True means we are already searching the tracks page.\n            if track_search:\n                return None\n\n            lyrics = self.get_lyrics(name, artists, track_search=True)\n            return lyrics\n\n        song_url = \"https://www.musixmatch.com\" + str(song_url_tag.get(\"href\", \"\"))\n        lyrics_resp = requests.get(song_url, headers=self.headers, timeout=10)\n\n        lyrics_soup = BeautifulSoup(lyrics_resp.text, \"html.parser\")\n        lyrics_paragraphs = lyrics_soup.select(\"p.mxm-lyrics__content\")\n        lyrics = \"\\n\".join(i.get_text() for i in lyrics_paragraphs)\n\n        return lyrics\n    except Exception:\n        return None\n</code></pre>"},{"location":"reference/types/","title":"types","text":"<p>Types for the spotdl package.</p>"},{"location":"reference/types/album/","title":"album","text":"<p>Artist module for retrieving artist data from Spotify.</p>"},{"location":"reference/types/album/#spotdl.types.album.Album","title":"<code>Album</code>  <code>dataclass</code>","text":"<p>         Bases: <code>SongList</code></p> <p>Album class for retrieving album data from Spotify.</p>"},{"location":"reference/types/album/#spotdl.types.album.Album.get_metadata","title":"<code>get_metadata(url)</code>  <code>staticmethod</code>","text":"<p>Get metadata for album.</p>"},{"location":"reference/types/album/#spotdl.types.album.Album.get_metadata--arguments","title":"Arguments","text":"<ul> <li>url: The URL of the album.</li> </ul>"},{"location":"reference/types/album/#spotdl.types.album.Album.get_metadata--returns","title":"Returns","text":"<ul> <li>A dictionary with metadata.</li> </ul> Source code in <code>spotdl/types/album.py</code> <pre><code>@staticmethod\ndef get_metadata(url: str) -&gt; Dict[str, Any]:\n\"\"\"\n    Get metadata for album.\n\n    ### Arguments\n    - url: The URL of the album.\n\n    ### Returns\n    - A dictionary with metadata.\n    \"\"\"\n\n    spotify_client = SpotifyClient()\n\n    album_metadata = spotify_client.album(url)\n    if album_metadata is None:\n        raise AlbumError(\n            \"Couldn't get metadata, check if you have passed correct album id\"\n        )\n\n    return {\n        \"name\": album_metadata[\"name\"],\n        \"artist\": album_metadata[\"artists\"][0],\n        \"url\": url,\n    }\n</code></pre>"},{"location":"reference/types/album/#spotdl.types.album.Album.get_urls","title":"<code>get_urls(url)</code>  <code>staticmethod</code>","text":"<p>Get urls for all songs in album.</p>"},{"location":"reference/types/album/#spotdl.types.album.Album.get_urls--arguments","title":"Arguments","text":"<ul> <li>url: The URL of the album.</li> </ul>"},{"location":"reference/types/album/#spotdl.types.album.Album.get_urls--returns","title":"Returns","text":"<ul> <li>A list of urls.</li> </ul> Source code in <code>spotdl/types/album.py</code> <pre><code>@staticmethod\ndef get_urls(url: str) -&gt; List[str]:\n\"\"\"\n    Get urls for all songs in album.\n\n    ### Arguments\n    - url: The URL of the album.\n\n    ### Returns\n    - A list of urls.\n    \"\"\"\n\n    spotify_client = SpotifyClient()\n\n    album_response = spotify_client.album_tracks(url)\n    if album_response is None:\n        raise AlbumError(\n            \"Couldn't get metadata, check if you have passed correct album id\"\n        )\n\n    tracks = album_response[\"items\"]\n\n    # Get all tracks from album\n    while album_response[\"next\"]:\n        album_response = spotify_client.next(album_response)\n\n        # Failed to get response, break the loop\n        if album_response is None:\n            break\n\n        tracks.extend(album_response[\"items\"])\n\n    if album_response is None:\n        raise AlbumError(f\"Failed to get album response: {url}\")\n\n    return [\n        track[\"external_urls\"][\"spotify\"]\n        for track in tracks\n        if track and track.get(\"id\")\n    ]\n</code></pre>"},{"location":"reference/types/album/#spotdl.types.album.Album.search","title":"<code>search(search_term)</code>  <code>classmethod</code>","text":"<p>Searches for Album from a search term.</p>"},{"location":"reference/types/album/#spotdl.types.album.Album.search--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to use.</li> </ul>"},{"location":"reference/types/album/#spotdl.types.album.Album.search--returns","title":"Returns","text":"<ul> <li>The raw search results</li> </ul> Source code in <code>spotdl/types/album.py</code> <pre><code>@classmethod\ndef search(cls, search_term: str):\n\"\"\"\n    Searches for Album from a search term.\n\n    ### Arguments\n    - search_term: The search term to use.\n\n    ### Returns\n    - The raw search results\n    \"\"\"\n\n    spotify_client = SpotifyClient()\n    raw_search_results = spotify_client.search(search_term, type=\"album\")\n\n    if (\n        raw_search_results is None\n        or len(raw_search_results.get(\"albums\", {}).get(\"items\", [])) == 0\n    ):\n        raise AlbumError(\"No album matches found on spotify\")\n\n    return raw_search_results\n</code></pre>"},{"location":"reference/types/album/#spotdl.types.album.AlbumError","title":"<code>AlbumError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Base class for all exceptions related to albums.</p>"},{"location":"reference/types/artist/","title":"artist","text":"<p>Artist module for retrieving artist data from Spotify.</p>"},{"location":"reference/types/artist/#spotdl.types.artist.Artist","title":"<code>Artist</code>  <code>dataclass</code>","text":"<p>         Bases: <code>SongList</code></p> <p>Artist class. Contains all the information about an artist. Frozen to prevent accidental modification.</p>"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.create_basic_list","title":"<code>create_basic_list(url)</code>  <code>classmethod</code>","text":"<p>Create a basic list with only the required metadata and urls.</p>"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.create_basic_list--arguments","title":"Arguments","text":"<ul> <li>url: The url of the list.</li> </ul>"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.create_basic_list--returns","title":"Returns","text":"<ul> <li>The SongList object.</li> </ul> Source code in <code>spotdl/types/artist.py</code> <pre><code>@classmethod\ndef create_basic_list(cls, url: str) -&gt; \"Artist\":\n\"\"\"\n    Create a basic list with only the required metadata and urls.\n\n    ### Arguments\n    - url: The url of the list.\n\n    ### Returns\n    - The SongList object.\n    \"\"\"\n\n    metadata = Artist.get_metadata(url)\n    urls = Artist.get_urls(url)\n\n    return cls(**metadata, urls=urls, songs=[], albums=[])\n</code></pre>"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.from_url","title":"<code>from_url(url)</code>  <code>classmethod</code>","text":"<p>Creates an Artist object from a URL.</p>"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.from_url--arguments","title":"Arguments","text":"<ul> <li>url: The URL of the artist.</li> </ul>"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.from_url--returns","title":"Returns","text":"<ul> <li>The Artist object.</li> </ul> Source code in <code>spotdl/types/artist.py</code> <pre><code>@classmethod\ndef from_url(cls, url: str) -&gt; \"Artist\":\n\"\"\"\n    Creates an Artist object from a URL.\n\n    ### Arguments\n    - url: The URL of the artist.\n\n    ### Returns\n    - The Artist object.\n    \"\"\"\n\n    if \"open.spotify.com\" not in url or \"artist\" not in url:\n        raise ArtistError(f\"Invalid URL: {url}\")\n\n    metadata = Artist.get_metadata(url)\n    album_urls = cls.get_albums(url)\n\n    tracks: List[Song] = []\n    albums: List[Album] = []\n\n    # get artist tracks\n    # same as above, but for tracks\n    known_tracks: Set[str] = set()\n    if len(album_urls) &lt; 1:\n        raise ArtistError(\n            \"Couldn't get albums, check if you have passed correct artist id\"\n        )\n\n    # get all tracks from all albums\n    # ignore duplicates\n    urls = []\n    for album_url in album_urls:\n        album = Album.from_url(album_url)\n        albums.append(album)\n        for track in album.songs:\n            track_name = slugify(track.name)  # type: ignore\n            if track_name not in known_tracks:\n                tracks.append(track)\n                urls.append(track.url)\n                known_tracks.add(track_name)\n\n    return cls(\n        **metadata,\n        songs=tracks,\n        albums=albums,\n        urls=urls,\n    )\n</code></pre>"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.get_albums","title":"<code>get_albums(url)</code>  <code>staticmethod</code>","text":"<p>Returns a list with album urls.</p>"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.get_albums--arguments","title":"Arguments","text":"<ul> <li>url: The URL of the artist.</li> </ul>"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.get_albums--returns","title":"Returns","text":"<ul> <li>List of album urls.</li> </ul> Source code in <code>spotdl/types/artist.py</code> <pre><code>@staticmethod\ndef get_albums(url: str) -&gt; List[str]:\n\"\"\"\n    Returns a list with album urls.\n\n    ### Arguments\n    - url: The URL of the artist.\n\n    ### Returns\n    - List of album urls.\n    \"\"\"\n\n    # query spotify for artist details\n    spotify_client = SpotifyClient()\n\n    artist_albums = spotify_client.artist_albums(url, album_type=\"album,single\")\n\n    # check if there is response\n    if not artist_albums:\n        raise ArtistError(\n            \"Couldn't get albums, check if you have passed correct artist id\"\n        )\n\n    # get artist albums and remove duplicates\n    # duplicates can occur if the artist has the same album available in\n    # different countries\n    albums: Set[str] = set()\n    known_albums: Set[str] = set()\n    for album in artist_albums[\"items\"]:\n        albums.add(album[\"external_urls\"][\"spotify\"])\n        known_albums.add(slugify(album[\"name\"]))\n\n    # Fetch all artist albums\n    while artist_albums and artist_albums[\"next\"]:\n        artist_albums = spotify_client.next(artist_albums)\n        if artist_albums is None:\n            break\n\n        for album in artist_albums[\"items\"]:\n            album_name = slugify(album[\"name\"])\n\n            if album_name not in known_albums:\n                albums.add(album[\"external_urls\"][\"spotify\"])\n\n                known_albums.add(album_name)\n\n    return list(albums)\n</code></pre>"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.get_metadata","title":"<code>get_metadata(url)</code>  <code>staticmethod</code>","text":"<p>Get metadata for artist.</p>"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.get_metadata--arguments","title":"Arguments","text":"<ul> <li>url: The URL of the artist.</li> </ul>"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.get_metadata--returns","title":"Returns","text":"<ul> <li>Dict with metadata for artist.</li> </ul> Source code in <code>spotdl/types/artist.py</code> <pre><code>@staticmethod\ndef get_metadata(url: str) -&gt; Dict[str, Any]:\n\"\"\"\n    Get metadata for artist.\n\n    ### Arguments\n    - url: The URL of the artist.\n\n    ### Returns\n    - Dict with metadata for artist.\n    \"\"\"\n\n    # query spotify for artist details\n    spotify_client = SpotifyClient()\n\n    # get artist info\n    raw_artist_meta = spotify_client.artist(url)\n\n    if raw_artist_meta is None:\n        raise ArtistError(\n            \"Couldn't get metadata, check if you have passed correct artist id\"\n        )\n\n    return {\n        \"name\": raw_artist_meta[\"name\"],\n        \"genres\": raw_artist_meta[\"genres\"],\n        \"url\": url,\n    }\n</code></pre>"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.get_urls","title":"<code>get_urls(url)</code>  <code>staticmethod</code>","text":"<p>Get urls for all songs for artist.</p>"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.get_urls--arguments","title":"Arguments","text":"<ul> <li>url: The URL of the artist.</li> </ul>"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.get_urls--returns","title":"Returns","text":"<ul> <li>List of urls for all songs for artist.</li> </ul> Source code in <code>spotdl/types/artist.py</code> <pre><code>@staticmethod\ndef get_urls(url: str) -&gt; List[str]:\n\"\"\"\n    Get urls for all songs for artist.\n\n    ### Arguments\n    - url: The URL of the artist.\n\n    ### Returns\n    - List of urls for all songs for artist.\n    \"\"\"\n\n    albums = Artist.get_albums(url)\n\n    urls = []\n    for album in albums:\n        urls.extend(Album.get_urls(album))\n\n    return urls\n</code></pre>"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.search","title":"<code>search(search_term)</code>  <code>classmethod</code>","text":"<p>Searches for Artist from a search term.</p>"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.search--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to use.</li> </ul>"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.search--returns","title":"Returns","text":"<ul> <li>The raw search results</li> </ul> Source code in <code>spotdl/types/artist.py</code> <pre><code>@classmethod\ndef search(cls, search_term: str):\n\"\"\"\n    Searches for Artist from a search term.\n\n    ### Arguments\n    - search_term: The search term to use.\n\n    ### Returns\n    - The raw search results\n    \"\"\"\n\n    spotify_client = SpotifyClient()\n    raw_search_results = spotify_client.search(search_term, type=\"artist\")\n\n    if (\n        raw_search_results is None\n        or len(raw_search_results.get(\"artists\", {}).get(\"items\", [])) == 0\n    ):\n        raise ArtistError(\"No artist matches found on spotify\")\n\n    return raw_search_results\n</code></pre>"},{"location":"reference/types/artist/#spotdl.types.artist.ArtistError","title":"<code>ArtistError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Base class for all exceptions related to artists.</p>"},{"location":"reference/types/playlist/","title":"playlist","text":"<p>Playlist module for retrieving playlist data from Spotify.</p>"},{"location":"reference/types/playlist/#spotdl.types.playlist.Playlist","title":"<code>Playlist</code>  <code>dataclass</code>","text":"<p>         Bases: <code>SongList</code></p> <p>Playlist class for retrieving playlist data from Spotify.</p>"},{"location":"reference/types/playlist/#spotdl.types.playlist.Playlist.get_metadata","title":"<code>get_metadata(url)</code>  <code>staticmethod</code>","text":"<p>Get metadata for a playlist.</p>"},{"location":"reference/types/playlist/#spotdl.types.playlist.Playlist.get_metadata--arguments","title":"Arguments","text":"<ul> <li>url: The URL of the playlist.</li> </ul>"},{"location":"reference/types/playlist/#spotdl.types.playlist.Playlist.get_metadata--returns","title":"Returns","text":"<ul> <li>A dictionary with metadata.</li> </ul> Source code in <code>spotdl/types/playlist.py</code> <pre><code>@staticmethod\ndef get_metadata(url: str) -&gt; Dict[str, Any]:\n\"\"\"\n    Get metadata for a playlist.\n\n    ### Arguments\n    - url: The URL of the playlist.\n\n    ### Returns\n    - A dictionary with metadata.\n    \"\"\"\n\n    spotify_client = SpotifyClient()\n\n    playlist = spotify_client.playlist(url)\n    if playlist is None:\n        raise PlaylistError(\"Invalid playlist URL.\")\n\n    return {\n        \"name\": playlist[\"name\"],\n        \"url\": url,\n        \"description\": playlist[\"description\"],\n        \"author_url\": playlist[\"external_urls\"][\"spotify\"],\n        \"author_name\": playlist[\"owner\"][\"display_name\"],\n        \"cover_url\": (\n            max(\n                playlist[\"images\"],\n                key=lambda i: 0\n                if i[\"width\"] is None or i[\"height\"] is None\n                else i[\"width\"] * i[\"height\"],\n            )[\"url\"]\n            if (len(playlist[\"images\"]) &gt; 0)\n            else \"\"\n        ),\n    }\n</code></pre>"},{"location":"reference/types/playlist/#spotdl.types.playlist.Playlist.get_urls","title":"<code>get_urls(url)</code>  <code>staticmethod</code>","text":"<p>Get URLs of all tracks in a playlist.</p>"},{"location":"reference/types/playlist/#spotdl.types.playlist.Playlist.get_urls--arguments","title":"Arguments","text":"<ul> <li>url: The URL of the playlist.</li> </ul>"},{"location":"reference/types/playlist/#spotdl.types.playlist.Playlist.get_urls--returns","title":"Returns","text":"<ul> <li>A list of urls.</li> </ul> Source code in <code>spotdl/types/playlist.py</code> <pre><code>@staticmethod\ndef get_urls(url: str) -&gt; List[str]:\n\"\"\"\n    Get URLs of all tracks in a playlist.\n\n    ### Arguments\n    - url: The URL of the playlist.\n\n    ### Returns\n    - A list of urls.\n    \"\"\"\n\n    spotify_client = SpotifyClient()\n    tracks = []\n\n    playlist_response = spotify_client.playlist_items(url)\n    if playlist_response is None:\n        raise PlaylistError(f\"Wrong playlist id: {url}\")\n\n    tracks = playlist_response[\"items\"]\n\n    # Get all tracks from playlist\n    while playlist_response[\"next\"]:\n        playlist_response = spotify_client.next(playlist_response)\n\n        # Failed to get response, break the loop\n        if playlist_response is None:\n            break\n\n        # Add tracks to the list\n        tracks.extend(playlist_response[\"items\"])\n\n    return [\n        track[\"track\"][\"external_urls\"][\"spotify\"]\n        for track in tracks\n        if track is not None\n        and track.get(\"track\") is not None\n        and track.get(\"track\").get(\"id\")\n    ]\n</code></pre>"},{"location":"reference/types/playlist/#spotdl.types.playlist.Playlist.search","title":"<code>search(search_term)</code>  <code>classmethod</code>","text":"<p>Searches for Playlist from a search term.</p>"},{"location":"reference/types/playlist/#spotdl.types.playlist.Playlist.search--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to use.</li> </ul>"},{"location":"reference/types/playlist/#spotdl.types.playlist.Playlist.search--returns","title":"Returns","text":"<ul> <li>The raw search results</li> </ul> Source code in <code>spotdl/types/playlist.py</code> <pre><code>@classmethod\ndef search(cls, search_term: str):\n\"\"\"\n    Searches for Playlist from a search term.\n\n    ### Arguments\n    - search_term: The search term to use.\n\n    ### Returns\n    - The raw search results\n    \"\"\"\n\n    spotify_client = SpotifyClient()\n    raw_search_results = spotify_client.search(search_term, type=\"playlist\")\n\n    if (\n        raw_search_results is None\n        or len(raw_search_results.get(\"playlists\", {}).get(\"items\", [])) == 0\n    ):\n        raise PlaylistError(\"No playlist matches found on spotify\")\n\n    return raw_search_results\n</code></pre>"},{"location":"reference/types/playlist/#spotdl.types.playlist.PlaylistError","title":"<code>PlaylistError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Base class for all exceptions related to playlists.</p>"},{"location":"reference/types/saved/","title":"saved","text":"<p>Saved module for handing the saved tracks from user library</p>"},{"location":"reference/types/saved/#spotdl.types.saved.Saved","title":"<code>Saved</code>  <code>dataclass</code>","text":"<p>         Bases: <code>SongList</code></p> <p>Saved class for handling the saved tracks from user library.</p>"},{"location":"reference/types/saved/#spotdl.types.saved.Saved.create_basic_list","title":"<code>create_basic_list(url='saved')</code>  <code>classmethod</code>","text":"<p>Create a basic list with only the required metadata and urls.</p>"},{"location":"reference/types/saved/#spotdl.types.saved.Saved.create_basic_list--returns","title":"Returns","text":"<ul> <li>The Saved object.</li> </ul> Source code in <code>spotdl/types/saved.py</code> <pre><code>@classmethod\ndef create_basic_list(cls, url: str = \"saved\") -&gt; \"Saved\":\n\"\"\"\n    Create a basic list with only the required metadata and urls.\n\n    ### Returns\n    - The Saved object.\n    \"\"\"\n\n    metadata = cls.get_metadata(url)\n    urls = cls.get_urls(url)\n\n    return cls(**metadata, urls=urls, songs=[])\n</code></pre>"},{"location":"reference/types/saved/#spotdl.types.saved.Saved.get_metadata","title":"<code>get_metadata(url='saved')</code>  <code>staticmethod</code>","text":"<p>Returns metadata for a saved list.</p>"},{"location":"reference/types/saved/#spotdl.types.saved.Saved.get_metadata--arguments","title":"Arguments","text":"<ul> <li>url: Not required, but used to match the signature of the other get_metadata methods.</li> </ul> Source code in <code>spotdl/types/saved.py</code> <pre><code>@staticmethod\ndef get_metadata(url: str = \"saved\") -&gt; Dict[str, Any]:\n\"\"\"\n    Returns metadata for a saved list.\n\n    ### Arguments\n    - url: Not required, but used to match the signature of the other get_metadata methods.\n    \"\"\"\n\n    return {\"name\": \"Saved tracks\", \"url\": url}\n</code></pre>"},{"location":"reference/types/saved/#spotdl.types.saved.Saved.get_urls","title":"<code>get_urls(_='saved')</code>  <code>staticmethod</code>","text":"<p>Returns a list of urls of all saved tracks.</p>"},{"location":"reference/types/saved/#spotdl.types.saved.Saved.get_urls--arguments","title":"Arguments","text":"<ul> <li>_: not required, but used to match the signature of the other get_urls methods.</li> </ul>"},{"location":"reference/types/saved/#spotdl.types.saved.Saved.get_urls--returns","title":"Returns","text":"<ul> <li>A list of urls.</li> </ul> Source code in <code>spotdl/types/saved.py</code> <pre><code>@staticmethod\ndef get_urls(_: str = \"saved\") -&gt; List[str]:\n\"\"\"\n    Returns a list of urls of all saved tracks.\n\n    ### Arguments\n    - _: not required, but used to match the signature of the other get_urls methods.\n\n    ### Returns\n    - A list of urls.\n    \"\"\"\n\n    spotify_client = SpotifyClient()\n    if spotify_client.user_auth is False:  # type: ignore\n        raise SavedError(\"You must be logged in to use this function.\")\n\n    saved_tracks_response = spotify_client.current_user_saved_tracks()\n    if saved_tracks_response is None:\n        raise Exception(\"Couldn't get saved tracks\")\n\n    saved_tracks = saved_tracks_response[\"items\"]\n\n    # Fetch all saved tracks\n    while saved_tracks_response and saved_tracks_response[\"next\"]:\n        response = spotify_client.next(saved_tracks_response)\n        # response is wrong, break\n        if response is None:\n            break\n\n        saved_tracks_response = response\n        saved_tracks.extend(saved_tracks_response[\"items\"])\n\n    # Remove songs without id\n    # and return urls\n    return [\n        \"https://open.spotify.com/track/\" + track[\"track\"][\"id\"]\n        for track in saved_tracks\n        if track and track.get(\"track\", {}).get(\"id\")\n    ]\n</code></pre>"},{"location":"reference/types/saved/#spotdl.types.saved.Saved.search","title":"<code>search(_)</code>  <code>classmethod</code>","text":"<p>Search for a saved list.</p>"},{"location":"reference/types/saved/#spotdl.types.saved.Saved.search--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term.</li> </ul>"},{"location":"reference/types/saved/#spotdl.types.saved.Saved.search--returns","title":"Returns","text":"<ul> <li>The Saved object.</li> </ul> Source code in <code>spotdl/types/saved.py</code> <pre><code>@classmethod\ndef search(cls, _: str):\n\"\"\"\n    Search for a saved list.\n\n    ### Arguments\n    - search_term: The search term.\n\n    ### Returns\n    - The Saved object.\n    \"\"\"\n\n    return cls.create_basic_list()\n</code></pre>"},{"location":"reference/types/saved/#spotdl.types.saved.SavedError","title":"<code>SavedError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Base class for all exceptions related to saved tracks.</p>"},{"location":"reference/types/song/","title":"song","text":"<p>Song module that hold the Song and SongList classes.</p>"},{"location":"reference/types/song/#spotdl.types.song.Song","title":"<code>Song</code>  <code>dataclass</code>","text":"<p>Song class. Contains all the information about a song.</p>"},{"location":"reference/types/song/#spotdl.types.song.Song.display_name","title":"<code>display_name: str</code>  <code>property</code>","text":"<p>Returns a display name for the song.</p>"},{"location":"reference/types/song/#spotdl.types.song.Song.display_name--returns","title":"Returns","text":"<ul> <li>The display name.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.Song.json","title":"<code>json: Dict[str, Any]</code>  <code>property</code>","text":"<p>Returns a dictionary of the song's data.</p>"},{"location":"reference/types/song/#spotdl.types.song.Song.json--returns","title":"Returns","text":"<ul> <li>The dictionary.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.Song.from_data_dump","title":"<code>from_data_dump(data)</code>  <code>classmethod</code>","text":"<p>Create a Song object from a data dump.</p>"},{"location":"reference/types/song/#spotdl.types.song.Song.from_data_dump--arguments","title":"Arguments","text":"<ul> <li>data: The data dump.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.Song.from_data_dump--returns","title":"Returns","text":"<ul> <li>The Song object.</li> </ul> Source code in <code>spotdl/types/song.py</code> <pre><code>@classmethod\ndef from_data_dump(cls, data: str) -&gt; \"Song\":\n\"\"\"\n    Create a Song object from a data dump.\n\n    ### Arguments\n    - data: The data dump.\n\n    ### Returns\n    - The Song object.\n    \"\"\"\n\n    # Create dict from json string\n    data_dict = json.loads(data)\n\n    # Return product object\n    return cls(**data_dict)\n</code></pre>"},{"location":"reference/types/song/#spotdl.types.song.Song.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a Song object from a dictionary.</p>"},{"location":"reference/types/song/#spotdl.types.song.Song.from_dict--arguments","title":"Arguments","text":"<ul> <li>data: The dictionary.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.Song.from_dict--returns","title":"Returns","text":"<ul> <li>The Song object.</li> </ul> Source code in <code>spotdl/types/song.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict[str, Any]) -&gt; \"Song\":\n\"\"\"\n    Create a Song object from a dictionary.\n\n    ### Arguments\n    - data: The dictionary.\n\n    ### Returns\n    - The Song object.\n    \"\"\"\n\n    # Reinitialize the correct song list object\n    if data.get(\"song_list\"):\n        # Find the correct song list class\n        # based on the class attributes\n        song_list_class = next(\n            (\n                list_class\n                for list_class in SongList.__subclasses__()\n                if list(list_class.__dataclass_fields__.keys())\n                == list(data[\"song_list\"].keys())\n            )\n        )\n\n        # Reinitialize the song list object\n        song_list = song_list_class(**data[\"song_list\"])\n\n        data[\"song_list\"] = song_list\n        data[\"list_position\"] = song_list.urls.index(data[\"url\"])\n\n    # Return product object\n    return cls(**data)\n</code></pre>"},{"location":"reference/types/song/#spotdl.types.song.Song.from_search_term","title":"<code>from_search_term(search_term)</code>  <code>classmethod</code>","text":"<p>Creates a list of Song objects from a search term.</p>"},{"location":"reference/types/song/#spotdl.types.song.Song.from_search_term--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to use.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.Song.from_search_term--returns","title":"Returns","text":"<ul> <li>The Song object.</li> </ul> Source code in <code>spotdl/types/song.py</code> <pre><code>@classmethod\ndef from_search_term(cls, search_term: str) -&gt; \"Song\":\n\"\"\"\n    Creates a list of Song objects from a search term.\n\n    ### Arguments\n    - search_term: The search term to use.\n\n    ### Returns\n    - The Song object.\n    \"\"\"\n\n    raw_search_results = Song.search(search_term)\n\n    return Song.from_url(\n        \"http://open.spotify.com/track/\"\n        + raw_search_results[\"tracks\"][\"items\"][0][\"id\"]\n    )\n</code></pre>"},{"location":"reference/types/song/#spotdl.types.song.Song.from_url","title":"<code>from_url(url)</code>  <code>classmethod</code>","text":"<p>Creates a Song object from a URL.</p>"},{"location":"reference/types/song/#spotdl.types.song.Song.from_url--arguments","title":"Arguments","text":"<ul> <li>url: The URL of the song.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.Song.from_url--returns","title":"Returns","text":"<ul> <li>The Song object.</li> </ul> Source code in <code>spotdl/types/song.py</code> <pre><code>@classmethod\ndef from_url(cls, url: str) -&gt; \"Song\":\n\"\"\"\n    Creates a Song object from a URL.\n\n    ### Arguments\n    - url: The URL of the song.\n\n    ### Returns\n    - The Song object.\n    \"\"\"\n\n    if \"open.spotify.com\" not in url or \"track\" not in url:\n        raise SongError(f\"Invalid URL: {url}\")\n\n    # query spotify for song, artist, album details\n    spotify_client = SpotifyClient()\n\n    # get track info\n    raw_track_meta = spotify_client.track(url)\n\n    if raw_track_meta is None:\n        raise SongError(\n            \"Couldn't get metadata, check if you have passed correct track id\"\n        )\n\n    # get artist info\n    primary_artist_id = raw_track_meta[\"artists\"][0][\"id\"]\n    raw_artist_meta: Dict[str, Any] = spotify_client.artist(primary_artist_id)  # type: ignore\n\n    # get album info\n    album_id = raw_track_meta[\"album\"][\"id\"]\n    raw_album_meta: Dict[str, Any] = spotify_client.album(album_id)  # type: ignore\n\n    # create song object\n    return cls(\n        name=raw_track_meta[\"name\"],\n        artists=[artist[\"name\"] for artist in raw_track_meta[\"artists\"]],\n        artist=raw_track_meta[\"artists\"][0][\"name\"],\n        album_name=raw_album_meta[\"name\"],\n        album_artist=raw_album_meta[\"artists\"][0][\"name\"],\n        copyright_text=raw_album_meta[\"copyrights\"][0][\"text\"]\n        if raw_album_meta[\"copyrights\"]\n        else None,\n        genres=raw_album_meta[\"genres\"] + raw_artist_meta[\"genres\"],\n        disc_number=raw_track_meta[\"disc_number\"],\n        disc_count=int(raw_album_meta[\"tracks\"][\"items\"][-1][\"disc_number\"]),\n        duration=raw_track_meta[\"duration_ms\"] / 1000,\n        year=int(raw_album_meta[\"release_date\"][:4]),\n        date=raw_album_meta[\"release_date\"],\n        track_number=raw_track_meta[\"track_number\"],\n        tracks_count=raw_album_meta[\"total_tracks\"],\n        isrc=raw_track_meta.get(\"external_ids\", {}).get(\"isrc\"),\n        song_id=raw_track_meta[\"id\"],\n        explicit=raw_track_meta[\"explicit\"],\n        publisher=raw_album_meta[\"label\"],\n        url=raw_track_meta[\"external_urls\"][\"spotify\"],\n        cover_url=max(\n            raw_album_meta[\"images\"], key=lambda i: i[\"width\"] * i[\"height\"]\n        )[\"url\"]\n        if raw_album_meta[\"images\"]\n        else None,\n    )\n</code></pre>"},{"location":"reference/types/song/#spotdl.types.song.Song.list_from_search_term","title":"<code>list_from_search_term(search_term)</code>  <code>classmethod</code>","text":"<p>Creates a list of Song objects from a search term.</p>"},{"location":"reference/types/song/#spotdl.types.song.Song.list_from_search_term--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to use.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.Song.list_from_search_term--returns","title":"Returns","text":"<ul> <li>The list of Song objects.</li> </ul> Source code in <code>spotdl/types/song.py</code> <pre><code>@classmethod\ndef list_from_search_term(cls, search_term: str) -&gt; \"List[Song]\":\n\"\"\"\n    Creates a list of Song objects from a search term.\n\n    ### Arguments\n    - search_term: The search term to use.\n\n    ### Returns\n    - The list of Song objects.\n    \"\"\"\n\n    raw_search_results = Song.search(search_term)\n\n    songs = []\n    for idx, _ in enumerate(raw_search_results[\"tracks\"][\"items\"]):\n        songs.append(\n            Song.from_url(\n                \"http://open.spotify.com/track/\"\n                + raw_search_results[\"tracks\"][\"items\"][idx][\"id\"]\n            )\n        )\n\n    return songs\n</code></pre>"},{"location":"reference/types/song/#spotdl.types.song.Song.search","title":"<code>search(search_term)</code>  <code>staticmethod</code>","text":"<p>Searches for Songs from a search term.</p>"},{"location":"reference/types/song/#spotdl.types.song.Song.search--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to use.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.Song.search--returns","title":"Returns","text":"<ul> <li>The raw search results</li> </ul> Source code in <code>spotdl/types/song.py</code> <pre><code>@staticmethod\ndef search(search_term: str):\n\"\"\"\n    Searches for Songs from a search term.\n\n    ### Arguments\n    - search_term: The search term to use.\n\n    ### Returns\n    - The raw search results\n    \"\"\"\n    spotify_client = SpotifyClient()\n    raw_search_results = spotify_client.search(search_term)\n\n    if (\n        raw_search_results is None\n        or len(raw_search_results.get(\"tracks\", {}).get(\"items\", [])) == 0\n    ):\n        raise SongError(f\"No songs matches found on spotify: {search_term}\")\n\n    return raw_search_results\n</code></pre>"},{"location":"reference/types/song/#spotdl.types.song.SongError","title":"<code>SongError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Base class for all exceptions related to songs.</p>"},{"location":"reference/types/song/#spotdl.types.song.SongList","title":"<code>SongList</code>  <code>dataclass</code>","text":"<p>SongList class. Base class for all other song lists subclasses.</p>"},{"location":"reference/types/song/#spotdl.types.song.SongList.length","title":"<code>length: int</code>  <code>property</code>","text":"<p>Get list length (number of songs).</p>"},{"location":"reference/types/song/#spotdl.types.song.SongList.length--returns","title":"Returns","text":"<ul> <li>The list length.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.SongList.create_basic_list","title":"<code>create_basic_list(url)</code>  <code>classmethod</code>","text":"<p>Create a basic list with only the required metadata and urls.</p>"},{"location":"reference/types/song/#spotdl.types.song.SongList.create_basic_list--arguments","title":"Arguments","text":"<ul> <li>url: The url of the list.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.SongList.create_basic_list--returns","title":"Returns","text":"<ul> <li>The SongList object.</li> </ul> Source code in <code>spotdl/types/song.py</code> <pre><code>@classmethod\ndef create_basic_list(cls, url: str):\n\"\"\"\n    Create a basic list with only the required metadata and urls.\n\n    ### Arguments\n    - url: The url of the list.\n\n    ### Returns\n    - The SongList object.\n    \"\"\"\n\n    metadata = cls.get_metadata(url)\n    urls = cls.get_urls(url)\n\n    return cls(**metadata, urls=urls, songs=[])\n</code></pre>"},{"location":"reference/types/song/#spotdl.types.song.SongList.create_basic_object","title":"<code>create_basic_object(url)</code>  <code>classmethod</code>","text":"<p>Create a basic list with only the required metadata.</p>"},{"location":"reference/types/song/#spotdl.types.song.SongList.create_basic_object--arguments","title":"Arguments","text":"<ul> <li>url: The url of the list.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.SongList.create_basic_object--returns","title":"Returns","text":"<ul> <li>The SongList object.</li> </ul> Source code in <code>spotdl/types/song.py</code> <pre><code>@classmethod\ndef create_basic_object(cls, url: str):\n\"\"\"\n    Create a basic list with only the required metadata.\n\n    ### Arguments\n    - url: The url of the list.\n\n    ### Returns\n    - The SongList object.\n    \"\"\"\n    metadata = cls.get_metadata(url)\n\n    return cls(**metadata, urls=[], songs=[])\n</code></pre>"},{"location":"reference/types/song/#spotdl.types.song.SongList.from_search_term","title":"<code>from_search_term(search_term)</code>  <code>classmethod</code>","text":"<p>Creates a SongList object from a search term.</p>"},{"location":"reference/types/song/#spotdl.types.song.SongList.from_search_term--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to use.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.SongList.from_search_term--returns","title":"Returns","text":"<ul> <li>The SongList object.</li> </ul> Source code in <code>spotdl/types/song.py</code> <pre><code>@classmethod\ndef from_search_term(cls, search_term: str):\n\"\"\"\n    Creates a SongList object from a search term.\n\n    ### Arguments\n    - search_term: The search term to use.\n\n    ### Returns\n    - The SongList object.\n    \"\"\"\n\n    list_type = cls.__name__.lower()\n    raw_search_results = cls.search(search_term)\n\n    return cls.create_basic_list(\n        f\"http://open.spotify.com/{list_type}/\"\n        + raw_search_results[f\"{list_type}s\"][\"items\"][0][\"id\"]\n    )\n</code></pre>"},{"location":"reference/types/song/#spotdl.types.song.SongList.from_url","title":"<code>from_url(url)</code>  <code>classmethod</code>","text":"<p>Parse an album from a Spotify URL.</p>"},{"location":"reference/types/song/#spotdl.types.song.SongList.from_url--arguments","title":"Arguments","text":"<ul> <li>url: The URL of the album.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.SongList.from_url--returns","title":"Returns","text":"<ul> <li>The Album object.</li> </ul> Source code in <code>spotdl/types/song.py</code> <pre><code>@classmethod\ndef from_url(cls, url: str):\n\"\"\"\n    Parse an album from a Spotify URL.\n\n    ### Arguments\n    - url: The URL of the album.\n\n    ### Returns\n    - The Album object.\n    \"\"\"\n\n    metadata = cls.get_metadata(url)\n\n    urls = cls.get_urls(url)\n\n    # Remove songs without id (country restricted/local tracks)\n    # And create song object for each track\n    songs: List[Song] = [Song.from_url(url) for url in urls]\n\n    return cls(\n        **metadata,\n        songs=songs,\n        urls=urls,\n    )\n</code></pre>"},{"location":"reference/types/song/#spotdl.types.song.SongList.get_metadata","title":"<code>get_metadata(url)</code>  <code>staticmethod</code>","text":"<p>Get metadata for list.</p>"},{"location":"reference/types/song/#spotdl.types.song.SongList.get_metadata--arguments","title":"Arguments","text":"<ul> <li>url: The URL of the list.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.SongList.get_metadata--returns","title":"Returns","text":"<ul> <li>The metadata.</li> </ul> Source code in <code>spotdl/types/song.py</code> <pre><code>@staticmethod\ndef get_metadata(url: str) -&gt; Dict[str, Any]:\n\"\"\"\n    Get metadata for list.\n\n    ### Arguments\n    - url: The URL of the list.\n\n    ### Returns\n    - The metadata.\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/types/song/#spotdl.types.song.SongList.get_urls","title":"<code>get_urls(url)</code>  <code>staticmethod</code>","text":"<p>Get urls for all songs in url.</p>"},{"location":"reference/types/song/#spotdl.types.song.SongList.get_urls--arguments","title":"Arguments","text":"<ul> <li>url: The URL of the list.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.SongList.get_urls--returns","title":"Returns","text":"<ul> <li>The list of urls.</li> </ul> Source code in <code>spotdl/types/song.py</code> <pre><code>@staticmethod\ndef get_urls(url: str) -&gt; List[str]:\n\"\"\"\n    Get urls for all songs in url.\n\n    ### Arguments\n    - url: The URL of the list.\n\n    ### Returns\n    - The list of urls.\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/types/song/#spotdl.types.song.SongList.list_from_search_term","title":"<code>list_from_search_term(search_term)</code>  <code>classmethod</code>","text":"<p>Creates a list of SongList objects from a search term.</p>"},{"location":"reference/types/song/#spotdl.types.song.SongList.list_from_search_term--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to use.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.SongList.list_from_search_term--returns","title":"Returns","text":"<ul> <li>The list of SongList objects.</li> </ul> Source code in <code>spotdl/types/song.py</code> <pre><code>@classmethod\ndef list_from_search_term(cls, search_term: str):\n\"\"\"\n    Creates a list of SongList objects from a search term.\n\n    ### Arguments\n    - search_term: The search term to use.\n\n    ### Returns\n    - The list of SongList objects.\n    \"\"\"\n\n    list_type = cls.__name__.lower()\n    raw_search_results = cls.search(search_term)\n\n    songlist = []\n    for idx, _ in enumerate(raw_search_results[f\"{list_type}s\"][\"items\"]):\n        songlist.append(\n            cls.create_basic_object(\n                f\"http://open.spotify.com/{list_type}/\"\n                + raw_search_results[f\"{list_type}s\"][\"items\"][idx][\"id\"]\n            )\n        )\n\n    return songlist\n</code></pre>"},{"location":"reference/types/song/#spotdl.types.song.SongList.search","title":"<code>search(search_term)</code>  <code>classmethod</code>","text":"<p>Searches for SongList from a search term.</p>"},{"location":"reference/types/song/#spotdl.types.song.SongList.search--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to use.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.SongList.search--returns","title":"Returns","text":"<ul> <li>The raw search results</li> </ul> Source code in <code>spotdl/types/song.py</code> <pre><code>@classmethod\ndef search(cls, search_term: str):\n\"\"\"\n    Searches for SongList from a search term.\n\n    ### Arguments\n    - search_term: The search term to use.\n\n    ### Returns\n    - The raw search results\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/utils/","title":"utils","text":"<p>Utility functions for spotdl. These functions are used in every stage of the download process.</p>"},{"location":"reference/utils/archive/","title":"archive","text":"<p>Module for archiving sets of data</p>"},{"location":"reference/utils/archive/#spotdl.utils.archive.Archive","title":"<code>Archive</code>","text":"<p>         Bases: <code>Set</code></p> <p>Archive class. A file-persistable set.</p>"},{"location":"reference/utils/archive/#spotdl.utils.archive.Archive.load","title":"<code>load(file)</code>","text":"<p>Imports the archive from the file.</p>"},{"location":"reference/utils/archive/#spotdl.utils.archive.Archive.load--arguments","title":"Arguments","text":"<ul> <li>file: the file name of the archive</li> </ul>"},{"location":"reference/utils/archive/#spotdl.utils.archive.Archive.load--returns","title":"Returns","text":"<ul> <li>if the file exists</li> </ul> Source code in <code>spotdl/utils/archive.py</code> <pre><code>def load(self, file: str) -&gt; bool:\n\"\"\"\n    Imports the archive from the file.\n\n    ### Arguments\n    - file: the file name of the archive\n\n    ### Returns\n    - if the file exists\n    \"\"\"\n\n    if not exists(file):\n        return False\n\n    with open(file, \"r\", encoding=\"utf-8\") as archive:\n        self.clear()\n        self.update([line.strip() for line in archive])\n\n    return True\n</code></pre>"},{"location":"reference/utils/archive/#spotdl.utils.archive.Archive.save","title":"<code>save(file)</code>","text":"<p>Exports the current archive to the file.</p>"},{"location":"reference/utils/archive/#spotdl.utils.archive.Archive.save--arguments","title":"Arguments","text":"<ul> <li>file: the file name of the archive</li> </ul> Source code in <code>spotdl/utils/archive.py</code> <pre><code>def save(self, file: str) -&gt; bool:\n\"\"\"\n    Exports the current archive to the file.\n\n    ### Arguments\n    - file: the file name of the archive\n    \"\"\"\n\n    with open(file, \"w\", encoding=\"utf-8\") as archive:\n        for element in sorted(self):\n            archive.write(f\"{element}\\n\")\n\n    return True\n</code></pre>"},{"location":"reference/utils/arguments/","title":"arguments","text":"<p>Module that handles the command line arguments.</p>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.SmartFormatter","title":"<code>SmartFormatter</code>","text":"<p>         Bases: <code>argparse.HelpFormatter</code></p> <p>Class that overrides the default help formatter.</p>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_arguments","title":"<code>parse_arguments()</code>","text":"<p>Parse arguments from the command line.</p>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_arguments--returns","title":"Returns","text":"<ul> <li>A Namespace object containing the parsed arguments.</li> </ul> Source code in <code>spotdl/utils/arguments.py</code> <pre><code>def parse_arguments() -&gt; Namespace:\n\"\"\"\n    Parse arguments from the command line.\n\n    ### Returns\n    - A Namespace object containing the parsed arguments.\n    \"\"\"\n\n    # Initialize argument parser\n    parser = ArgumentParser(\n        prog=\"spotdl\",\n        description=\"Download your Spotify playlists and songs along with album art and metadata\",\n        formatter_class=SmartFormatter,\n        epilog=(\n            \"For more information, visit http://spotdl.rtfd.io/ \"\n            \"or join our Discord server: https://discord.com/invite/xCa23pwJWY\"\n        ),\n    )\n\n    # Parse main options\n    main_options = parser.add_argument_group(\"Main options\")\n    parse_main_options(main_options)\n\n    # Parse spotify options\n    spotify_options = parser.add_argument_group(\"Spotify options\")\n    parse_spotify_options(spotify_options)\n\n    # Parse ffmpeg options\n    ffmpeg_options = parser.add_argument_group(\"FFmpeg options\")\n    parse_ffmpeg_options(ffmpeg_options)\n\n    # Parse output options\n    output_options = parser.add_argument_group(\"Output options\")\n    parse_output_options(output_options)\n\n    # Parse web options\n    web_options = parser.add_argument_group(\"Web options\")\n    parse_web_options(web_options)\n\n    # Parse misc options\n    misc_options = parser.add_argument_group(\"Misc options\")\n    parse_misc_options(misc_options)\n\n    # Parse other options\n    other_options = parser.add_argument_group(\"Other options\")\n    parse_other_options(other_options)\n\n    return parser.parse_args()\n</code></pre>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_ffmpeg_options","title":"<code>parse_ffmpeg_options(parser)</code>","text":"<p>Parse ffmpeg options from the command line.</p>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_ffmpeg_options--arguments","title":"Arguments","text":"<ul> <li>parser: The argument parser to add the options to.</li> </ul> Source code in <code>spotdl/utils/arguments.py</code> <pre><code>def parse_ffmpeg_options(parser: _ArgumentGroup):\n\"\"\"\n    Parse ffmpeg options from the command line.\n\n    ### Arguments\n    - parser: The argument parser to add the options to.\n    \"\"\"\n\n    # Add ffmpeg executable argument\n    parser.add_argument(\n        \"--ffmpeg\",\n        help=\"The ffmpeg executable to use.\",\n    )\n\n    # Add search threads argument\n    parser.add_argument(\n        \"--threads\",\n        type=int,\n        help=\"The number of threads to use when downloading songs.\",\n    )\n    # Add constant bit rate argument\n    parser.add_argument(\n        \"--bitrate\",\n        choices=[\n            \"8k\",\n            \"16k\",\n            \"24k\",\n            \"32k\",\n            \"40k\",\n            \"48k\",\n            \"64k\",\n            \"80k\",\n            \"96k\",\n            \"112k\",\n            \"128k\",\n            \"160k\",\n            \"192k\",\n            \"224k\",\n            \"256k\",\n            \"320k\",\n        ]\n        + list(map(str, range(0, 10))),\n        type=str.lower,\n        help=(\n            \"The constant/variable bitrate to use for the output file. \"\n            \"Values from 0 to 9 are variable bitrates. \"\n        ),\n    )\n\n    # Additional ffmpeg arguments\n    parser.add_argument(\n        \"--ffmpeg-args\",\n        type=str,\n        help=\"Additional ffmpeg arguments passed as a string.\",\n    )\n\n    # Preserve original audio stream\n    parser.add_argument(\n        \"--preserve-original-audio\",\n        action=\"store_const\",\n        const=True,\n        help=(\n            \"Preserve the original audio stream in case of m4a and opus files. \"\n            \"This option might overwrite the bitrate option. \"\n            \"Adding additional ffmpeg arguments might make this option useless.\"\n        ),\n    )\n</code></pre>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_main_options","title":"<code>parse_main_options(parser)</code>","text":"<p>Parse main options from the command line.</p>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_main_options--arguments","title":"Arguments","text":"<ul> <li>parser: The argument parser to add the options to.</li> </ul> Source code in <code>spotdl/utils/arguments.py</code> <pre><code>def parse_main_options(parser: _ArgumentGroup):\n\"\"\"\n    Parse main options from the command line.\n\n    ### Arguments\n    - parser: The argument parser to add the options to.\n    \"\"\"\n\n    # Add operation argument\n    operation = parser.add_argument(\n        \"operation\",\n        choices=OPERATIONS,\n        default=\"download\",\n        const=\"download\",\n        nargs=\"?\",\n        help=(\n            \"N|The operation to perform.\\n\"\n            \"download: Download the songs to the disk and embed metadata.\\n\"\n            \"save: Saves the songs metadata to a file for further use.\\n\"\n            \"web: Starts a web interface to simplify the download process.\\n\"\n            \"sync: Removes songs that are no longer present, downloads new ones\\n\"\n            \"meta: Update your audio files with metadata\\n\"\n        ),\n    )\n\n    # Add query argument\n    query = parser.add_argument(\n        \"query\",\n        nargs=\"+\",\n        type=str,\n        help=(\n            \"Spotify URL for a song/playlist/album/artist/etc. to download. \"\n            \"For album searching, include 'album:' and optional 'artist:' tags \"\n            \"(ie. 'album:the album name' or 'artist:the artist album: the album'). \"\n            \"For manual audio matching, you can use the format 'YouTubeURL|SpotifyURL'\"\n        ),\n    )\n\n    try:\n        is_web = sys.argv[1] == \"web\"\n    except IndexError:\n        is_web = False\n\n    is_frozen = getattr(sys, \"frozen\", False)\n\n    # If the program is frozen, we and user didn't pass any arguments,\n    # or if the user is using the web interface, we don't need to parse\n    # the query\n    if (is_frozen and len(sys.argv) &lt; 2) or (len(sys.argv) &gt; 1 and is_web):\n        # If we are running the web interface\n        # or we are in the frozen env and not running web interface\n        # don't remove the operation from the arg parser\n        if not is_web or (is_frozen and not is_web):\n            parser._remove_action(operation)  # pylint: disable=protected-access\n\n        parser._remove_action(query)  # pylint: disable=protected-access\n\n    # Audio provider argument\n    parser.add_argument(\n        \"--audio\",\n        dest=\"audio_providers\",\n        nargs=\"*\",\n        choices=AUDIO_PROVIDERS,\n        help=\"The audio provider to use. You can provide more than one for fallback.\",\n    )\n\n    # Lyrics provider argument\n    parser.add_argument(\n        \"--lyrics\",\n        dest=\"lyrics_providers\",\n        nargs=\"*\",\n        choices=LYRICS_PROVIDERS.keys(),\n        help=\"The lyrics provider to use. You can provide more than one for fallback.\",\n    )\n\n    # Add config argument\n    parser.add_argument(\n        \"--config\",\n        action=\"store_true\",\n        help=(\n            \"Use the config file to download songs. \"\n            \"It's located under C:\\\\Users\\\\user\\\\.spotdl\\\\config.json \"\n            \"or ~/.spotdl/config.json under linux\"\n        ),\n    )\n\n    # Add search query argument\n    parser.add_argument(\n        \"--search-query\",\n        help=f\"The search query to use, available variables: {', '.join(VARS)}\",\n    )\n\n    # Add don't filter results argument\n    parser.add_argument(\n        \"--dont-filter-results\",\n        dest=\"filter_results\",\n        action=\"store_const\",\n        const=False,\n        help=\"Disable filtering results.\",\n    )\n</code></pre>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_misc_options","title":"<code>parse_misc_options(parser)</code>","text":"<p>Parse misc options from the command line.</p>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_misc_options--arguments","title":"Arguments","text":"<ul> <li>parser: The argument parser to add the options to.</li> </ul> Source code in <code>spotdl/utils/arguments.py</code> <pre><code>def parse_misc_options(parser: _ArgumentGroup):\n\"\"\"\n    Parse misc options from the command line.\n\n    ### Arguments\n    - parser: The argument parser to add the options to.\n    \"\"\"\n\n    # Add verbose argument\n    parser.add_argument(\n        \"--log-level\",\n        choices=NAME_TO_LEVEL.keys(),\n        help=\"Select log level.\",\n    )\n\n    # Add simple tui argument\n    parser.add_argument(\n        \"--simple-tui\",\n        action=\"store_const\",\n        const=True,\n        help=\"Use a simple tui.\",\n    )\n\n    # Add headless argument\n    parser.add_argument(\n        \"--headless\",\n        action=\"store_const\",\n        const=True,\n        help=\"Run in headless mode.\",\n    )\n</code></pre>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_other_options","title":"<code>parse_other_options(parser)</code>","text":"<p>Parse other options from the command line.</p>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_other_options--arguments","title":"Arguments","text":"<ul> <li>parser: The argument parser to add the options to.</li> </ul> Source code in <code>spotdl/utils/arguments.py</code> <pre><code>def parse_other_options(parser: _ArgumentGroup):\n\"\"\"\n    Parse other options from the command line.\n\n    ### Arguments\n    - parser: The argument parser to add the options to.\n    \"\"\"\n\n    parser.add_argument(\n        \"--download-ffmpeg\",\n        action=\"store_true\",\n        help=\"Download ffmpeg to spotdl directory.\",\n    )\n\n    parser.add_argument(\n        \"--generate-config\",\n        action=\"store_true\",\n        help=\"Generate a config file. This will overwrite current config if present.\",\n    )\n\n    parser.add_argument(\n        \"--check-for-updates\", action=\"store_true\", help=\"Check for new version.\"\n    )\n\n    parser.add_argument(\n        \"--profile\",\n        action=\"store_true\",\n        help=\"Run in profile mode. Useful for debugging.\",\n    )\n\n    parser.add_argument(\n        \"--version\",\n        \"-v\",\n        action=\"version\",\n        help=\"Show the version number and exit.\",\n        version=_version.__version__,\n    )\n</code></pre>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_output_options","title":"<code>parse_output_options(parser)</code>","text":"<p>Parse output options from the command line.</p>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_output_options--arguments","title":"Arguments","text":"<ul> <li>parser: The argument parser to add the options to.</li> </ul> Source code in <code>spotdl/utils/arguments.py</code> <pre><code>def parse_output_options(parser: _ArgumentGroup):\n\"\"\"\n    Parse output options from the command line.\n\n    ### Arguments\n    - parser: The argument parser to add the options to.\n    \"\"\"\n\n    # Add output format argument\n    parser.add_argument(\n        \"--format\",\n        choices=FFMPEG_FORMATS.keys(),\n        help=\"The format to download the song in.\",\n    )\n\n    # Add save file argument\n    parser.add_argument(\n        \"--save-file\",\n        type=str,\n        help=(\n            \"The file to save/load the songs data from/to. \"\n            \"It has to end with .spotdl. \"\n            \"If combined with the download operation, it will save the songs data to the file. \"\n            \"Required for save/preload/sync\"\n        ),\n        required=len(sys.argv) &gt; 1 and sys.argv[1] in [\"save\"],\n    )\n\n    # Add preload argument\n    parser.add_argument(\n        \"--preload\",\n        action=\"store_const\",\n        const=True,\n        help=\"Preload the download url to speed up the download process.\",\n    )\n\n    # Add name format argument\n    parser.add_argument(\n        \"--output\",\n        type=str,\n        help=f\"Specify the downloaded file name format, available variables: {', '.join(VARS)}\",\n    )\n\n    # Add m3u argument\n    parser.add_argument(\n        \"--m3u\",\n        type=str,\n        nargs=\"?\",\n        help=(\n            \"Name of the m3u file to save the songs to. \"\n            \"Defaults to {list[0]}.m3u \"\n            \"If you want to generate a m3u for each list in the query use {list-name}, \"\n            \"If you want to generate a m3u file based on the first list in the query use {list[0]}\"\n            \", (0 is the first list in the query, 1 is the second, etc. \"\n            \"songs don't count towards the list number) \"\n        ),\n        const=\"{list[0]}.m3u\",\n    )\n\n    # Add overwrite argument\n    parser.add_argument(\n        \"--overwrite\",\n        choices={\"force\", \"skip\", \"metadata\"},\n        help=\"Overwrite existing files.\",\n    )\n\n    # Option to restrict filenames for easier handling in the shell\n    parser.add_argument(\n        \"--restrict\",\n        action=\"store_const\",\n        const=True,\n        help=\"Restrict filenames to ASCII only\",\n    )\n\n    # Option to print errors on exit, useful for long playlist\n    parser.add_argument(\n        \"--print-errors\",\n        action=\"store_const\",\n        const=True,\n        help=\"Print errors (wrong songs, failed downloads etc) on exit, useful for long playlist\",\n    )\n\n    # Option to use sponsor block\n    parser.add_argument(\n        \"--sponsor-block\",\n        action=\"store_const\",\n        const=True,\n        help=\"Use the sponsor block to download songs from yt/ytm.\",\n    )\n\n    # Add archive_file argument\n    parser.add_argument(\n        \"--archive\",\n        type=str,\n        help=\"Specify the file name for an archive of already downloaded songs\",\n    )\n\n    # Option to set the track number &amp; album of tracks in a playlist to their index in the playlist\n    # &amp; the name of playlist respectively.\n    parser.add_argument(\n        \"--playlist-numbering\",\n        action=\"store_const\",\n        dest=\"playlist_numbering\",\n        const=True,\n        help=\"Sets each track in a playlist to have the playlist's name as its album,\\\n            and album art as the playlist's icon\",\n    )\n</code></pre>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_spotify_options","title":"<code>parse_spotify_options(parser)</code>","text":"<p>Parse spotify options from the command line.</p>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_spotify_options--arguments","title":"Arguments","text":"<ul> <li>parser: The argument parser to add the options to.</li> </ul> Source code in <code>spotdl/utils/arguments.py</code> <pre><code>def parse_spotify_options(parser: _ArgumentGroup):\n\"\"\"\n    Parse spotify options from the command line.\n\n    ### Arguments\n    - parser: The argument parser to add the options to.\n    \"\"\"\n\n    # Add login argument\n    parser.add_argument(\n        \"--user-auth\",\n        action=\"store_const\",\n        const=True,\n        help=\"Login to Spotify using OAuth.\",\n    )\n\n    # Add client id argument\n    parser.add_argument(\n        \"--client-id\",\n        help=\"The client id to use when logging in to Spotify.\",\n    )\n\n    # Add client secret argument\n    parser.add_argument(\n        \"--client-secret\",\n        help=\"The client secret to use when logging in to Spotify.\",\n    )\n\n    # Add auth token argument\n    parser.add_argument(\n        \"--auth-token\",\n        help=\"The authorisation token to use directly to log in to Spotify.\",\n    )\n\n    # Add cache path argument\n    parser.add_argument(\n        \"--cache-path\",\n        type=str,\n        help=\"The path where spotipy cache file will be stored.\",\n    )\n\n    # Add no cache argument\n    parser.add_argument(\n        \"--no-cache\",\n        action=\"store_const\",\n        const=True,\n        help=\"Disable caching (both requests and token).\",\n    )\n\n    # Add cookie file argument\n    parser.add_argument(\n        \"--cookie-file\",\n        help=\"Path to cookies file.\",\n    )\n</code></pre>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_web_options","title":"<code>parse_web_options(parser)</code>","text":"<p>Parse web options from the command line.</p>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_web_options--arguments","title":"Arguments","text":"<ul> <li>parser: The argument parser to add the options to.</li> </ul> Source code in <code>spotdl/utils/arguments.py</code> <pre><code>def parse_web_options(parser: _ArgumentGroup):\n\"\"\"\n    Parse web options from the command line.\n\n    ### Arguments\n    - parser: The argument parser to add the options to.\n    \"\"\"\n\n    # Add host argument\n    parser.add_argument(\n        \"--host\",\n        type=str,\n        help=\"The host to use for the web server.\",\n    )\n\n    # Add port argument\n    parser.add_argument(\n        \"--port\",\n        type=int,\n        help=\"The port to run the web server on.\",\n    )\n\n    # Add keep alive argument\n    parser.add_argument(\n        \"--keep-alive\",\n        action=\"store_const\",\n        const=True,\n        help=\"Keep the web server alive even when no clients are connected.\",\n    )\n\n    # Add allowed origins argument\n    parser.add_argument(\n        \"--allowed-origins\",\n        nargs=\"*\",\n        help=\"The allowed origins for the web server.\",\n    )\n</code></pre>"},{"location":"reference/utils/config/","title":"config","text":"<p>Module related to managing reading and writing to the config file.</p> <p>Default config - spotdl.utils.config.DEFAULT_CONFIG</p>"},{"location":"reference/utils/config/#spotdl.utils.config.ConfigError","title":"<code>ConfigError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Base class for all exceptions related to config.</p>"},{"location":"reference/utils/config/#spotdl.utils.config.get_cache_path","title":"<code>get_cache_path()</code>","text":"<p>Get the path to the cache folder.</p>"},{"location":"reference/utils/config/#spotdl.utils.config.get_cache_path--returns","title":"Returns","text":"<ul> <li>The path to the spotipy cache file.</li> </ul> Source code in <code>spotdl/utils/config.py</code> <pre><code>def get_cache_path() -&gt; Path:\n\"\"\"\n    Get the path to the cache folder.\n\n    ### Returns\n    - The path to the spotipy cache file.\n    \"\"\"\n\n    return get_spotdl_path() / \".spotipy\"\n</code></pre>"},{"location":"reference/utils/config/#spotdl.utils.config.get_config","title":"<code>get_config()</code>","text":"<p>Get the config.</p>"},{"location":"reference/utils/config/#spotdl.utils.config.get_config--returns","title":"Returns","text":"<ul> <li>The dictionary with the config.</li> </ul>"},{"location":"reference/utils/config/#spotdl.utils.config.get_config--errors","title":"Errors","text":"<ul> <li>ConfigError: If the config file does not exist.</li> </ul> Source code in <code>spotdl/utils/config.py</code> <pre><code>def get_config() -&gt; Dict[str, Any]:\n\"\"\"\n    Get the config.\n\n    ### Returns\n    - The dictionary with the config.\n\n    ### Errors\n    - ConfigError: If the config file does not exist.\n    \"\"\"\n\n    config_path = get_config_file()\n\n    if not config_path.exists():\n        raise ConfigError(\n            \"Config file not found.\"\n            \"Please run `spotdl --generate-config` to create a config file.\"\n        )\n\n    with open(config_path, \"r\", encoding=\"utf-8\") as config_file:\n        return json.load(config_file)\n</code></pre>"},{"location":"reference/utils/config/#spotdl.utils.config.get_config_file","title":"<code>get_config_file()</code>","text":"<p>Get config file path</p>"},{"location":"reference/utils/config/#spotdl.utils.config.get_config_file--returns","title":"Returns","text":"<ul> <li>The path to the config file.</li> </ul> Source code in <code>spotdl/utils/config.py</code> <pre><code>def get_config_file() -&gt; Path:\n\"\"\"\n    Get config file path\n\n    ### Returns\n    - The path to the config file.\n    \"\"\"\n\n    return get_spotdl_path() / \"config.json\"\n</code></pre>"},{"location":"reference/utils/config/#spotdl.utils.config.get_errors_path","title":"<code>get_errors_path()</code>","text":"<p>Get the path to the errors folder.</p>"},{"location":"reference/utils/config/#spotdl.utils.config.get_errors_path--returns","title":"Returns","text":"<ul> <li>The path to the errors folder.</li> </ul>"},{"location":"reference/utils/config/#spotdl.utils.config.get_errors_path--notes","title":"Notes","text":"<ul> <li>If the errors directory does not exist, it will be created.</li> </ul> Source code in <code>spotdl/utils/config.py</code> <pre><code>def get_errors_path() -&gt; Path:\n\"\"\"\n    Get the path to the errors folder.\n\n    ### Returns\n    - The path to the errors folder.\n\n    ### Notes\n    - If the errors directory does not exist, it will be created.\n    \"\"\"\n\n    errors_path = get_spotdl_path() / \"errors\"\n\n    if not errors_path.exists():\n        os.mkdir(errors_path)\n\n    return errors_path\n</code></pre>"},{"location":"reference/utils/config/#spotdl.utils.config.get_spotdl_path","title":"<code>get_spotdl_path()</code>","text":"<p>Get the path to the spotdl folder.</p>"},{"location":"reference/utils/config/#spotdl.utils.config.get_spotdl_path--returns","title":"Returns","text":"<ul> <li>The path to the spotdl folder.</li> </ul>"},{"location":"reference/utils/config/#spotdl.utils.config.get_spotdl_path--notes","title":"Notes","text":"<ul> <li>If the spotdl directory does not exist, it will be created.</li> </ul> Source code in <code>spotdl/utils/config.py</code> <pre><code>def get_spotdl_path() -&gt; Path:\n\"\"\"\n    Get the path to the spotdl folder.\n\n    ### Returns\n    - The path to the spotdl folder.\n\n    ### Notes\n    - If the spotdl directory does not exist, it will be created.\n    \"\"\"\n\n    # Check if os is linux\n    if platform.system() == \"Linux\":\n        # if platform is linux, and XDG DATA HOME spotdl folder exists, use it\n        user_data_dir = Path(platformdirs.user_data_dir(\"spotdl\", \"spotDL\"))\n        if user_data_dir.exists():\n            return user_data_dir\n\n    spotdl_path = Path(os.path.expanduser(\"~\"), \".spotdl\")\n    if not spotdl_path.exists():\n        os.mkdir(spotdl_path)\n\n    return spotdl_path\n</code></pre>"},{"location":"reference/utils/config/#spotdl.utils.config.get_temp_path","title":"<code>get_temp_path()</code>","text":"<p>Get the path to the temp folder.</p>"},{"location":"reference/utils/config/#spotdl.utils.config.get_temp_path--returns","title":"Returns","text":"<ul> <li>The path to the temp folder.</li> </ul> Source code in <code>spotdl/utils/config.py</code> <pre><code>def get_temp_path() -&gt; Path:\n\"\"\"\n    Get the path to the temp folder.\n\n    ### Returns\n    - The path to the temp folder.\n    \"\"\"\n\n    temp_path = get_spotdl_path() / \"temp\"\n    if not temp_path.exists():\n        os.mkdir(temp_path)\n\n    return temp_path\n</code></pre>"},{"location":"reference/utils/console/","title":"console","text":"<p>Module for holding console related actions.</p>"},{"location":"reference/utils/console/#spotdl.utils.console.check_for_updates","title":"<code>check_for_updates()</code>","text":"<p>Check for updates to the current version.</p> Source code in <code>spotdl/utils/console.py</code> <pre><code>def check_for_updates():\n\"\"\"\n    Check for updates to the current version.\n    \"\"\"\n\n    version_message = get_update_status()\n\n    print(version_message)\n</code></pre>"},{"location":"reference/utils/console/#spotdl.utils.console.download_ffmpeg","title":"<code>download_ffmpeg()</code>","text":"<p>Handle ffmpeg download process and print the result.</p> Source code in <code>spotdl/utils/console.py</code> <pre><code>def download_ffmpeg():\n\"\"\"\n    Handle ffmpeg download process and print the result.\n    \"\"\"\n\n    if get_local_ffmpeg() is not None or is_ffmpeg_installed():\n        overwrite_ffmpeg = input(\n            \"FFmpeg is already installed. Do you want to overwrite it? (y/N): \"\n        )\n\n        if overwrite_ffmpeg.lower() == \"y\":\n            local_ffmpeg = ffmpeg_download()\n\n            if local_ffmpeg.is_file():\n                print(f\"FFmpeg successfully downloaded to {local_ffmpeg.absolute()}\")\n            else:\n                print(\"FFmpeg download failed\")\n    else:\n        print(\"Downloading FFmpeg...\")\n        download_path = ffmpeg_download()\n\n        if download_path.is_file():\n            print(f\"FFmpeg successfully downloaded to {download_path.absolute()}\")\n        else:\n            print(\"FFmpeg download failed\")\n</code></pre>"},{"location":"reference/utils/console/#spotdl.utils.console.generate_config","title":"<code>generate_config()</code>","text":"<p>Generate the config file if it doesn't exist This is done before the argument parser so it doesn't requires <code>operation</code> and <code>query</code> to be passed.</p> Source code in <code>spotdl/utils/console.py</code> <pre><code>def generate_config():\n\"\"\"\n    Generate the config file if it doesn't exist\n    This is done before the argument parser so it doesn't requires `operation`\n    and `query` to be passed.\n    \"\"\"\n\n    config_path = get_config_file()\n    if config_path.exists():\n        overwrite_config = input(\"Config file already exists. Overwrite? (y/N): \")\n\n        if overwrite_config.lower() != \"y\":\n            print(\"Exiting...\")\n            return None\n\n    with open(config_path, \"w\", encoding=\"utf-8\") as config_file:\n        json.dump(DEFAULT_CONFIG, config_file, indent=4)\n\n    print(f\"Config file generated at {config_path}\")\n\n    return None\n</code></pre>"},{"location":"reference/utils/ffmpeg/","title":"ffmpeg","text":"<p>Module for converting audio files to different formats and checking for ffmpeg binary, and downloading it if not found.</p>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.FFmpegError","title":"<code>FFmpegError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Base class for all exceptions related to FFmpeg.</p>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.convert","title":"<code>convert(input_file, output_file, ffmpeg='ffmpeg', output_format='mp3', bitrate=None, ffmpeg_args=None, progress_handler=None)</code>","text":"<p>Convert the input file to the output file synchronously with progress handler.</p>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.convert--arguments","title":"Arguments","text":"<ul> <li>input_file: Path to input file or tuple of (url, file_format).</li> <li>output_file: Path to output file.</li> <li>ffmpeg: ffmpeg executable to use.</li> <li>output_format: output format.</li> <li>bitrate: constant/variable bitrate.</li> <li>ffmpeg_args: ffmpeg arguments.</li> <li>progress_handler: progress handler, has to accept an integer as argument.</li> </ul>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.convert--returns","title":"Returns","text":"<ul> <li>Tuple of conversion status and error dictionary.</li> </ul>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.convert--notes","title":"Notes","text":"<ul> <li>Make sure to check if ffmpeg is installed before calling this function.</li> </ul> Source code in <code>spotdl/utils/ffmpeg.py</code> <pre><code>def convert(\n    input_file: Union[Path, Tuple[str, str]],\n    output_file: Path,\n    ffmpeg: str = \"ffmpeg\",\n    output_format: str = \"mp3\",\n    bitrate: Optional[str] = None,\n    ffmpeg_args: Optional[str] = None,\n    progress_handler: Optional[Callable[[int], None]] = None,\n) -&gt; Tuple[bool, Optional[Dict[str, Any]]]:\n\"\"\"\n    Convert the input file to the output file synchronously with progress handler.\n\n    ### Arguments\n    - input_file: Path to input file or tuple of (url, file_format).\n    - output_file: Path to output file.\n    - ffmpeg: ffmpeg executable to use.\n    - output_format: output format.\n    - bitrate: constant/variable bitrate.\n    - ffmpeg_args: ffmpeg arguments.\n    - progress_handler: progress handler, has to accept an integer as argument.\n\n    ### Returns\n    - Tuple of conversion status and error dictionary.\n\n    ### Notes\n    - Make sure to check if ffmpeg is installed before calling this function.\n    \"\"\"\n\n    # Initialize ffmpeg command\n    # -i is the input file\n    arguments: List[str] = [\n        \"-nostdin\",\n        \"-y\",\n        \"-i\",\n        str(input_file.resolve()) if isinstance(input_file, Path) else input_file[0],\n        \"-movflags\",\n        \"+faststart\",\n        \"-v\",\n        \"debug\",\n        \"-progress\",\n        \"-\",\n        \"-nostats\",\n    ]\n\n    file_format = (\n        str(input_file.suffix).split(\".\")[1]\n        if isinstance(input_file, Path)\n        else input_file[1]\n    )\n\n    # Add output format to command\n    # -c:a is used if the file is not an matroska container\n    # and we want to convert to opus\n    # otherwise we use arguments from FFMPEG_FORMATS\n    if output_format == \"opus\" and file_format != \"webm\":\n        arguments.extend([\"-c:a\", \"libopus\"])\n    else:\n        if (\n            (output_format == \"opus\" and file_format == \"opus\")\n            or (output_format == \"m4a\" and file_format == \"m4a\")\n            and not (bitrate or ffmpeg_args)\n        ):\n            # Copy the audio stream to the output file\n            arguments.extend([\"-vn\", \"-c:a\", \"copy\"])\n        else:\n            arguments.extend(FFMPEG_FORMATS[output_format])\n\n    # Add bitrate if specified\n    if bitrate:\n        # Check if bitrate is an integer\n        # if it is then use it as variable bitrate\n        if bitrate.isdigit():\n            arguments.extend([\"-q:a\", bitrate])\n        else:\n            arguments.extend([\"-b:a\", bitrate])\n\n    # Add other ffmpeg arguments if specified\n    if ffmpeg_args:\n        arguments.extend(shlex.split(ffmpeg_args))\n\n    # Add output file at the end\n    arguments.append(str(output_file.resolve()))\n\n    # Run ffmpeg\n    with subprocess.Popen(\n        [ffmpeg, *arguments],\n        stdin=subprocess.PIPE,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.STDOUT,\n        universal_newlines=False,\n    ) as process:\n        if not progress_handler:\n            # Wait for process to finish\n            proc_out = process.communicate()\n\n            if process.returncode != 0:\n                # get version and build year\n                version = get_ffmpeg_version(ffmpeg)\n\n                # join stdout and stderr and decode to utf-8\n                message = b\"\".join([out for out in proc_out if out]).decode(\"utf-8\")\n\n                # return error dictionary\n                return False, {\n                    \"return_code\": process.returncode,\n                    \"arguments\": arguments,\n                    \"ffmpeg\": ffmpeg,\n                    \"version\": version[0],\n                    \"build_year\": version[1],\n                    \"error\": message,\n                }\n\n            return True, None\n\n        progress_handler(0)\n\n        out_buffer = []\n        total_dur = None\n        out: str = \"\"\n        while True:\n            if process.stdout is None:\n                continue\n\n            out_line = (\n                process.stdout.readline().decode(\"utf-8\", errors=\"replace\").strip()\n            )\n\n            if out_line == \"\" and process.poll() is not None:\n                break\n\n            out_buffer.append(out_line.strip())\n\n            out = \"\\n\".join(out_buffer)\n\n            total_dur_match = DUR_REGEX.search(out_line)\n            if total_dur is None and total_dur_match:\n                total_dur = to_ms(**total_dur_match.groupdict())  # type: ignore\n                continue\n            if total_dur:\n                progress_time = TIME_REGEX.search(out_line)\n                if progress_time:\n                    elapsed_time = to_ms(**progress_time.groupdict())  # type: ignore\n                    progress_handler(int(elapsed_time / total_dur * 100))  # type: ignore\n\n        if process.returncode != 0:\n            # get version and build year\n            version = get_ffmpeg_version(ffmpeg)\n\n            return False, {\n                \"return_code\": process.returncode,\n                \"arguments\": arguments,\n                \"ffmpeg\": ffmpeg,\n                \"version\": version[0],\n                \"build_year\": version[1],\n                \"error\": out,\n            }\n\n        progress_handler(100)\n\n        return True, None\n</code></pre>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.download_ffmpeg","title":"<code>download_ffmpeg()</code>","text":"<p>Download ffmpeg binary to spotdl directory.</p>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.download_ffmpeg--returns","title":"Returns","text":"<ul> <li>Path to ffmpeg binary.</li> </ul>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.download_ffmpeg--notes","title":"Notes","text":"<ul> <li>ffmpeg is downloaded from github releases     for current platform and architecture.</li> <li>executable permission is set for ffmpeg binary.</li> </ul> Source code in <code>spotdl/utils/ffmpeg.py</code> <pre><code>def download_ffmpeg() -&gt; Path:\n\"\"\"\n    Download ffmpeg binary to spotdl directory.\n\n    ### Returns\n    - Path to ffmpeg binary.\n\n    ### Notes\n    - ffmpeg is downloaded from github releases\n        for current platform and architecture.\n    - executable permission is set for ffmpeg binary.\n    \"\"\"\n\n    os_name = platform.system().lower()\n    os_arch = platform.machine().lower()\n\n    ffmpeg_url = FFMPEG_URLS.get(os_name, {}).get(os_arch)\n    ffmpeg_path = Path(\n        os.path.join(\n            get_spotdl_path(), \"ffmpeg\" + (\".exe\" if os_name == \"windows\" else \"\")\n        )\n    )\n\n    if ffmpeg_url is None:\n        raise FFmpegError(\"FFmpeg binary is not available for your system.\")\n\n    # Download binary and save it to a file in spotdl directory\n    ffmpeg_binary = requests.get(ffmpeg_url, allow_redirects=True, timeout=10).content\n    with open(ffmpeg_path, \"wb\") as ffmpeg_file:\n        ffmpeg_file.write(ffmpeg_binary)\n\n    # Set executable permission on linux and mac\n    if os_name in [\"linux\", \"darwin\"]:\n        ffmpeg_path.chmod(ffmpeg_path.stat().st_mode | stat.S_IEXEC)\n\n    return ffmpeg_path\n</code></pre>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.get_ffmpeg_path","title":"<code>get_ffmpeg_path()</code>","text":"<p>Get path to global ffmpeg binary or a local ffmpeg binary.</p>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.get_ffmpeg_path--returns","title":"Returns","text":"<ul> <li>Path to ffmpeg binary or None if not found.</li> </ul> Source code in <code>spotdl/utils/ffmpeg.py</code> <pre><code>def get_ffmpeg_path() -&gt; Optional[Path]:\n\"\"\"\n    Get path to global ffmpeg binary or a local ffmpeg binary.\n\n    ### Returns\n    - Path to ffmpeg binary or None if not found.\n    \"\"\"\n\n    # Check if ffmpeg is installed\n    global_ffmpeg = shutil.which(\"ffmpeg\")\n    if global_ffmpeg:\n        return Path(global_ffmpeg)\n\n    # Get local ffmpeg path\n    return get_local_ffmpeg()\n</code></pre>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.get_ffmpeg_version","title":"<code>get_ffmpeg_version(ffmpeg='ffmpeg')</code>","text":"<p>Get ffmpeg version.</p>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.get_ffmpeg_version--arguments","title":"Arguments","text":"<ul> <li>ffmpeg: ffmpeg executable to check</li> </ul>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.get_ffmpeg_version--returns","title":"Returns","text":"<ul> <li>Tuple of optional version and optional year.</li> </ul>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.get_ffmpeg_version--errors","title":"Errors","text":"<ul> <li>FFmpegError if ffmpeg is not installed.</li> <li>FFmpegError if ffmpeg version is not found.</li> </ul> Source code in <code>spotdl/utils/ffmpeg.py</code> <pre><code>def get_ffmpeg_version(ffmpeg: str = \"ffmpeg\") -&gt; Tuple[Optional[float], Optional[int]]:\n\"\"\"\n    Get ffmpeg version.\n\n    ### Arguments\n    - ffmpeg: ffmpeg executable to check\n\n    ### Returns\n    - Tuple of optional version and optional year.\n\n    ### Errors\n    - FFmpegError if ffmpeg is not installed.\n    - FFmpegError if ffmpeg version is not found.\n    \"\"\"\n\n    # Check if ffmpeg is installed\n    if not is_ffmpeg_installed(ffmpeg):\n        if ffmpeg == \"ffmpeg\":\n            raise FFmpegError(\"ffmpeg is not installed.\")\n\n        raise FFmpegError(f\"{ffmpeg} is not a valid ffmpeg executable.\")\n\n    with subprocess.Popen(\n        [ffmpeg, \"-version\"],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        encoding=\"utf-8\",\n    ) as process:\n        output = \"\".join(process.communicate())\n\n    # Search for version and build year in output\n    version_result = VERSION_REGEX.search(output)\n    year_result = YEAR_REGEX.search(output)\n\n    build_year = None\n    version = None\n\n    if version_result is not None:\n        # remove all non numeric characters from string example: n4.3\n        version_str = re.sub(r\"[a-zA-Z]\", \"\", version_result.group(0))\n\n        # parse version string to float\n        version = float(version_str) if version_str else None\n\n    if year_result is not None:\n        # get build years from string example: Copyright (c) 2019-2020\n        build_years = [\n            int(\n                re.sub(r\"[^0-9]\", \"\", year)\n            )  # remove all non numeric characters from string\n            for year in year_result.group(0).split(\n                \"-\"\n            )  # split string into list of years\n        ]\n\n        # get the highest build year\n        build_year = max(build_years)\n\n    return (version, build_year)\n</code></pre>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.get_local_ffmpeg","title":"<code>get_local_ffmpeg()</code>","text":"<p>Get local ffmpeg binary path.</p>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.get_local_ffmpeg--returns","title":"Returns","text":"<ul> <li>Path to ffmpeg binary or None if not found.</li> </ul> Source code in <code>spotdl/utils/ffmpeg.py</code> <pre><code>def get_local_ffmpeg() -&gt; Optional[Path]:\n\"\"\"\n    Get local ffmpeg binary path.\n\n    ### Returns\n    - Path to ffmpeg binary or None if not found.\n    \"\"\"\n\n    ffmpeg_path = Path(get_spotdl_path()) / (\n        \"ffmpeg\" + (\".exe\" if platform.system() == \"Windows\" else \"\")\n    )\n\n    if ffmpeg_path.is_file():\n        return ffmpeg_path\n\n    return None\n</code></pre>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.is_ffmpeg_installed","title":"<code>is_ffmpeg_installed(ffmpeg='ffmpeg')</code>","text":"<p>Check if ffmpeg is installed.</p>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.is_ffmpeg_installed--arguments","title":"Arguments","text":"<ul> <li>ffmpeg: ffmpeg executable to check</li> </ul>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.is_ffmpeg_installed--returns","title":"Returns","text":"<ul> <li>True if ffmpeg is installed, False otherwise.</li> </ul> Source code in <code>spotdl/utils/ffmpeg.py</code> <pre><code>def is_ffmpeg_installed(ffmpeg: str = \"ffmpeg\") -&gt; bool:\n\"\"\"\n    Check if ffmpeg is installed.\n\n    ### Arguments\n    - ffmpeg: ffmpeg executable to check\n\n    ### Returns\n    - True if ffmpeg is installed, False otherwise.\n    \"\"\"\n\n    if ffmpeg == \"ffmpeg\":\n        global_ffmpeg = shutil.which(\"ffmpeg\")\n        if global_ffmpeg is None:\n            ffmpeg_path = get_ffmpeg_path()\n        else:\n            ffmpeg_path = Path(global_ffmpeg)\n    else:\n        ffmpeg_path = Path(ffmpeg)\n\n    if ffmpeg_path is None:\n        return False\n\n    # else check if path to ffmpeg is valid\n    # and if ffmpeg has the correct access rights\n    return ffmpeg_path.exists() and os.access(ffmpeg_path, os.X_OK)\n</code></pre>"},{"location":"reference/utils/formatter/","title":"formatter","text":"<p>Module for formatting songs into strings. Contains functions to create search queries and song titles and file names.</p>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_file_name","title":"<code>create_file_name(song, template, file_extension, short=False)</code>","text":"<p>Create the file name for the song, by replacing template variables with the actual values.</p>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_file_name--arguments","title":"Arguments","text":"<ul> <li>song: the song object</li> <li>template: the template string</li> <li>file_extension: the file extension to use</li> <li>short: whether to use the short version of the template</li> </ul>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_file_name--returns","title":"Returns","text":"<ul> <li>the formatted string as a Path object</li> </ul> Source code in <code>spotdl/utils/formatter.py</code> <pre><code>def create_file_name(\n    song: Song,\n    template: str,\n    file_extension: str,\n    short: bool = False,\n) -&gt; Path:\n\"\"\"\n    Create the file name for the song, by replacing template variables with the actual values.\n\n    ### Arguments\n    - song: the song object\n    - template: the template string\n    - file_extension: the file extension to use\n    - short: whether to use the short version of the template\n\n    ### Returns\n    - the formatted string as a Path object\n    \"\"\"\n\n    # If template does not contain any of the keys,\n    # append {artists} - {title}.{output-ext} to it\n    if not any(key in template for key in VARS):\n        template += \"/{artists} - {title}.{output-ext}\"\n\n    # If template ends with a slash. Does not have a file name with extension\n    # at the end of the template, append {artists} - {title}.{output-ext} to it\n    if template.endswith(\"/\") or template.endswith(r\"\\\\\") or template.endswith(\"\\\\\\\\\"):\n        template += \"/{artists} - {title}.{output-ext}\"\n\n    # If template does not end with {output-ext}, append it to the end of the template\n    if not template.endswith(\".{output-ext}\"):\n        template += \".{output-ext}\"\n\n    formatted_string = format_query(\n        song=song,\n        template=template,\n        santitize=True,\n        file_extension=file_extension,\n        short=short,\n    )\n\n    # Parse template as Path object\n    file = Path(formatted_string)\n\n    santitized_parts = []\n    for part in file.parts:\n        match = re.search(r\"[^\\.*](.*)[^\\.*$]\", part)\n        if match and part != \".spotdl\":\n            santitized_parts.append(match.group(0))\n        else:\n            santitized_parts.append(part)\n\n    # Join the parts of the path\n    file = Path(*santitized_parts)\n\n    # Check if the file name length is greater than 255\n    if len(file.name) &gt; 255:\n        # If the file name length is greater than 255,\n        # and we are already using the short version of the template,\n        # fallback to default template\n        if short is True:\n            warnings.warn(\n                f\"{song.display_name}: File name is too long. Using the default template.\"\n            )\n\n            return create_file_name(\n                song=song,\n                template=\"/{artist} - {title}.{output-ext}\",\n                file_extension=file_extension,\n                short=short,\n            )\n\n        # This will probably never occur, but just in case\n        if short is True and template == \"/{artist} - {title}.{output-ext}\":\n            raise RecursionError(\n                f'\"{song.display_name} is too long to be shortened. File a bug report on GitHub'\n            )\n\n        return create_file_name(\n            song,\n            template,\n            file_extension,\n            short=True,\n        )\n\n    return file\n</code></pre>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_search_query","title":"<code>create_search_query(song, template, santitize, file_extension=None, short=False)</code>","text":"<p>Create the search query for the song.</p>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_search_query--arguments","title":"Arguments","text":"<ul> <li>song: the song object</li> <li>template: the template string</li> <li>santitize: whether to sanitize the string</li> <li>file_extension: the file extension to use</li> <li>short: whether to use the short version of the template</li> </ul>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_search_query--returns","title":"Returns","text":"<ul> <li>the formatted string</li> </ul> Source code in <code>spotdl/utils/formatter.py</code> <pre><code>def create_search_query(\n    song: Song,\n    template: str,\n    santitize: bool,\n    file_extension: Optional[str] = None,\n    short: bool = False,\n) -&gt; str:\n\"\"\"\n    Create the search query for the song.\n\n    ### Arguments\n    - song: the song object\n    - template: the template string\n    - santitize: whether to sanitize the string\n    - file_extension: the file extension to use\n    - short: whether to use the short version of the template\n\n    ### Returns\n    - the formatted string\n    \"\"\"\n\n    # If template does not contain any of the keys,\n    # append {artist} - {title} at the beggining of the template\n    if not any(key in template for key in VARS):\n        template = \"{artist} - {title}\" + template\n\n    return format_query(song, template, santitize, file_extension, short=short)\n</code></pre>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_song_title","title":"<code>create_song_title(song_name, song_artists)</code>","text":"<p>Create the song title.</p>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_song_title--arguments","title":"Arguments","text":"<ul> <li>song_name: the name of the song</li> <li>song_artists: the list of artists of the song</li> </ul>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_song_title--returns","title":"Returns","text":"<ul> <li>the song title</li> </ul>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_song_title--notes","title":"Notes","text":"<ul> <li>Example: \"Artist1, Artist2 - Song Name\"</li> </ul> Source code in <code>spotdl/utils/formatter.py</code> <pre><code>def create_song_title(song_name: str, song_artists: List[str]) -&gt; str:\n\"\"\"\n    Create the song title.\n\n    ### Arguments\n    - song_name: the name of the song\n    - song_artists: the list of artists of the song\n\n    ### Returns\n    - the song title\n\n    ### Notes\n    - Example: \"Artist1, Artist2 - Song Name\"\n\n    \"\"\"\n\n    joined_artists = \", \".join(song_artists)\n    if len(song_artists) &gt;= 1:\n        return f\"{joined_artists} - {song_name}\"\n\n    return song_name\n</code></pre>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.format_query","title":"<code>format_query(song, template, santitize, file_extension=None, short=False)</code>","text":"<p>Replace template variables with the actual values.</p>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.format_query--arguments","title":"Arguments","text":"<ul> <li>song: the song object</li> <li>template: the template string</li> <li>santitize: whether to sanitize the string</li> <li>file_extension: the file extension to use</li> <li>short: whether to use the short version of the template</li> </ul>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.format_query--returns","title":"Returns","text":"<ul> <li>the formatted string</li> </ul> Source code in <code>spotdl/utils/formatter.py</code> <pre><code>def format_query(\n    song: Song,\n    template: str,\n    santitize: bool,\n    file_extension: Optional[str] = None,\n    short: bool = False,\n) -&gt; str:\n\"\"\"\n    Replace template variables with the actual values.\n\n    ### Arguments\n    - song: the song object\n    - template: the template string\n    - santitize: whether to sanitize the string\n    - file_extension: the file extension to use\n    - short: whether to use the short version of the template\n\n    ### Returns\n    - the formatted string\n    \"\"\"\n\n    if \"{output-ext}\" in template and file_extension is None:\n        raise ValueError(\"file_extension is None, but template contains {output-ext}\")\n\n    if (\n        any(k in template for k in [\"{list-length}\", \"{list-position}\", \"{list-name}\"])\n        and song.song_list is None\n    ):\n        # If the template contains {list-length} or {list-position} or {list-name},\n        # but the song_list is None, replace them with empty strings\n        for k in [\"{list-length}\", \"{list-position}\", \"{list-name}\"]:\n            template = template.replace(k, \"\")\n            template = template.replace(r\"//\", r\"/\")\n\n    # If template has only {output-ext}, fix it\n    # This can happen if the template consits of only list values\n    # and song.song_list is None\n    if template in [\"/.{output-ext}\", \".{output-ext}\"]:\n        template = \"{artists} - {title}.{output-ext}\"\n\n    # Remove artists from the list that are already in the title\n    artists = [\n        artist for artist in song.artists if slugify(artist) not in slugify(song.name)\n    ]\n\n    # Add the main artist again to the list\n    if len(artists) == 0 or artists[0] != song.artists[0]:\n        artists.insert(0, song.artists[0])\n\n    artists_str = \", \".join(artists)\n\n    # the code below is valid, song_list is actually checked for None\n    formats = {\n        \"{title}\": song.name,\n        \"{artists}\": song.artists[0] if short is True else artists_str,\n        \"{artist}\": song.artists[0],\n        \"{album}\": song.album_name,\n        \"{album-artist}\": song.album_artist,\n        \"{genre}\": song.genres[0] if len(song.genres) &gt; 0 else \"\",\n        \"{disc-number}\": song.disc_number,\n        \"{disc-count}\": song.disc_count,\n        \"{duration}\": song.duration,\n        \"{year}\": song.year,\n        \"{original-date}\": song.date,\n        \"{track-number}\": f\"{song.track_number:02d}\",\n        \"{tracks-count}\": song.tracks_count,\n        \"{isrc}\": song.isrc,\n        \"{track-id}\": song.song_id,\n        \"{publisher}\": song.publisher,\n        \"{output-ext}\": file_extension,\n    }\n\n    if song.song_list and any(\n        k in template for k in [\"{list-length}\", \"{list-position}\", \"{list-name}\"]\n    ):\n        try:\n            index = song.song_list.songs.index(song)\n        except ValueError:\n            index = song.song_list.urls.index(song.url)\n\n        formats.update(\n            {\n                \"{list-name}\": song.song_list.name,  # type: ignore\n                \"{list-position}\": str(index + 1).zfill(\n                    len(str(song.song_list.length))\n                ),\n                \"{list-length}\": song.song_list.length,\n            }\n        )\n\n    if santitize:\n        # sanitize the values in formats dict\n        for key, value in formats.items():\n            if value is None:\n                continue\n\n            formats[key] = sanitize_string(str(value))\n\n    # Replace all the keys with the values\n    for key, value in formats.items():\n        template = template.replace(key, str(value))\n\n    return template\n</code></pre>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.parse_duration","title":"<code>parse_duration(duration)</code>","text":"<p>Convert string value of time (duration: \"25:36:59\") to a float value of seconds (92219.0)</p>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.parse_duration--arguments","title":"Arguments","text":"<ul> <li>duration: the string value of time</li> </ul>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.parse_duration--returns","title":"Returns","text":"<ul> <li>the float value of seconds</li> </ul> Source code in <code>spotdl/utils/formatter.py</code> <pre><code>def parse_duration(duration: Optional[str]) -&gt; float:\n\"\"\"\n    Convert string value of time (duration: \"25:36:59\") to a float value of seconds (92219.0)\n\n    ### Arguments\n    - duration: the string value of time\n\n    ### Returns\n    - the float value of seconds\n    \"\"\"\n\n    if duration is None:\n        return 0.0\n\n    try:\n        # {(1, \"s\"), (60, \"m\"), (3600, \"h\")}\n        mapped_increments = zip([1, 60, 3600], reversed(duration.split(\":\")))\n        seconds = sum(multiplier * int(time) for multiplier, time in mapped_increments)\n        return float(seconds)\n\n    # This usually occurs when the wrong string is mistaken for the duration\n    except (ValueError, TypeError, AttributeError):\n        return 0.0\n</code></pre>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.restrict_filename","title":"<code>restrict_filename(pathobj)</code>","text":"<p>Sanitizes the filename part of a Path object. Returns modified object.</p>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.restrict_filename--arguments","title":"Arguments","text":"<ul> <li>pathobj: the Path object to sanitize</li> </ul>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.restrict_filename--returns","title":"Returns","text":"<ul> <li>the modified Path object</li> </ul>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.restrict_filename--notes","title":"Notes","text":"<ul> <li>Based on the <code>sanitize_filename</code> function from yt-dlp</li> </ul> Source code in <code>spotdl/utils/formatter.py</code> <pre><code>def restrict_filename(pathobj: Path) -&gt; Path:\n\"\"\"\n    Sanitizes the filename part of a Path object. Returns modified object.\n\n    ### Arguments\n    - pathobj: the Path object to sanitize\n\n    ### Returns\n    - the modified Path object\n\n    ### Notes\n    - Based on the `sanitize_filename` function from yt-dlp\n    \"\"\"\n\n    result = sanitize_filename(pathobj.name, True, False)\n    result = result.replace(\"_-_\", \"-\")\n\n    if not result:\n        result = \"_\"\n\n    return pathobj.with_name(result)\n</code></pre>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.sanitize_string","title":"<code>sanitize_string(string)</code>","text":"<p>Sanitize the filename to be used in the file system.</p>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.sanitize_string--arguments","title":"Arguments","text":"<ul> <li>string: the string to sanitize</li> </ul>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.sanitize_string--returns","title":"Returns","text":"<ul> <li>the sanitized string</li> </ul> Source code in <code>spotdl/utils/formatter.py</code> <pre><code>def sanitize_string(string: str) -&gt; str:\n\"\"\"\n    Sanitize the filename to be used in the file system.\n\n    ### Arguments\n    - string: the string to sanitize\n\n    ### Returns\n    - the sanitized string\n    \"\"\"\n\n    output = string\n\n    # this is windows specific (disallowed chars)\n    output = \"\".join(char for char in output if char not in \"/?\\\\*|&lt;&gt;\")\n\n    # double quotes (\") and semi-colons (:) are also disallowed characters but we would\n    # like to retain their equivalents, so they aren't removed in the prior loop\n    output = output.replace('\"', \"'\").replace(\":\", \"-\")\n\n    return output\n</code></pre>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.to_ms","title":"<code>to_ms(string=None, precision=None, **kwargs)</code>","text":"<p>Convert a string to milliseconds.</p>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.to_ms--arguments","title":"Arguments","text":"<ul> <li>string: the string to convert</li> <li>precision: the number of decimals to round to</li> <li>kwargs: the keyword args to convert</li> </ul>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.to_ms--returns","title":"Returns","text":"<ul> <li>the milliseconds</li> </ul>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.to_ms--notes","title":"Notes","text":"<ul> <li>You can either pass a string,</li> <li>or a set of keyword args (\"hour\", \"min\", \"sec\", \"ms\") to convert.</li> <li>If \"precision\" is set, the result is rounded to the number of decimals given.</li> <li>From: https://gist.github.com/Hellowlol/5f8545e999259b4371c91ac223409209</li> </ul> Source code in <code>spotdl/utils/formatter.py</code> <pre><code>def to_ms(\n    string: Optional[str] = None, precision: Optional[int] = None, **kwargs\n) -&gt; float:\n\"\"\"\n    Convert a string to milliseconds.\n\n    ### Arguments\n    - string: the string to convert\n    - precision: the number of decimals to round to\n    - kwargs: the keyword args to convert\n\n    ### Returns\n    - the milliseconds\n\n    ### Notes\n    - You can either pass a string,\n    - or a set of keyword args (\"hour\", \"min\", \"sec\", \"ms\") to convert.\n    - If \"precision\" is set, the result is rounded to the number of decimals given.\n    - From: https://gist.github.com/Hellowlol/5f8545e999259b4371c91ac223409209\n    \"\"\"\n\n    if string:\n        hour = int(string[0:2])\n        minute = int(string[3:5])\n        sec = int(string[6:8])\n        milliseconds = int(string[10:11])\n    else:\n        hour = int(kwargs.get(\"hour\", 0))\n        minute = int(kwargs.get(\"min\", 0))\n        sec = int(kwargs.get(\"sec\", 0))\n        milliseconds = int(kwargs.get(\"ms\", 0))\n\n    result = (\n        (hour * 60 * 60 * 1000) + (minute * 60 * 1000) + (sec * 1000) + milliseconds\n    )\n\n    if precision and isinstance(precision, int):\n        return round(result, precision)\n\n    return result\n</code></pre>"},{"location":"reference/utils/github/","title":"github","text":"<p>Module for getting information about the current version of spotdl from GitHub, downloading the latest version, and checking for updates.</p>"},{"location":"reference/utils/github/#spotdl.utils.github.check_for_updates","title":"<code>check_for_updates(repo=REPO)</code>","text":"<p>Check for updates to the current version.</p>"},{"location":"reference/utils/github/#spotdl.utils.github.check_for_updates--arguments","title":"Arguments","text":"<ul> <li>repo: the repo to check (defaults to spotdl/spotify-downloader)</li> </ul>"},{"location":"reference/utils/github/#spotdl.utils.github.check_for_updates--returns","title":"Returns","text":"<ul> <li>the latest version</li> </ul> Source code in <code>spotdl/utils/github.py</code> <pre><code>def check_for_updates(repo: str = REPO) -&gt; str:\n\"\"\"\n    Check for updates to the current version.\n\n    ### Arguments\n    - repo: the repo to check (defaults to spotdl/spotify-downloader)\n\n    ### Returns\n    - the latest version\n    \"\"\"\n\n    message = \"\"\n\n    url = f\"https://api.github.com/repos/{repo}/releases/latest\"\n\n    response = requests.get(url, timeout=10)\n\n    if response.status_code != 200:\n        raise RuntimeError(\n            f\"Failed to get commit count. Status code: {response.status_code}\"\n        )\n\n    data = response.json()\n\n    latest_version = data[\"name\"]  # returns \"vx.x.x\"\n    current_version = f\"v{_version.__version__}\"  # returns \"vx.x.x\"\n\n    if latest_version != current_version:\n        message = f\"New version available: {latest_version}.\\n\\n\"\n    else:\n        message = \"No updates available.\\n\\n\"\n\n    master = get_status(current_version, \"master\")\n    dev = get_status(current_version, \"dev\")\n\n    for branch in [\"master\", \"dev\"]:\n        name = branch.capitalize()\n        if branch == \"master\":\n            status, ahead_by, behind_by = master\n        else:\n            status, ahead_by, behind_by = dev\n\n        if status == \"behind\":\n            message += f\"{name} is {status} by {behind_by} commits.\\n\"\n        elif status == \"ahead\":\n            message += f\"{name} is {status} by {ahead_by} commits.\\n\"\n        else:\n            message += f\"{name} is up to date.\\n\"\n\n    return message\n</code></pre>"},{"location":"reference/utils/github/#spotdl.utils.github.create_github_url","title":"<code>create_github_url(url=WEB_APP_URL)</code>","text":"<p>From the given url, produce a URL that is compatible with Github's REST API.</p>"},{"location":"reference/utils/github/#spotdl.utils.github.create_github_url--arguments","title":"Arguments","text":"<ul> <li>url: the url to convert</li> </ul>"},{"location":"reference/utils/github/#spotdl.utils.github.create_github_url--notes","title":"Notes","text":"<ul> <li>Can handle blob or tree paths.</li> </ul> Source code in <code>spotdl/utils/github.py</code> <pre><code>def create_github_url(url: str = WEB_APP_URL):\n\"\"\"\n    From the given url, produce a URL that is compatible with Github's REST API.\n\n    ### Arguments\n    - url: the url to convert\n\n    ### Notes\n    - Can handle blob or tree paths.\n    \"\"\"\n\n    repo_only_url = re.compile(\n        r\"https:\\/\\/github\\.com\\/[a-z\\d](?:[a-z\\d]|-(?=[a-z\\d])){0,38}\\/[a-zA-Z0-9]+$\"\n    )\n    re_branch = re.compile(\"/(tree|blob)/(.+?)/\")\n\n    # Check if the given url is a url to a GitHub repo. If it is, tell the\n    # user to use 'git clone' to download it\n    if re.match(repo_only_url, url):\n        raise ValueError(\n            \"The given URL is a GitHub repo. Please use 'git clone' to download it.\"\n        )\n\n    # extract the branch name from the given url (e.g master)\n    branch = re_branch.search(url)\n    if branch:\n        download_dirs = url[branch.end() :]\n        api_url = (\n            url[: branch.start()].replace(\"github.com\", \"api.github.com/repos\", 1)\n            + \"/contents/\"\n            + download_dirs\n            + \"?ref=\"\n            + branch.group(2)\n        )\n        return api_url\n\n    raise ValueError(\"The given url is not a valid GitHub url\")\n</code></pre>"},{"location":"reference/utils/github/#spotdl.utils.github.download_github_dir","title":"<code>download_github_dir(repo_url=WEB_APP_URL, flatten=False, output_dir='./')</code>","text":"<p>Downloads the files and directories in repo_url.</p>"},{"location":"reference/utils/github/#spotdl.utils.github.download_github_dir--arguments","title":"Arguments","text":"<ul> <li>repo_url: the url to the repo to download</li> <li>flatten: whether to flatten the directory structure</li> <li>output_dir: the directory to download the files to</li> </ul>"},{"location":"reference/utils/github/#spotdl.utils.github.download_github_dir--notes","title":"Notes","text":"<ul> <li>Modification of https://github.com/sdushantha/gitdir/blob/master/gitdir/gitdir.py</li> </ul> Source code in <code>spotdl/utils/github.py</code> <pre><code>def download_github_dir(\n    repo_url: str = WEB_APP_URL, flatten: bool = False, output_dir: str = \"./\"\n):\n\"\"\"\n    Downloads the files and directories in repo_url.\n\n    ### Arguments\n    - repo_url: the url to the repo to download\n    - flatten: whether to flatten the directory structure\n    - output_dir: the directory to download the files to\n\n    ### Notes\n    - Modification of https://github.com/sdushantha/gitdir/blob/master/gitdir/gitdir.py\n    \"\"\"\n\n    # generate the url which returns the JSON data\n    api_url = create_github_url(repo_url)\n\n    dir_out = output_dir\n\n    response = requests.get(api_url, timeout=10).json()\n\n    if (\n        isinstance(response, dict)\n        and \"message\" in response.keys()\n        and \"rate limit\" in response[\"message\"]\n    ):\n        logging.error(\n            \"You have been rate limited by Github API attempting to update web client.\"\n            \"Proceeding with cached web client. Please try again later.\"\n            \"See https://docs.github.com/en/rest/overview/resources-in-the-rest-api#rate-limiting\"\n        )\n        return None\n\n    if not flatten:\n        # make a directory with the name which is taken from\n        # the actual repo\n        os.makedirs(dir_out, exist_ok=True)\n\n    if isinstance(response, dict) and response[\"type\"] == \"file\":\n        response = [response]\n\n    for file in response:\n        file_url = file[\"download_url\"]\n\n        if flatten:\n            path = os.path.join(dir_out, os.path.basename(file[\"path\"]))\n        else:\n            path = os.path.join(dir_out, file[\"path\"])\n\n        dirname = os.path.dirname(path)\n\n        if dirname != \"\":\n            os.makedirs(dirname, exist_ok=True)\n\n        if file_url is not None:\n            with open(path, \"wb\") as new_file:\n                new_file.write(requests.get(file_url, timeout=10).content)\n        else:\n            download_github_dir(file[\"html_url\"], flatten, output_dir)\n\n    return None\n</code></pre>"},{"location":"reference/utils/github/#spotdl.utils.github.get_status","title":"<code>get_status(start, end, repo=REPO)</code>","text":"<p>Get the status of a commit range.</p>"},{"location":"reference/utils/github/#spotdl.utils.github.get_status--arguments","title":"Arguments","text":"<ul> <li>start: the starting commit/branch/tag</li> <li>end: the ending commit/branch/tag</li> <li>repo: the repo to check (defaults to spotdl/spotify-downloader)</li> </ul>"},{"location":"reference/utils/github/#spotdl.utils.github.get_status--returns","title":"Returns","text":"<ul> <li>tuple of (status, ahead_by, behind_by)</li> </ul> Source code in <code>spotdl/utils/github.py</code> <pre><code>def get_status(start: str, end: str, repo: str = REPO) -&gt; Tuple[str, int, int]:\n\"\"\"\n    Get the status of a commit range.\n\n    ### Arguments\n    - start: the starting commit/branch/tag\n    - end: the ending commit/branch/tag\n    - repo: the repo to check (defaults to spotdl/spotify-downloader)\n\n    ### Returns\n    - tuple of (status, ahead_by, behind_by)\n    \"\"\"\n\n    url = f\"https://api.github.com/repos/{repo}/compare/{start}...{end}\"\n\n    response = requests.get(url, timeout=10)\n\n    if response.status_code != 200:\n        raise RuntimeError(\n            f\"Failed to get commit count. Status code: {response.status_code}\"\n        )\n\n    data = response.json()\n\n    return (\n        data[\"status\"],\n        data[\"ahead_by\"],\n        data[\"behind_by\"],\n    )\n</code></pre>"},{"location":"reference/utils/m3u/","title":"m3u","text":"<p>Module for creating m3u content and writing it to a file.</p>"},{"location":"reference/utils/m3u/#spotdl.utils.m3u.create_m3u_content","title":"<code>create_m3u_content(song_list, template, file_extension, short=False)</code>","text":"<p>Create m3u content and return it as a string.</p>"},{"location":"reference/utils/m3u/#spotdl.utils.m3u.create_m3u_content--arguments","title":"Arguments","text":"<ul> <li>song_list: the list of songs</li> <li>template: the template to use</li> <li>file_extension: the file extension to use</li> <li>short: whether to use the short version of the template</li> </ul>"},{"location":"reference/utils/m3u/#spotdl.utils.m3u.create_m3u_content--returns","title":"Returns","text":"<ul> <li>the m3u content as a string</li> </ul> Source code in <code>spotdl/utils/m3u.py</code> <pre><code>def create_m3u_content(\n    song_list: List[Song], template: str, file_extension: str, short: bool = False\n) -&gt; str:\n\"\"\"\n    Create m3u content and return it as a string.\n\n    ### Arguments\n    - song_list: the list of songs\n    - template: the template to use\n    - file_extension: the file extension to use\n    - short: whether to use the short version of the template\n\n    ### Returns\n    - the m3u content as a string\n    \"\"\"\n\n    text = \"\"\n    for song in song_list:\n        text += str(create_file_name(song, template, file_extension, short)) + \"\\n\"\n\n    return text\n</code></pre>"},{"location":"reference/utils/m3u/#spotdl.utils.m3u.create_m3u_file","title":"<code>create_m3u_file(file_name, song_list, template, file_extension, short=False)</code>","text":"<p>Create the m3u file.</p>"},{"location":"reference/utils/m3u/#spotdl.utils.m3u.create_m3u_file--arguments","title":"Arguments","text":"<ul> <li>file_name: the file name to use</li> <li>song_list: the list of songs</li> <li>template: the template to use</li> <li>file_extension: the file extension to use</li> <li>short: whether to use the short version of the template</li> </ul>"},{"location":"reference/utils/m3u/#spotdl.utils.m3u.create_m3u_file--returns","title":"Returns","text":"<ul> <li>the m3u content as a string</li> </ul> Source code in <code>spotdl/utils/m3u.py</code> <pre><code>def create_m3u_file(\n    file_name: str,\n    song_list: List[Song],\n    template: str,\n    file_extension: str,\n    short: bool = False,\n) -&gt; str:\n\"\"\"\n    Create the m3u file.\n\n    ### Arguments\n    - file_name: the file name to use\n    - song_list: the list of songs\n    - template: the template to use\n    - file_extension: the file extension to use\n    - short: whether to use the short version of the template\n\n    ### Returns\n    - the m3u content as a string\n    \"\"\"\n\n    m3u_content = create_m3u_content(song_list, template, file_extension, short)\n\n    with open(file_name, \"w\", encoding=\"utf-8\") as m3u_file:\n        m3u_file.write(m3u_content)\n\n    return m3u_content\n</code></pre>"},{"location":"reference/utils/m3u/#spotdl.utils.m3u.gen_m3u_files","title":"<code>gen_m3u_files(query, file_name, song_list, template, file_extension, short=False)</code>","text":"<p>Create an m3u filename from the query.</p>"},{"location":"reference/utils/m3u/#spotdl.utils.m3u.gen_m3u_files--arguments","title":"Arguments","text":"<ul> <li>query: the query</li> <li>file_name: the file name to use</li> <li>song_list: the list of songs</li> <li>template: the template to use</li> <li>file_extension: the file extension to use</li> <li>short: whether to use the short version of the template</li> </ul> Source code in <code>spotdl/utils/m3u.py</code> <pre><code>def gen_m3u_files(\n    query: List[str],\n    file_name: Optional[str],\n    song_list: List[Song],\n    template: str,\n    file_extension: str,\n    short: bool = False,\n):\n\"\"\"\n    Create an m3u filename from the query.\n\n    ### Arguments\n    - query: the query\n    - file_name: the file name to use\n    - song_list: the list of songs\n    - template: the template to use\n    - file_extension: the file extension to use\n    - short: whether to use the short version of the template\n    \"\"\"\n\n    # If no file name is provided, use the first list's name\n    if not file_name:\n        file_name = \"{list[0]}.m3u\"\n\n    # If file_name ends with a slash. Does not have a m3u name with extension\n    # at the end of the template, append `{list[0]}`` to it\n    if (\n        file_name.endswith(\"/\")\n        or file_name.endswith(r\"\\\\\")\n        or file_name.endswith(\"\\\\\\\\\")\n    ):\n        file_name += \"/{list[0]}.m3u\"\n\n    # Check if the file name ends with .m3u\n    if not file_name.endswith(\".m3u\"):\n        file_name += \".m3u\"\n\n    lists = []\n    for request in query:\n        if \"open.spotify.com\" in request and \"playlist\" in request:\n            lists.append(Playlist.create_basic_list(request))\n        elif \"open.spotify.com\" in request and \"album\" in request:\n            lists.append(Album.create_basic_list(request))\n        elif \"open.spotify.com\" in request and \"artist\" in request:\n            lists.append(Artist.create_basic_list(request))\n        elif request == \"saved\":\n            lists.append(Saved.create_basic_list())\n\n    if len(lists) == 0 and \"{list\" in template:\n        raise ValueError(\n            \"You must provide a playlist/album/artist/saved to use {list} in the template.\"\n        )\n\n    # Create a songs list from the lists and the song_list\n    songs_lists = []\n    for list_obj in lists:\n        songs = []\n        for song in song_list:\n            if song.url in list_obj.urls:\n                songs.append(song)\n\n        songs_lists.append((list_obj.name, songs))\n\n    if \"{list}\" in file_name:\n        for list_name, new_song_list in songs_lists:\n            create_m3u_file(\n                file_name.format(\n                    list=list_name,\n                ),\n                new_song_list,\n                template,\n                file_extension,\n                short,\n            )\n    elif \"{list[\" in file_name and \"]}\" in file_name:\n        create_m3u_file(\n            file_name.format(list=[list_name for list_name, _ in songs_lists]),\n            song_list,\n            template,\n            file_extension,\n            short,\n        )\n    else:\n        create_m3u_file(\n            file_name,\n            song_list,\n            template,\n            file_extension,\n            short,\n        )\n</code></pre>"},{"location":"reference/utils/metadata/","title":"metadata","text":"<p>Module for embedding metadata into audio files using Mutagen.</p> <pre><code>embed_metadata(\n    output_file=Path(\"test.mp3\"),\n    song=song_object,\n    file_format=\"mp3\",\n)\n</code></pre>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.MetadataError","title":"<code>MetadataError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Base class for all exceptions related to metadata and id3 embedding.</p>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.embed_metadata","title":"<code>embed_metadata(output_file, song, file_format)</code>","text":"<p>Embeds metadata into the output file.</p>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.embed_metadata--arguments","title":"Arguments","text":"<ul> <li>output_file: Path to the output file.</li> <li>song: Song object.</li> <li>file_format: File format of the output file.</li> </ul> Source code in <code>spotdl/utils/metadata.py</code> <pre><code>def embed_metadata(output_file: Path, song: Song, file_format: str) -&gt; None:\n\"\"\"\n    Embeds metadata into the output file.\n\n    ### Arguments\n    - output_file: Path to the output file.\n    - song: Song object.\n    - file_format: File format of the output file.\n    \"\"\"\n\n    function = AVAILABLE_FORMATS.get(file_format)\n    if function:\n        function(output_file, song)\n</code></pre>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.get_song_metadata","title":"<code>get_song_metadata(path)</code>","text":"<p>Get song metadata.</p>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.get_song_metadata--arguments","title":"Arguments","text":"<ul> <li>path: Path to the song.</li> </ul>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.get_song_metadata--returns","title":"Returns","text":"<ul> <li>Tuple containing the song name and a dict with other metadata.</li> </ul>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.get_song_metadata--raises","title":"Raises","text":"<ul> <li>OSError: If the file is not found.</li> <li>MetadataError: If the file is not a valid audio file.</li> </ul> Source code in <code>spotdl/utils/metadata.py</code> <pre><code>def get_song_metadata(path: Path) -&gt; Optional[Dict[str, Any]]:\n\"\"\"\n    Get song metadata.\n\n    ### Arguments\n    - path: Path to the song.\n\n    ### Returns\n    - Tuple containing the song name and a dict with other metadata.\n\n    ### Raises\n    - OSError: If the file is not found.\n    - MetadataError: If the file is not a valid audio file.\n    \"\"\"\n\n    if path.exists() is False:\n        raise OSError(f\"File not found: {path}\")\n\n    audio_file = File(str(path.resolve()), easy=True)\n\n    if audio_file is None or audio_file == {}:\n        return None\n\n    song_meta = {}\n    for key in TAG_PRESET:\n        song_meta[key] = audio_file.get(key)\n\n    if path.suffix == \".mp3\":\n        song_meta[\"lyrics\"] = audio_file.get(\"USLT::'eng'\")\n\n    return song_meta\n</code></pre>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.set_id3_flac","title":"<code>set_id3_flac(output_file, song)</code>","text":"<p>Set ID3 tags for FLAC files.</p>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.set_id3_flac--arguments","title":"Arguments","text":"<ul> <li>output_file: Path to the output file.</li> <li>song: Song object.</li> </ul> Source code in <code>spotdl/utils/metadata.py</code> <pre><code>def set_id3_flac(output_file: Path, song: Song):\n\"\"\"\n    Set ID3 tags for FLAC files.\n\n    ### Arguments\n    - output_file: Path to the output file.\n    - song: Song object.\n    \"\"\"\n\n    audio_file = FLAC(str(output_file.resolve()))\n\n    audio_file = _embed_basic_metadata(audio_file, song, \"flac\")\n    audio_file = _embed_ogg_metadata(audio_file, song)\n    audio_file = _embed_cover(audio_file, song, \"flac\")\n\n    audio_file.save()\n</code></pre>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.set_id3_m4a","title":"<code>set_id3_m4a(output_file, song)</code>","text":"<p>Set ID3 tags for M4A files.</p>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.set_id3_m4a--arguments","title":"Arguments","text":"<ul> <li>output_file: Path to the output file.</li> <li>song: Song object.</li> </ul> Source code in <code>spotdl/utils/metadata.py</code> <pre><code>def set_id3_m4a(output_file: Path, song: Song):\n\"\"\"\n    Set ID3 tags for M4A files.\n\n    ### Arguments\n    - output_file: Path to the output file.\n    - song: Song object.\n    \"\"\"\n\n    audio_file = MP4(str(output_file.resolve()))\n\n    audio_file = _embed_basic_metadata(audio_file, song, \"m4a\", M4A_TAG_PRESET)\n\n    audio_file[M4A_TAG_PRESET[\"year\"]] = str(song.year)\n    audio_file[M4A_TAG_PRESET[\"explicit\"]] = (4 if song.explicit is True else 2,)\n\n    if song.lyrics:\n        audio_file[M4A_TAG_PRESET[\"lyrics\"]] = song.lyrics\n\n    if song.cover_url:\n        try:\n            with urlopen(song.cover_url) as raw_album_art:\n                audio_file[M4A_TAG_PRESET[\"albumart\"]] = [\n                    MP4Cover(\n                        raw_album_art.read(),\n                        imageformat=MP4Cover.FORMAT_JPEG,\n                    )\n                ]\n        except IndexError:\n            pass\n\n    if song.download_url:\n        audio_file[M4A_TAG_PRESET[\"comment\"]] = song.download_url\n\n    audio_file.save()\n</code></pre>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.set_id3_mp3","title":"<code>set_id3_mp3(output_file, song)</code>","text":"<p>Set ID3 tags for MP3 files.</p>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.set_id3_mp3--arguments","title":"Arguments","text":"<ul> <li>output_file: Path to the output file.</li> <li>song: Song object.</li> </ul> Source code in <code>spotdl/utils/metadata.py</code> <pre><code>def set_id3_mp3(output_file: Path, song: Song):\n\"\"\"\n    Set ID3 tags for MP3 files.\n\n    ### Arguments\n    - output_file: Path to the output file.\n    - song: Song object.\n    \"\"\"\n\n    try:\n        audio_file: Union[EasyID3, ID3FileType] = EasyID3(str(output_file.resolve()))\n    except ID3NoHeaderError as exc:\n        unknown_file: Optional[ID3FileType] = File(\n            str(output_file.resolve()), easy=True\n        )\n\n        if unknown_file is None:\n            raise MetadataError(\"Unable to load file.\") from exc\n\n        unknown_file.add_tags()\n        audio_file = unknown_file\n\n    audio_file.delete()\n\n    audio_file[\"title\"] = song.name\n    audio_file[\"titlesort\"] = song.name\n    audio_file[\"tracknumber\"] = [song.track_number, song.tracks_count]\n    audio_file[\"discnumber\"] = [song.disc_number, song.disc_count]\n    audio_file[\"artist\"] = song.artists\n    audio_file[\"album\"] = song.album_name\n    audio_file[\"albumartist\"] = song.album_artist\n    audio_file[\"date\"] = song.date\n    audio_file[\"originaldate\"] = song.date\n    audio_file[\"encodedby\"] = song.publisher\n    if song.copyright_text:\n        audio_file[\"copyright\"] = song.copyright_text\n\n    genres = song.genres\n    if len(genres) &gt; 0:\n        audio_file[\"genre\"] = genres[0]\n\n    audio_file.save(v2_version=3)\n\n    temp_audio_file: ID3 = ID3(str(output_file.resolve()))\n    if song.cover_url:\n        with urlopen(song.cover_url) as raw_album_art:\n            temp_audio_file[\"APIC\"] = AlbumCover(\n                encoding=3,\n                mime=\"image/jpeg\",\n                type=3,\n                desc=\"Cover\",\n                data=raw_album_art.read(),\n            )\n\n    if song.lyrics:\n        temp_audio_file[\"USLT::'eng'\"] = USLT(\n            encoding=3, lang=\"eng\", desc=\"desc\", text=song.lyrics\n        )\n\n    if song.download_url:\n        temp_audio_file.add(Comment(encoding=3, text=song.download_url))\n\n    temp_audio_file.save(v2_version=3)\n</code></pre>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.set_id3_ogg","title":"<code>set_id3_ogg(output_file, song)</code>","text":"<p>Set ID3 tags for OGG files.</p>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.set_id3_ogg--arguments","title":"Arguments","text":"<ul> <li>output_file: Path to the output file.</li> <li>song: Song object.</li> </ul> Source code in <code>spotdl/utils/metadata.py</code> <pre><code>def set_id3_ogg(output_file: Path, song: Song):\n\"\"\"\n    Set ID3 tags for OGG files.\n\n    ### Arguments\n    - output_file: Path to the output file.\n    - song: Song object.\n    \"\"\"\n\n    audio_file = OggVorbis(str(output_file.resolve()))\n\n    audio_file = _embed_basic_metadata(audio_file, song, \"ogg\")\n    audio_file = _embed_ogg_metadata(audio_file, song)\n    audio_file = _embed_cover(audio_file, song, \"ogg\")\n\n    audio_file.save()\n</code></pre>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.set_id3_opus","title":"<code>set_id3_opus(output_file, song)</code>","text":"<p>Set ID3 tags for Opus files.</p>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.set_id3_opus--arguments","title":"Arguments","text":"<ul> <li>output_file: Path to the output file.</li> <li>song: Song object.</li> </ul> Source code in <code>spotdl/utils/metadata.py</code> <pre><code>def set_id3_opus(output_file: Path, song: Song):\n\"\"\"\n    Set ID3 tags for Opus files.\n\n    ### Arguments\n    - output_file: Path to the output file.\n    - song: Song object.\n    \"\"\"\n\n    audio_file = OggOpus(str(output_file.resolve()))\n\n    audio_file = _embed_basic_metadata(audio_file, song, \"opus\")\n    audio_file = _embed_ogg_metadata(audio_file, song)\n    audio_file = _embed_cover(audio_file, song, \"opus\")\n\n    audio_file.save()\n</code></pre>"},{"location":"reference/utils/search/","title":"search","text":"<p>Module for creating Song objects by interacting with Spotify API or by parsing a query.</p> <p>To use this module you must first initialize the SpotifyClient.</p>"},{"location":"reference/utils/search/#spotdl.utils.search.QueryError","title":"<code>QueryError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Base class for all exceptions related to query.</p>"},{"location":"reference/utils/search/#spotdl.utils.search.create_empty_song","title":"<code>create_empty_song(name=None, artists=None, album_name=None, album_artist=None, genres=None, disc_number=None, disc_count=None, duration=None, year=None, date=None, track_number=None, tracks_count=None, isrc=None, song_id=None, cover_url=None, explicit=None, publisher=None, url=None, copyright_text=None, download_url=None, song_list=None)</code>","text":"<p>Create an empty song.</p>"},{"location":"reference/utils/search/#spotdl.utils.search.create_empty_song--arguments","title":"Arguments","text":"<ul> <li>name: Name of the song</li> <li>artists: List of artists</li> <li>album_name: Name of the album</li> <li>album_artist: Name of the album artist</li> <li>genres: List of genres</li> <li>disc_number: Disc number</li> <li>disc_count: Disc count</li> <li>duration: Duration of the song in seconds</li> <li>year: Year of release</li> <li>date: Date of release</li> <li>track_number: Track number</li> <li>tracks_count: Number of tracks</li> <li>isrc: ISRC code</li> <li>song_id: Spotify song ID</li> <li>cover_url: URL of the cover art</li> <li>explicit: Explicit flag</li> <li>publisher: Publisher</li> <li>url: URL of the song</li> <li>copyright_text: Copyright text</li> <li>download_url: Download URL</li> <li>song_list: Song list</li> </ul>"},{"location":"reference/utils/search/#spotdl.utils.search.create_empty_song--returns","title":"Returns","text":"<ul> <li>Song object</li> </ul> Source code in <code>spotdl/utils/search.py</code> <pre><code>def create_empty_song(\n    name: Optional[str] = None,\n    artists: Optional[List[str]] = None,\n    album_name: Optional[str] = None,\n    album_artist: Optional[str] = None,\n    genres: Optional[List[str]] = None,\n    disc_number: Optional[int] = None,\n    disc_count: Optional[int] = None,\n    duration: Optional[int] = None,\n    year: Optional[int] = None,\n    date: Optional[str] = None,\n    track_number: Optional[int] = None,\n    tracks_count: Optional[int] = None,\n    isrc: Optional[str] = None,\n    song_id: Optional[str] = None,\n    cover_url: Optional[str] = None,\n    explicit: Optional[bool] = None,\n    publisher: Optional[str] = None,\n    url: Optional[str] = None,\n    copyright_text: Optional[str] = None,\n    download_url: Optional[str] = None,\n    song_list: Optional[\"SongList\"] = None,\n) -&gt; Song:\n\"\"\"\n    Create an empty song.\n\n    ### Arguments\n    - name: Name of the song\n    - artists: List of artists\n    - album_name: Name of the album\n    - album_artist: Name of the album artist\n    - genres: List of genres\n    - disc_number: Disc number\n    - disc_count: Disc count\n    - duration: Duration of the song in seconds\n    - year: Year of release\n    - date: Date of release\n    - track_number: Track number\n    - tracks_count: Number of tracks\n    - isrc: ISRC code\n    - song_id: Spotify song ID\n    - cover_url: URL of the cover art\n    - explicit: Explicit flag\n    - publisher: Publisher\n    - url: URL of the song\n    - copyright_text: Copyright text\n    - download_url: Download URL\n    - song_list: Song list\n\n    ### Returns\n    - Song object\n    \"\"\"\n\n    return Song(\n        name=name,  # type: ignore\n        artists=artists,  # type: ignore\n        artist=None if artists is None else artists[0],  # type: ignore\n        album_name=album_name,  # type: ignore\n        album_artist=album_artist,  # type: ignore\n        genres=genres,  # type: ignore\n        disc_number=disc_number,  # type: ignore\n        disc_count=disc_count,  # type: ignore\n        duration=duration,  # type: ignore\n        year=year,  # type: ignore\n        date=date,  # type: ignore\n        track_number=track_number,  # type: ignore\n        tracks_count=tracks_count,  # type: ignore\n        isrc=isrc,  # type: ignore\n        song_id=song_id,  # type: ignore\n        cover_url=cover_url,  # type: ignore\n        explicit=explicit,  # type: ignore\n        publisher=publisher,  # type: ignore\n        url=url,  # type: ignore\n        copyright_text=copyright_text,\n        download_url=download_url,\n        song_list=song_list,\n    )\n</code></pre>"},{"location":"reference/utils/search/#spotdl.utils.search.get_search_results","title":"<code>get_search_results(search_term)</code>","text":"<p>Creates a list of Song objects from a search term.</p>"},{"location":"reference/utils/search/#spotdl.utils.search.get_search_results--arguments","title":"Arguments","text":"<ul> <li>search_term: the search term to use</li> </ul>"},{"location":"reference/utils/search/#spotdl.utils.search.get_search_results--returns","title":"Returns","text":"<ul> <li>a list of Song objects</li> </ul> Source code in <code>spotdl/utils/search.py</code> <pre><code>def get_search_results(search_term: str) -&gt; List[Song]:\n\"\"\"\n    Creates a list of Song objects from a search term.\n\n    ### Arguments\n    - search_term: the search term to use\n\n    ### Returns\n    - a list of Song objects\n    \"\"\"\n\n    return Song.list_from_search_term(search_term)\n</code></pre>"},{"location":"reference/utils/search/#spotdl.utils.search.get_simple_songs","title":"<code>get_simple_songs(query)</code>","text":"<p>Parse query and return list containing simple song objects</p>"},{"location":"reference/utils/search/#spotdl.utils.search.get_simple_songs--arguments","title":"Arguments","text":"<ul> <li>query: List of strings containing query</li> </ul>"},{"location":"reference/utils/search/#spotdl.utils.search.get_simple_songs--returns","title":"Returns","text":"<ul> <li>List of simple song objects</li> </ul> Source code in <code>spotdl/utils/search.py</code> <pre><code>def get_simple_songs(\n    query: List[str],\n) -&gt; List[Song]:\n\"\"\"\n    Parse query and return list containing simple song objects\n\n    ### Arguments\n    - query: List of strings containing query\n\n    ### Returns\n    - List of simple song objects\n    \"\"\"\n\n    songs: List[Song] = []\n    lists: List[SongList] = []\n    for request in query:\n        if (\n            \"youtube.com/watch?v=\" in request\n            or \"youtu.be/\" in request\n            and \"open.spotify.com\" in request\n            and \"track\" in request\n            and \"|\" in request\n        ):\n            split_urls = request.split(\"|\")\n            if (\n                len(split_urls) &lt;= 1\n                or \"youtube\" not in split_urls[0]\n                and \"youtu.be\" not in split_urls[0]\n                or \"spotify\" not in split_urls[1]\n            ):\n                raise QueryError(\n                    'Incorrect format used, please use \"YouTubeURL|SpotifyURL\"'\n                )\n\n            songs.append(\n                create_empty_song(url=split_urls[1], download_url=split_urls[0])\n            )\n        elif \"open.spotify.com\" in request and \"track\" in request:\n            songs.append(create_empty_song(url=request))  # type: ignore\n        elif \"open.spotify.com\" in request and \"playlist\" in request:\n            lists.append(Playlist.create_basic_list(request))\n        elif \"open.spotify.com\" in request and \"album\" in request:\n            lists.append(Album.create_basic_list(request))\n        elif \"open.spotify.com\" in request and \"artist\" in request:\n            lists.append(Artist.create_basic_list(request))\n        elif \"album:\" in request:\n            lists.append(Album.from_search_term(request))\n        elif request == \"saved\":\n            lists.append(Saved.create_basic_list())\n        elif request.endswith(\".spotdl\"):\n            with open(request, \"r\", encoding=\"utf-8\") as save_file:\n                for track in json.load(save_file):\n                    # Append to songs\n                    songs.append(Song.from_dict(track))\n        else:\n            songs.append(Song.from_search_term(request))\n\n    for song_list in lists:\n        songs.extend(\n            [create_empty_song(url=url, song_list=song_list) for url in song_list.urls]\n        )  # type: ignore\n\n    return songs\n</code></pre>"},{"location":"reference/utils/search/#spotdl.utils.search.parse_query","title":"<code>parse_query(query, threads=1)</code>","text":"<p>Parse query and return list containing song object</p>"},{"location":"reference/utils/search/#spotdl.utils.search.parse_query--arguments","title":"Arguments","text":"<ul> <li>query: List of strings containing query</li> <li>threads: Number of threads to use</li> </ul>"},{"location":"reference/utils/search/#spotdl.utils.search.parse_query--returns","title":"Returns","text":"<ul> <li>List of song objects</li> </ul> Source code in <code>spotdl/utils/search.py</code> <pre><code>def parse_query(\n    query: List[str],\n    threads: int = 1,\n) -&gt; List[Song]:\n\"\"\"\n    Parse query and return list containing song object\n\n    ### Arguments\n    - query: List of strings containing query\n    - threads: Number of threads to use\n\n    ### Returns\n    - List of song objects\n    \"\"\"\n\n    songs: List[Song] = get_simple_songs(query)\n\n    results = []\n    with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:\n        for song in executor.map(reinit_song, songs):\n            results.append(song)\n\n    return results\n</code></pre>"},{"location":"reference/utils/search/#spotdl.utils.search.reinit_song","title":"<code>reinit_song(song, playlist_numbering=False)</code>","text":"<p>Update song object with new data from Spotify</p>"},{"location":"reference/utils/search/#spotdl.utils.search.reinit_song--arguments","title":"Arguments","text":"<ul> <li>song: Song object</li> <li>playlist_numbering: bool, default value is False</li> </ul>"},{"location":"reference/utils/search/#spotdl.utils.search.reinit_song--returns","title":"Returns","text":"<ul> <li>Updated song object</li> </ul> Source code in <code>spotdl/utils/search.py</code> <pre><code>def reinit_song(song: Song, playlist_numbering: bool = False) -&gt; Song:\n\"\"\"\n    Update song object with new data\n    from Spotify\n\n    ### Arguments\n    - song: Song object\n    - playlist_numbering: bool, default value is False\n\n    ### Returns\n    - Updated song object\n    \"\"\"\n\n    data = song.json\n    new_data = Song.from_url(data[\"url\"]).json\n    data.update((k, v) for k, v in new_data.items() if v is not None)\n\n    if data.get(\"song_list\"):\n        # Reinitialize the correct song list object\n        if song.song_list:\n            song_list = song.song_list.__class__(**data[\"song_list\"])\n            data[\"song_list\"] = song_list\n            data[\"list_position\"] = song_list.urls.index(song.url)\n            if playlist_numbering:\n                data[\"track_number\"] = data[\"list_position\"] + 1\n                data[\"tracks_count\"] = len(song_list.urls)\n                data[\"album_name\"] = song_list.name\n                if isinstance(song_list, Playlist):\n                    data[\"album_artist\"] = song_list.author_name\n                    data[\"cover_url\"] = song_list.cover_url\n                data[\"disc_number\"] = 1\n                data[\"disc_count\"] = 1\n\n    # return reinitialized song object\n    return Song(**data)\n</code></pre>"},{"location":"reference/utils/spotify/","title":"spotify","text":"<p>Module for interacting with Spotify API. To use this module, you must have a Spotify API key and Spotify API secret.</p> <pre><code>import spotdl.utils.spotify\nspotify.Spotify.init(client_id, client_secret)\n</code></pre>"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.Singleton","title":"<code>Singleton</code>","text":"<p>         Bases: <code>type</code></p> <p>Singleton metaclass for SpotifyClient. Ensures that SpotifyClient is not instantiated without prior initialization. Every other instantiation of SpotifyClient will return the same instance.</p>"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.Singleton.__call__","title":"<code>__call__()</code>","text":"<p>Call method for Singleton metaclass.</p>"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.Singleton.__call__--returns","title":"Returns","text":"<ul> <li>The instance of the SpotifyClient.</li> </ul> Source code in <code>spotdl/utils/spotify.py</code> <pre><code>def __call__(self):  # pylint: disable=bad-mcs-method-argument\n\"\"\"\n    Call method for Singleton metaclass.\n\n    ### Returns\n    - The instance of the SpotifyClient.\n    \"\"\"\n\n    if self._instance is None:\n        raise SpotifyError(\n            \"Spotify client not created. Call SpotifyClient.init\"\n            \"(client_id, client_secret, user_auth, cache_path, no_cache, open_browser) first.\"\n        )\n    return self._instance\n</code></pre>"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.Singleton.init","title":"<code>init(client_id, client_secret, auth_token=None, user_auth=False, cache_path=None, no_cache=False, open_browser=True)</code>","text":"<p>Initializes the SpotifyClient.</p>"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.Singleton.init--arguments","title":"Arguments","text":"<ul> <li>client_id: The client ID of the application.</li> <li>client_secret: The client secret of the application.</li> <li>auth_token: The access token to use.</li> <li>user_auth: Whether or not to use user authentication.</li> <li>cache_path: The path to the cache file.</li> <li>no_cache: Whether or not to use the cache.</li> <li>open_browser: Whether or not to open the browser.</li> </ul>"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.Singleton.init--returns","title":"Returns","text":"<ul> <li>The instance of the SpotifyClient.</li> </ul> Source code in <code>spotdl/utils/spotify.py</code> <pre><code>def init(  # pylint: disable=bad-mcs-method-argument\n    self,\n    client_id: str,\n    client_secret: str,\n    auth_token: Optional[str] = None,\n    user_auth: bool = False,\n    cache_path: Optional[str] = None,\n    no_cache: bool = False,\n    open_browser: bool = True,\n) -&gt; \"Singleton\":\n\"\"\"\n    Initializes the SpotifyClient.\n\n    ### Arguments\n    - client_id: The client ID of the application.\n    - client_secret: The client secret of the application.\n    - auth_token: The access token to use.\n    - user_auth: Whether or not to use user authentication.\n    - cache_path: The path to the cache file.\n    - no_cache: Whether or not to use the cache.\n    - open_browser: Whether or not to open the browser.\n\n    ### Returns\n    - The instance of the SpotifyClient.\n    \"\"\"\n\n    # check if initialization has been completed, if yes, raise an Exception\n    if isinstance(self._instance, self):\n        raise SpotifyError(\"A spotify client has already been initialized\")\n\n    credential_manager = None\n\n    cache_handler = (\n        CacheFileHandler(cache_path or get_cache_path())\n        if not no_cache\n        else MemoryCacheHandler()\n    )\n    # Use SpotifyOAuth as auth manager\n    if user_auth:\n        credential_manager = SpotifyOAuth(\n            client_id=client_id,\n            client_secret=client_secret,\n            redirect_uri=\"http://127.0.0.1:8080/\",\n            scope=\"user-library-read\",\n            cache_handler=cache_handler,\n            open_browser=open_browser,\n        )\n    # Use SpotifyClientCredentials as auth manager\n    else:\n        credential_manager = SpotifyClientCredentials(\n            client_id=client_id,\n            client_secret=client_secret,\n            cache_handler=cache_handler,\n        )\n    if auth_token is not None:\n        credential_manager = None\n\n    self.user_auth = user_auth\n    self.no_cache = no_cache\n\n    # Create instance\n    self._instance = super().__call__(\n        auth=auth_token,\n        auth_manager=credential_manager,\n        status_forcelist=(429, 500, 502, 503, 504, 404),\n    )\n\n    # Return instance\n    return self._instance\n</code></pre>"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.SpotifyClient","title":"<code>SpotifyClient(*args, **kwargs)</code>","text":"<p>         Bases: <code>Spotify</code></p> <p>This is the Spotify client meant to be used in the app. Has to be initialized first by calling <code>SpotifyClient.init(client_id, client_secret, user_auth, cache_path, no_cache, open_browser)</code>.</p>"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.SpotifyClient--arguments","title":"Arguments","text":"<ul> <li>auth: The access token to use.</li> <li>auth_manager: The auth manager to use.</li> </ul> Source code in <code>spotdl/utils/spotify.py</code> <pre><code>def __init__(self, *args, **kwargs):\n\"\"\"\n    Initializes the SpotifyClient.\n\n    ### Arguments\n    - auth: The access token to use.\n    - auth_manager: The auth manager to use.\n    \"\"\"\n\n    super().__init__(*args, **kwargs)\n    self._initialized = True\n</code></pre>"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.SpotifyError","title":"<code>SpotifyError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Base class for all exceptions related to SpotifyClient.</p>"},{"location":"reference/utils/web/","title":"web","text":"<p>Module which contains the web server related function FastAPI routes/classes etc.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.ApplicationState","title":"<code>ApplicationState</code>","text":"<p>Class that holds the application state.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.SPAStaticFiles","title":"<code>SPAStaticFiles</code>","text":"<p>         Bases: <code>StaticFiles</code></p> <p>Override the static files to serve the index.html and other assets.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.SPAStaticFiles.get_response","title":"<code>get_response(path, scope)</code>  <code>async</code>","text":"<p>Serve static files from the SPA.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.SPAStaticFiles.get_response--arguments","title":"Arguments","text":"<ul> <li>path: The path to the file.</li> <li>scope: The scope of the request.</li> </ul>"},{"location":"reference/utils/web/#spotdl.utils.web.SPAStaticFiles.get_response--returns","title":"Returns","text":"<ul> <li>returns the response.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>async def get_response(self, path: str, scope: Scope) -&gt; Response:\n\"\"\"\n    Serve static files from the SPA.\n\n    ### Arguments\n    - path: The path to the file.\n    - scope: The scope of the request.\n\n    ### Returns\n    - returns the response.\n    \"\"\"\n\n    response = await super().get_response(path, scope)\n    if response.status_code == 404:\n        response = await super().get_response(\".\", scope)\n\n    return response\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.WSProgressHandler","title":"<code>WSProgressHandler(websocket, client_id)</code>","text":"<p>Handles song updates.</p> <ul> <li>websocket: The WebSocket instance.</li> <li>client_id: The client's ID.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>def __init__(self, websocket: WebSocket, client_id: str):\n\"\"\"\n    Initialize the WebSocket handler.\n    ### Arguments\n    - websocket: The WebSocket instance.\n    - client_id: The client's ID.\n    \"\"\"\n\n    self.websocket = websocket\n    self.client_id = client_id\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.WSProgressHandler.connect","title":"<code>connect()</code>  <code>async</code>","text":"<p>Called when a new client connects to the websocket.</p> Source code in <code>spotdl/utils/web.py</code> <pre><code>async def connect(self):\n\"\"\"\n    Called when a new client connects to the websocket.\n    \"\"\"\n\n    await self.websocket.accept()\n\n    # Add the connection to the list of connections\n    app_state.ws_instances.append(self)\n\n    app_state.logger.info(\"Client %s connected\", self.client_id)\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.WSProgressHandler.get_instance","title":"<code>get_instance(client_id)</code>  <code>classmethod</code>","text":"<p>Get the WebSocket instance for a client.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.WSProgressHandler.get_instance--arguments","title":"Arguments","text":"<ul> <li>client_id: The client's ID.</li> </ul>"},{"location":"reference/utils/web/#spotdl.utils.web.WSProgressHandler.get_instance--returns","title":"Returns","text":"<ul> <li>returns the WebSocket instance.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>@classmethod\ndef get_instance(cls, client_id: str) -&gt; Optional[\"WSProgressHandler\"]:\n\"\"\"\n    Get the WebSocket instance for a client.\n\n    ### Arguments\n    - client_id: The client's ID.\n\n    ### Returns\n    - returns the WebSocket instance.\n    \"\"\"\n\n    for instance in app_state.ws_instances:\n        if instance.client_id == client_id:\n            return instance\n\n    app_state.logger.error(\"Client %s not found\", client_id)\n\n    return None\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.WSProgressHandler.send_update","title":"<code>send_update(update)</code>  <code>async</code>","text":"<p>Send an update to the client.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.WSProgressHandler.send_update--arguments","title":"Arguments","text":"<ul> <li>update: The update to send.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>async def send_update(self, update: Dict[str, Any]):\n\"\"\"\n    Send an update to the client.\n\n    ### Arguments\n    - update: The update to send.\n    \"\"\"\n\n    await self.websocket.send_json(update)\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.WSProgressHandler.song_update","title":"<code>song_update(progress_handler, message)</code>","text":"<p>Called when a song updates.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.WSProgressHandler.song_update--arguments","title":"Arguments","text":"<ul> <li>progress_handler: The progress handler.</li> <li>message: The message to send.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>def song_update(self, progress_handler: SongTracker, message: str):\n\"\"\"\n    Called when a song updates.\n\n    ### Arguments\n    - progress_handler: The progress handler.\n    - message: The message to send.\n    \"\"\"\n\n    update_message = {\n        \"song\": progress_handler.song.json,\n        \"progress\": progress_handler.progress,\n        \"message\": message,\n    }\n\n    asyncio.run_coroutine_threadsafe(\n        self.send_update(update_message), app_state.loop\n    )\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.download_file","title":"<code>download_file(file, client_id)</code>  <code>async</code>","text":"<p>Download file using path.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.download_file--arguments","title":"Arguments","text":"<ul> <li>file: The file path.</li> </ul>"},{"location":"reference/utils/web/#spotdl.utils.web.download_file--returns","title":"Returns","text":"<ul> <li>returns the file response, filename specified to return as attachment.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>@router.get(\"/api/download/file\")\nasync def download_file(file: str, client_id: str) -&gt; FileResponse:\n\"\"\"\n    Download file using path.\n\n    ### Arguments\n    - file: The file path.\n\n    ### Returns\n    - returns the file response, filename specified to return as attachment.\n    \"\"\"\n\n    return FileResponse(\n        str((get_spotdl_path() / f\"web/sessions/{client_id}/{file}\").absolute()),\n        filename=file,\n    )\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.download_url","title":"<code>download_url(url, client_id, state=Depends(get_current_state))</code>  <code>async</code>","text":"<p>Download songs using Song url.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.download_url--arguments","title":"Arguments","text":"<ul> <li>url: The url to download.</li> </ul>"},{"location":"reference/utils/web/#spotdl.utils.web.download_url--returns","title":"Returns","text":"<ul> <li>returns the file path if the song was downloaded.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>@router.post(\"/api/download/url\")\nasync def download_url(\n    url: str, client_id: str, state: ApplicationState = Depends(get_current_state)\n) -&gt; Optional[str]:\n\"\"\"\n    Download songs using Song url.\n\n    ### Arguments\n    - url: The url to download.\n\n    ### Returns\n    - returns the file path if the song was downloaded.\n    \"\"\"\n\n    state.downloader.output = str(\n        (get_spotdl_path() / f\"web/sessions/{client_id}\").absolute()\n    )\n\n    ws_instance = WSProgressHandler.get_instance(client_id)\n    if ws_instance is not None:\n        state.downloader.progress_handler = ProgressHandler(\n            NAME_TO_LEVEL[state.settings[\"log_level\"]],\n            simple_tui=True,\n            update_callback=ws_instance.song_update,\n        )\n\n    try:\n        # Fetch song metadata\n        song = Song.from_url(url)\n\n        # Download Song\n        _, path = await state.downloader.pool_download(song)\n\n        if path is None:\n            state.logger.error(f\"Failure downloading {song.name}\")\n\n            raise HTTPException(\n                status_code=500, detail=f\"Error downloading: {song.name}\"\n            )\n\n        # Strip Filename\n        filename = os.path.basename(path)\n\n        return filename\n\n    except Exception as exception:\n        state.logger.error(f\"Error downloading! {exception}\")\n\n        raise HTTPException(\n            status_code=500, detail=f\"Error downloading: {exception}\"\n        ) from exception\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.fix_mime_types","title":"<code>fix_mime_types()</code>","text":"<p>Fix incorrect entries in the <code>mimetypes</code> registry. On Windows, the Python standard library's <code>mimetypes</code> reads in mappings from file extension to MIME type from the Windows registry. Other applications can and do write incorrect values to this registry, which causes <code>mimetypes.guess_type</code> to return incorrect values, which causes spotDL to fail to render on the frontend. This method hard-codes the correct mappings for certain MIME types that are known to be either used by TensorBoard or problematic in general.</p> Source code in <code>spotdl/utils/web.py</code> <pre><code>def fix_mime_types():\n\"\"\"Fix incorrect entries in the `mimetypes` registry.\n    On Windows, the Python standard library's `mimetypes` reads in\n    mappings from file extension to MIME type from the Windows\n    registry. Other applications can and do write incorrect values\n    to this registry, which causes `mimetypes.guess_type` to return\n    incorrect values, which causes spotDL to fail to render on\n    the frontend.\n    This method hard-codes the correct mappings for certain MIME\n    types that are known to be either used by TensorBoard or\n    problematic in general.\n    \"\"\"\n\n    # Known to be problematic when Visual Studio is installed:\n    # &lt;https://github.com/tensorflow/tensorboard/issues/3120&gt;\n    # https://github.com/spotDL/spotify-downloader/issues/1540\n    mimetypes.add_type(\"application/javascript\", \".js\")\n\n    # Not known to be problematic, but used by spotDL:\n    mimetypes.add_type(\"text/css\", \".css\")\n    mimetypes.add_type(\"image/svg+xml\", \".svg\")\n    mimetypes.add_type(\"text/html\", \".html\")\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.get_current_state","title":"<code>get_current_state()</code>","text":"<p>Get the current state of the application.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.get_current_state--returns","title":"Returns","text":"<ul> <li>returns the application state.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>def get_current_state() -&gt; ApplicationState:\n\"\"\"\n    Get the current state of the application.\n\n    ### Returns\n    - returns the application state.\n    \"\"\"\n\n    return app_state\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.get_settings","title":"<code>get_settings(state=Depends(get_current_state))</code>","text":"<p>Get the settings.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.get_settings--returns","title":"Returns","text":"<ul> <li>returns the settings.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>@router.get(\"/api/settings\")\ndef get_settings(\n    state: ApplicationState = Depends(get_current_state),\n) -&gt; Dict[str, Any]:\n\"\"\"\n    Get the settings.\n\n    ### Returns\n    - returns the settings.\n    \"\"\"\n\n    return state.settings\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.query_search","title":"<code>query_search(query)</code>","text":"<p>Parse search term and return list of Song objects.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.query_search--arguments","title":"Arguments","text":"<ul> <li>query: The query to parse.</li> </ul>"},{"location":"reference/utils/web/#spotdl.utils.web.query_search--returns","title":"Returns","text":"<ul> <li>returns a list of Song objects.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>@router.get(\"/api/songs/search\", response_model=None)\ndef query_search(query: str) -&gt; List[Song]:\n\"\"\"\n    Parse search term and return list of Song objects.\n\n    ### Arguments\n    - query: The query to parse.\n\n    ### Returns\n    - returns a list of Song objects.\n    \"\"\"\n\n    return get_search_results(query)\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.query_search_albums","title":"<code>query_search_albums(query)</code>","text":"<p>Parse search term and return list of Album objects.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.query_search_albums--arguments","title":"Arguments","text":"<ul> <li>query: The query to parse.</li> </ul>"},{"location":"reference/utils/web/#spotdl.utils.web.query_search_albums--returns","title":"Returns","text":"<ul> <li>returns a list of Album objects.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>@router.get(\"/api/albums/search\", response_model=None)\ndef query_search_albums(query: str) -&gt; List[Album]:\n\"\"\"\n    Parse search term and return list of Album objects.\n\n    ### Arguments\n    - query: The query to parse.\n\n    ### Returns\n    - returns a list of Album objects.\n    \"\"\"\n\n    return Album.list_from_search_term(query)\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.song_from_url","title":"<code>song_from_url(url)</code>","text":"<p>Search for a song on spotify using url.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.song_from_url--arguments","title":"Arguments","text":"<ul> <li>url: The url to search.</li> </ul>"},{"location":"reference/utils/web/#spotdl.utils.web.song_from_url--returns","title":"Returns","text":"<ul> <li>returns the first result as a Song object.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>@router.get(\"/api/song/url\", response_model=None)\ndef song_from_url(url: str) -&gt; Song:\n\"\"\"\n    Search for a song on spotify using url.\n\n    ### Arguments\n    - url: The url to search.\n\n    ### Returns\n    - returns the first result as a Song object.\n    \"\"\"\n\n    return Song.from_url(url)\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.update_settings","title":"<code>update_settings(settings, state=Depends(get_current_state))</code>","text":"<p>Change downloader settings by re-initializing the downloader.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.update_settings--arguments","title":"Arguments","text":"<ul> <li>settings: The settings to change.</li> </ul>"},{"location":"reference/utils/web/#spotdl.utils.web.update_settings--returns","title":"Returns","text":"<ul> <li>returns True if the settings were changed.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>@router.post(\"/api/settings/update\")\ndef update_settings(\n    settings: Dict[str, Any], state: ApplicationState = Depends(get_current_state)\n) -&gt; Dict[str, Any]:\n\"\"\"\n    Change downloader settings by re-initializing the downloader.\n\n    ### Arguments\n    - settings: The settings to change.\n\n    ### Returns\n    - returns True if the settings were changed.\n    \"\"\"\n\n    # Create shallow copy of settings\n    settings_cpy = state.settings.copy()\n\n    # Update settings with new settings that are not None\n    settings_cpy.update({k: v for k, v in settings.items() if v is not None})\n\n    state.logger.info(f\"Applying settings: {settings_cpy}\")\n\n    # Re-initialize downloader\n    state.downloader = Downloader(\n        audio_providers=settings_cpy[\"audio_providers\"],\n        lyrics_providers=settings_cpy[\"lyrics_providers\"],\n        ffmpeg=settings_cpy[\"ffmpeg\"],\n        bitrate=settings_cpy[\"bitrate\"],\n        ffmpeg_args=settings_cpy[\"ffmpeg_args\"],\n        output_format=settings_cpy[\"format\"],\n        threads=settings_cpy[\"threads\"],\n        output=settings_cpy[\"output\"],\n        save_file=settings_cpy[\"save_file\"],\n        overwrite=settings_cpy[\"overwrite\"],\n        cookie_file=settings_cpy[\"cookie_file\"],\n        filter_results=settings_cpy[\"filter_results\"],\n        search_query=settings_cpy[\"search_query\"],\n        log_level=settings_cpy[\"log_level\"],\n        simple_tui=True,\n        restrict=settings_cpy[\"restrict\"],\n        print_errors=settings_cpy[\"print_errors\"],\n        sponsor_block=settings_cpy[\"sponsor_block\"],\n        loop=state.loop,\n        preserve_original_audio=settings_cpy[\"preserve_original_audio\"],\n    )\n\n    return settings_cpy\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.websocket_endpoint","title":"<code>websocket_endpoint(websocket, client_id)</code>  <code>async</code>","text":"<p>Websocket endpoint.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.websocket_endpoint--arguments","title":"Arguments","text":"<ul> <li>websocket: The WebSocket instance.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>@router.websocket(\"/api/ws\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n\"\"\"\n    Websocket endpoint.\n    ### Arguments\n    - websocket: The WebSocket instance.\n    \"\"\"\n\n    await WSProgressHandler(websocket, client_id).connect()\n\n    try:\n        while True:\n            await websocket.receive_json()\n    except WebSocketDisconnect:\n        instance = WSProgressHandler.get_instance(client_id)\n        if instance:\n            app_state.ws_instances.remove(instance)\n\n        if (\n            len(app_state.ws_instances) == 0\n            and app_state.settings[\"keep_alive\"] is False\n        ):\n            app_state.logger.debug(\n                \"No active connections, waiting 1s before shutting down\"\n            )\n\n            await asyncio.sleep(1)\n\n            # Wait 5 seconds before shutting down\n            # This is to prevent the server from shutting down when a client\n            # disconnects and reconnects quickly (e.g. when refreshing the page)\n            if len(app_state.ws_instances) == 0:\n                # Perform a clean exit\n                app_state.logger.info(\"Shutting down server, no active connections\")\n                app_state.server.force_exit = True\n                app_state.server.should_exit = True\n                await app_state.server.shutdown()\n</code></pre>"}]}