{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#spotdl-v4","title":"spotDL v4","text":"<p>spotDL finds songs from Spotify playlists on YouTube and downloads them - along with album art, lyrics and metadata.</p> <p> </p> <p>spotDL: The fastest, easiest and most accurate command-line music downloader.</p>"},{"location":"#installation","title":"Installation","text":"<p>Refer to our Installation Guide for more details.</p>"},{"location":"#python-recommended-method","title":"Python (Recommended Method)","text":"<ul> <li>spotDL can be installed by running <code>pip install spotdl</code>.</li> <li>To update spotDL run <code>pip install --upgrade spotdl</code></li> </ul> <p>On some systems you might have to change <code>pip</code> to <code>pip3</code>.</p>"},{"location":"#other-options","title":"Other options","text":"<ul> <li>Prebuilt executable<ul> <li>Download the latest version from the Releases Tab.</li> </ul> </li> <li>On Termux<ul> <li><code>curl -L https://raw.githubusercontent.com/spotDL/spotify-downloader/master/scripts/termux.sh | sh</code></li> </ul> </li> <li>Arch<ul> <li>There is an Arch User Repository (AUR) package for spotDL.</li> </ul> </li> <li> <p>Docker</p> <ul> <li>Build image:</li> </ul> <pre><code>docker build -t spotdl .\n</code></pre> <ul> <li>Launch container with spotDL parameters (see section below). You need to create mapped   volume to access song files</li> </ul> <pre><code>docker run --rm -v $(pwd):/music spotdl download [trackUrl]\n</code></pre> </li> <li> <p>Build from source</p> <pre><code>git clone https://github.com/spotDL/spotify-downloader &amp;&amp; cd spotify-downloader\npip install uv\nuv sync\nuv run scripts/build.py\n</code></pre> <p>An executable is created in <code>spotify-downloader/dist/</code>.</p> </li> </ul>"},{"location":"#installing-ffmpeg","title":"Installing FFmpeg","text":"<p>FFmpeg is required for spotDL. If using FFmpeg only for spotDL, you can simply install FFmpeg to your spotDL installation directory: <code>spotdl --download-ffmpeg</code></p> <p>We recommend the above option, but if you want to install FFmpeg system-wide, follow these instructions</p> <ul> <li>Windows Tutorial</li> <li>OSX - <code>brew install ffmpeg</code></li> <li>Linux - <code>sudo apt install ffmpeg</code> or use your distro's package manager</li> </ul>"},{"location":"#usage","title":"Usage","text":"<p>Using SpotDL without options:</p> <pre><code>spotdl [urls]\n</code></pre> <p>You can run spotDL as a package if running it as a script doesn't work:</p> <pre><code>python -m spotdl [urls]\n</code></pre> <p>General usage:</p> <pre><code>spotdl [operation] [options] QUERY\n</code></pre> <p>There are different operations spotDL can perform. The default is <code>download</code>, which simply downloads the songs from YouTube and embeds metadata.</p> <p>The query for spotDL is usually a list of Spotify URLs, but for some operations like sync, only a single link or file is required. For a list of all options use <code>spotdl -h</code></p>"},{"location":"#refer-to-usage-for-more-info","title":"Refer to Usage for more info.","text":""},{"location":"#music-sourcing-and-audio-quality","title":"Music Sourcing and Audio Quality","text":"<p>spotDL uses YouTube as a source for music downloads. This method is used to avoid any issues related to downloading music from Spotify.</p> <p>Note Users are responsible for their actions and potential legal consequences. We do not support unauthorized downloading of copyrighted material and take no responsibility for user actions.</p>"},{"location":"#audio-quality","title":"Audio Quality","text":"<p>spotDL downloads music from YouTube and is designed to always download the highest possible bitrate; which is 128 kbps for regular users and 256 kbps for YouTube Music premium users.</p> <p>Check the Audio Formats page for more info.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Interested in contributing? Check out our CONTRIBUTING.md to find resources around contributing along with a guide on how to set up a development environment.</p>"},{"location":"#join-our-amazing-community-as-a-code-contributor","title":"Join our amazing community as a code contributor","text":""},{"location":"#license","title":"License","text":"<p>This project is Licensed under the MIT License.</p>"},{"location":"CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes, and learning from   the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address, without their   explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at spotdladmins@googlegroups.com. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"CONTRIBUTING/","title":"Contributing","text":""},{"location":"CONTRIBUTING/#contributing-to-spotdl","title":"Contributing to spotdl","text":"<p>First off, thanks for taking the time to contribute! \u2764\ufe0f</p> <p>All types of contributions are encouraged and valued. See the Table of Contents for different ways to help and details about how this project handles them. Please make sure to read the relevant section before making your contribution. It will make it a lot easier for us maintainers and smooth out the experience for everyone involved. The community looks forward to your contributions. \ud83c\udf89</p> <p>And if you like the project, but just don't have time to contribute, that's fine. There are other easy ways to support the project and show your appreciation, which we would also be very happy about:</p> <ul> <li>Star the project</li> <li>Tweet about it</li> <li>Refer this project in your project's readme</li> <li>Mention the project at local meetups and tell your friends/colleagues</li> </ul>"},{"location":"CONTRIBUTING/#table-of-contents","title":"Table of Contents","text":"<ul> <li>I Have a Question</li> <li>I Want To Contribute</li> <li>Reporting Bugs</li> <li>Suggesting Enhancements</li> <li>Linting, Formatting and Type-checking</li> <li>Python Documentation</li> <li>Overview of the Project Structure</li> <li>Join The Project Team</li> </ul>"},{"location":"CONTRIBUTING/#i-have-a-question","title":"I Have a Question","text":"<p>If you want to ask a question, we assume that you have read the available Documentation.</p> <p>Before you ask a question, it is best to search for existing Issues that might help you. In case you have found a suitable issue and still need clarification, you can write your question in this issue. It is also advisable to search the internet for answers first.</p> <p>If you then still feel the need to ask a question and need clarification, we recommend the following:</p> <ul> <li>Open an Issue.</li> <li>Provide as much context as you can about what you're running into.</li> <li>Provide project and platform versions (nodejs, npm, etc), depending on what seems relevant.</li> </ul> <p>We will then take care of the issue as soon as possible.</p>"},{"location":"CONTRIBUTING/#i-want-to-contribute","title":"I Want To Contribute","text":""},{"location":"CONTRIBUTING/#legal-notice","title":"Legal Notice","text":"<p>When contributing to this project, you must agree that you have authored 100% of the content, that you have the necessary rights to the content and that the content you contribute may be provided under the project license.</p>"},{"location":"CONTRIBUTING/#reporting-bugs","title":"Reporting Bugs","text":""},{"location":"CONTRIBUTING/#before-submitting-a-bug-report","title":"Before Submitting a Bug Report","text":"<p>A good bug report shouldn't leave others needing to chase you up for more information. Therefore, we ask you to investigate carefully, collect information and describe the issue in detail in your report. Please complete the following steps in advance to help us fix any potential bug as fast as possible.</p> <ul> <li>Make sure that you are using the latest version.</li> <li>Determine if your bug is really a bug and not an error on your side e.g. using incompatible   environment components/versions (Make sure that you have read the   documentation. If you are looking for   support, you might want to check this section).</li> <li>To see if other users have experienced (and potentially already solved) the same issue you   are having, check if there is not already a bug report existing for your bug or error in the   bug tracker.</li> <li>Also make sure to search the internet (including Stack Overflow) to see if users outside of   the GitHub community have discussed the issue.</li> <li>Collect information about the bug:</li> <li>Stack trace (Traceback)</li> <li>OS, Platform and Version (Windows, Linux, macOS, x86, ARM)</li> <li>Version of the interpreter, compiler, SDK, runtime environment, package manager, depending on   what seems relevant.</li> <li>Possibly your input and the output</li> <li>Can you reliably reproduce the issue? And can you also reproduce it with older versions?</li> </ul>"},{"location":"CONTRIBUTING/#how-do-i-submit-a-good-bug-report","title":"How Do I Submit a Good Bug Report?","text":"<p>You must never report security related issues, vulnerabilities or bugs to the issue tracker, or elsewhere in public. Instead sensitive bugs must be sent by Discord to Silverarmor (spotDL Discord Owner).</p> <p>We use GitHub issues to track bugs and errors. If you run into an issue with the project:</p> <ul> <li>Open an Issue. (Since we can't be   sure at this point whether it is a bug or not, we ask you not to talk about a bug yet and not   to label the issue.)</li> <li>Explain the behavior you would expect and the actual behavior.</li> <li>Please provide as much context as possible and describe the reproduction steps that someone   else can follow to recreate the issue on their own. This usually includes your code. For good   bug reports you should isolate the problem and create a reduced test case.</li> <li>Provide the information you collected in the previous section.</li> </ul> <p>Once it's filed:</p> <ul> <li>The project team will label the issue accordingly.</li> <li>A team member will try to reproduce the issue with your provided steps. If there are no   reproduction steps or no obvious way to reproduce the issue, the team will ask you for those   steps and mark the issue as <code>needs-repro</code>. Bugs with the <code>needs-repro</code> tag will not be   addressed until they are reproduced.</li> <li>If the team is able to reproduce the issue, it will be marked <code>needs-fix</code>, as well as   possibly other tags (such as <code>critical</code>), and the issue will be left to be   implemented by someone.</li> </ul>"},{"location":"CONTRIBUTING/#suggesting-enhancements","title":"Suggesting Enhancements","text":"<p>This section guides you through submitting an enhancement suggestion for spotdl, including completely new features and minor improvements to existing functionality. Following these guidelines will help maintainers and the community to understand your suggestion and find related suggestions.</p>"},{"location":"CONTRIBUTING/#before-submitting-an-enhancement","title":"Before Submitting an Enhancement","text":"<ul> <li>Make sure that you are using the latest version.</li> <li>Read the documentation carefully and find   out if the functionality is already covered, maybe by an individual configuration.</li> <li>Perform a search to see if the   enhancement has already been suggested. If it has, add a comment to the existing issue   instead of opening a new one.</li> <li>Find out whether your idea fits with the scope and aims of the project. It's up to you to   make a strong case to convince the project's developers of the merits of this feature. Keep   in mind that we want features that will be useful to the majority of our users and not just a   small subset. If you're just targeting a minority of users, consider writing an add-on/plugin   library.</li> </ul>"},{"location":"CONTRIBUTING/#how-do-i-submit-a-good-enhancement-suggestion","title":"How Do I Submit a Good Enhancement Suggestion?","text":"<p>Enhancement suggestions are tracked as GitHub issues.</p> <ul> <li>Use a clear and descriptive title for the issue to identify the suggestion.</li> <li>Provide a step-by-step description of the suggested enhancement in as many details as   possible.</li> <li>Describe the current behavior and explain which behavior you expected to see instead   and why. At this point you can also tell which alternatives do not work for you.</li> <li>You may want to include screenshots and animated GIFs which help you demonstrate the   steps or point out the part which the suggestion is related to. You can use   this tool to record GIFs on macOS and Windows, and   this tool or   this tool on Linux.       </li> <li>Explain why this enhancement would be useful to most spotdl users. You may also want to   point out the other projects that solved it better and which could serve as inspiration.</li> </ul>"},{"location":"CONTRIBUTING/#developing","title":"Developing","text":"<p>Fork the repository on Github and then clone it.</p> <pre><code>git clone [your username]/spotify-downloader\ncd spotify-downloader\n</code></pre> <ul> <li>Install uv</li> </ul> <pre><code>pip install uv\n</code></pre> <ul> <li>Install spotDL in-place</li> </ul> <pre><code>uv sync\n</code></pre> <ul> <li>Activate virtual environment</li> </ul> macOS and LinuxWindows <pre><code>source .venv/bin/activate\n</code></pre> <pre><code>.venv\\Scripts\\activate\n</code></pre> <ul> <li>OR you can prefix all commands with <code>uv run</code></li> </ul> <pre><code>uv run spotdl -h\n</code></pre>"},{"location":"CONTRIBUTING/#linting-formatting-and-type-checking","title":"Linting, Formatting and Type-checking","text":"<ul> <li>We use <code>pylint</code> for linting and expect a score above <code>9</code></li> </ul> <pre><code>pylint --fail-under 10 --limit-inference-results 0 --disable=R0917 ./spotdl\n</code></pre> <ul> <li>We use <code>black</code> for code formatting</li> </ul> <pre><code>black ./spotdl\n</code></pre> <ul> <li>We use <code>mypy</code> for type-checking and expect no errors at all</li> </ul> <p>To install type-stubs the first time around</p> <pre><code>mypy --ignore-missing-imports --follow-imports silent --install-types --non-interactive ./spotdl\n</code></pre> <pre><code>mypy ./spotdl\n</code></pre>"},{"location":"CONTRIBUTING/#python-documentation","title":"Python Documentation","text":"<p>Any submitted code is expected to have accompanying documentation</p>"},{"location":"CONTRIBUTING/#mkdocs-generating-documentation","title":"mkdocs: generating documentation","text":"<ul> <li>We generate our documentation with <code>mkdocs</code></li> </ul> <p>generate docs with</p> <pre><code>mkdocs build --strict\n</code></pre> <p>view docs live-time while editing with</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"CONTRIBUTING/#docstring-formats","title":"DocString Formats","text":"<ul> <li>For functions</li> </ul> <pre><code>one-liner about functions purpose\n\n### Args (optional)\n- arg_name: description\n\n### Returns (optional)\n- return value description\n\n### Errors (only if there are known unhandled Errors/thrown Errors)\n- known errors\n\n### Notes (optional)\n- notes if any\n</code></pre> <ul> <li>For Classes</li> </ul> <pre><code>one-liner about class purpose\n\n### Attributes\n- attribute: description\n\n### Notes (optional)\n- notes if any\n</code></pre> <ul> <li>For modules/package <code>__init__</code></li> </ul> <pre><code>at max 3 lines about module/package purpose\n\noptional usage example for module/package preferably showcasing most commonly used functionality\n</code></pre>"},{"location":"CONTRIBUTING/#notes-about-docstrings","title":"Notes about docstrings","text":"<ul> <li>DocStrings are Inherited</li> </ul> <pre><code>class A:\n    def test(self):\n        \"\"\"Docstring for A.\"\"\"\n        pass\n\nclass B(A):\n    def test(self):\n        pass\n</code></pre>"},{"location":"CONTRIBUTING/#overview-of-the-project-structure","title":"Overview of the Project Structure","text":"sub-package purpose <code>utils</code> Contains commonly used functions <code>types</code> Custom data types used in the spotdl project <code>providers</code> Different Providers to obtain info (like song details) from <code>download</code> Download manager <code>console</code> Different user-facing operations like download, preload and web-ui <code>__init__</code> Contains spotdl class that simplifies the download process"},{"location":"CONTRIBUTING/#join-the-project-team","title":"Join The Project Team","text":""},{"location":"CONTRIBUTING/#attribution","title":"Attribution","text":"<p>This guide is based on the contributing-gen. Make your own!</p>"},{"location":"installation/","title":"spotDL Installation Guide","text":"<p>spotDL is a free and open source tool that downloads your Spotify playlists &amp; music</p> <p>The fastest, easiest, and most accurate command-line music downloader</p>"},{"location":"installation/#install-via-python","title":"Install via Python","text":"<p>This is our recommended installation method.</p> <p>If you are on Windows, Install Visual C++ Redistributable (link below) and then proceed to install Python &amp; FFmpeg</p>"},{"location":"installation/#prerequisites-to-spotdl","title":"Prerequisites to spotDL","text":"<ul> <li>Visual C++ 2019 redistributable   (on Windows)</li> <li>Python 3.7 or above (added to PATH)</li> <li>FFmpeg 4.2 or above (added to PATH)</li> </ul>"},{"location":"installation/#install-python-to-path","title":"Install Python to PATH","text":"<p>We recommend installing the latest version of Python</p> <p>When installing Python, ensure to select \"Add to PATH\".</p> <p></p>"},{"location":"installation/#installing-spotdl","title":"Installing spotDL","text":"<p>If you are not on Windows (e.g. OSX/UNIX), replace <code>pip</code> with <code>pip3</code> and <code>python</code> with <code>python3</code> in all commands.</p> <p>Firstly, open a terminal. On Windows: Command Prompt, OSX: \"Terminal\", *UNIX: Bash or Zsh.</p> <p>Verify you have installed Python correctly via <code>python -V</code>. Ensure you have v3.7 or greater.</p> <p>Next, install spotDL by typing the following</p> <pre><code>pip install spotdl\n</code></pre>"},{"location":"installation/#installing-ffmpeg","title":"Installing FFmpeg","text":"<p>If using FFmpeg only for spotDL, you can install FFmpeg to your local directory. <code>spotdl --download-ffmpeg</code> will download FFmpeg to your spotDL installation directory.</p> <p>We recommend the above option, but if you want to install FFmpeg system-wide,</p> <ul> <li>Windows Tutorial</li> <li>OSX - <code>brew install ffmpeg</code></li> <li>Linux - <code>sudo apt install ffmpeg</code> or use your distro's package manager</li> </ul> <p>If you require further help, ask in our Discord Server</p> <p></p>"},{"location":"installation/#using-prebuilt-executable","title":"Using Prebuilt Executable","text":""},{"location":"installation/#download-the-executable","title":"Download the executable","text":"<p>You can download the latest version from the Releases Tab</p>"},{"location":"installation/#running-web-ui","title":"Running Web UI","text":"<p>Web UI will start by default if no arguments are passed to the command line (after double-clicking for example)</p> <p></p>"},{"location":"installation/#running-the-cli","title":"Running the CLI","text":"<p>To use the command line interface just open your terminal and run <code>./spotdl-vX.X.X operation [urls]</code></p>"},{"location":"installation/#docker-setup","title":"Docker Setup","text":"<p>spotDL provides a Docker image.</p> <p>Install Docker: https://docs.docker.com/engine/installation/</p> <p>Install Docker Compose: https://docs.docker.com/compose/install/</p> <p>Docker documentation: https://docs.docker.com/</p>"},{"location":"installation/#built-in-docker-image","title":"Built-in Docker Image","text":"<ul> <li>Build docker image <code>docker build -t spotdl .</code></li> <li>List spotdl options: <code>docker run --rm spotdl --help</code></li> <li>Download a song:   <code>docker run --rm -v $(pwd):/music spotdl download https://open.spotify.com/track/0VjIjW4GlUZAMYd2vXMi3b</code></li> </ul>"},{"location":"installation/#docker-hub-image","title":"Docker Hub Image","text":"<ul> <li> <p>Pull docker image from Docker hub: <code>docker pull spotdl/spotify-downloader</code></p> </li> <li> <p>Download a song using Docker image:   <code>docker run --rm -v $(pwd):/music spotdl/spotify-downloader download https://open.spotify.com/track/0VjIjW4GlUZAMYd2vXMi3b</code></p> </li> <li> <p>Create a Docker container</p> </li> </ul> <pre><code>docker create \\\n  --name=spotdl \\\n  -v &lt;path to data&gt;:/music \\\n  spotdl/spotify-downloader\n</code></pre>"},{"location":"installation/#docker-compose","title":"Docker Compose","text":"<ul> <li>Create a container using Docker Compose: <code>docker-compose up --no-start</code></li> <li>Download a song using Docker compose:   <code>docker-compose run --rm spotdl download https://open.spotify.com/track/0VjIjW4GlUZAMYd2vXMi3b</code></li> </ul>"},{"location":"installation/#other-installation-methods","title":"Other Installation Methods","text":""},{"location":"installation/#termux","title":"Termux","text":"<p>We have a dedicated Termux installation script <code>curl -L https://raw.githubusercontent.com/spotDL/spotify-downloader/master/scripts/termux.sh | sh</code></p>"},{"location":"installation/#arch-user-repository-aur-package","title":"Arch User Repository (AUR) package","text":"<p>You can find the AUR Package here</p>"},{"location":"installation/#where-does-spotdl-download-songs","title":"Where does spotDL download songs?","text":"<p>spotDL downloads files to the folder where you ran spotDL from.</p> <p>Open pwsh/powershell/cmd/terminal/similar in the folder you want files to download to, or cd to desired folder.</p> <p>Windows Shortcut: Navigate to the folder you want the files to download to. <code>SHIFT + RIGHT CLICK</code>, then select \"Open PowerShell window here\"</p> <p></p>"},{"location":"installation/#we-have-a-public-discord-server-at-discordggxca23pwjwy","title":"We have a public Discord server at discord.gg/xCa23pwJWY!","text":""},{"location":"troubleshooting/","title":"Troubleshooting / FAQ Guide","text":"<p>As common issues or questions are encountered solutions will be added to this guide.</p> 'spotdl' is not recognized <p>Python/(site packages) is not added to PATH correctly. You need to install Python from https://www.python.org/downloads/</p> <p>Or you are using python from microsoft store. If so uninstall it and restart cmd. If this doesn't work reinstall python.</p> spotdl: command not found <p>If you see this error after installing spotdl, that means that the bin (Binaries) folder is not on <code>$PATH</code></p> pkg_resources.DistributionNotFound <p>Sometimes not all packages are installed but are required by yt-dlp for example: <code>brotli</code> or <code>websockets</code></p> HTTP Error 404 <p>https://github.com/plamere/spotipy/issues/795#issuecomment-1100321148</p> ssl.SSLError: [SSL: CERTIFICATE_VERIFY_FAILED] <p>https://stackoverflow.com/questions/27835619/urllib-and-ssl-certificate-verify-failed-error</p> RecursionError <p>https://github.com/spotDL/spotify-downloader/issues/1493</p> RuntimeWarning <p>This happens when running spotdl using <code>python -m</code>.</p> Not found '_raw_ecb.so' <p>This error is specific for M1 Macs only.</p> <p>https://discord.com/channels/771628785447337985/871006150357823498 https://discord.com/channels/771628785447337985/939475659238043738</p>"},{"location":"troubleshooting/#error-message","title":"Error message","text":"<pre><code>'spotdl' is not recognized as an internal or external command,\noperable program or batch file.\n</code></pre>"},{"location":"troubleshooting/#solution","title":"Solution","text":"<p>Ensure to add to PATH when installing: </p>"},{"location":"troubleshooting/#solution_1","title":"Solution","text":""},{"location":"troubleshooting/#bashrc","title":"<code>.bashrc</code>","text":"<p>Add <code>export PATH=~/.local/bin:$PATH</code> at the bottom of <code>~/.bashrc</code></p> <p>Then run <code>source ~/.bashrc</code></p>"},{"location":"troubleshooting/#zshrc","title":"<code>.zshrc</code>","text":"<p>Add <code>export PATH=~/.local/bin:$PATH</code> at the bottom of <code>~/.zshrc</code> Then run <code>source ~/.zshrc</code></p>"},{"location":"troubleshooting/#error-message_1","title":"Error Message","text":"<p><code>pkg_resources.DistributionNotFound: The 'websockets' distribution was not found and is required by yt-dlp</code></p>"},{"location":"troubleshooting/#solution_2","title":"Solution","text":"<p><code>pip install brotli websockets yt-dlp -U</code></p>"},{"location":"troubleshooting/#error-message_2","title":"Error Message","text":"<p><code>HTTP Error for GET to URL with Params: {} returned 404 due to None</code></p>"},{"location":"troubleshooting/#solution_3","title":"Solution","text":"<p>Update spotdl to the latest version which contains workaround.</p> <p><code>pip install -U spotdl</code></p>"},{"location":"troubleshooting/#error-message_3","title":"Error Message","text":"<p><code>urllib.error.URLError: &lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:847)&gt;</code></p>"},{"location":"troubleshooting/#solution_4","title":"Solution","text":"<p>https://stackoverflow.com/questions/27835619/urllib-and-ssl-certificate-verify-failed-error</p>"},{"location":"troubleshooting/#error-message_4","title":"Error Message","text":"<p><code>RecursionError: maximum recursion depth exceeded</code></p>"},{"location":"troubleshooting/#solution_5","title":"Solution","text":"<p>Update spotdl</p> <p><code>pip install spotdl -U</code></p>"},{"location":"troubleshooting/#error-message_5","title":"Error Message","text":"<pre><code>RuntimeWarning: 'spotdl.__main__' found in sys.modules after import of package 'spotdl',\nbut prior to execution of 'spotdl.__main__'; this may result in unpredictable behaviour\nwarn(RuntimeWarning(msg))\n</code></pre>"},{"location":"troubleshooting/#solution_6","title":"Solution","text":"<p>You can ignore this error or just run spotdl directly</p>"},{"location":"troubleshooting/#error-message_6","title":"Error Message","text":"<pre><code>aise OSError(\"Cannot load native module '%s': %s\" % (name, \", \".join(attempts)))\nOSError: Cannot load native module 'Cryptodome.Cipher._raw_ecb': Not found '_raw_ecb.cpython-39-darwin.so',\nCannot load '_raw_ecb.abi3.so': dlopen(/opt/homebrew/lib/python3.9/site-packages/Cryptodome/Util/../Cipher/_raw_ecb.abi3.so, 6): no suitable image found.  Did find:\n/opt/homebrew/lib/python3.9/site-packages/Cryptodome/Util/../Cipher/_raw_ecb.abi3.so: mach-o, but wrong architecture\n/opt/homebrew/lib/python3.9/site-packages/Cryptodome/Cipher/_raw_ecb.abi3.so: mach-o, but wrong architecture, Not found '_raw_ecb.so'\n</code></pre>"},{"location":"troubleshooting/#solution_7","title":"Solution","text":"<p>Possible solutions:</p> <p>https://discord.com/channels/771628785447337985/871006150357823498 https://discord.com/channels/771628785447337985/939475659238043738</p>"},{"location":"usage/","title":"spotDL usage examples","text":""},{"location":"usage/#downloading","title":"Downloading","text":"Song <p>To download a song, run</p> <pre><code>spotdl download [trackUrl]\n</code></pre> <p>example:</p> <pre><code>spotdl download https://open.spotify.com/track/0VjIjW4GlUZAMYd2vXMi3b\n</code></pre> Album <p>To download an album, run</p> <pre><code>spotdl download [albumUrl]\n</code></pre> <p>example:</p> <pre><code>spotdl download https://open.spotify.com/album/4yP0hdKOZPNshxUOjY0cZj\n</code></pre> Playlist <p>To download a playlist, run</p> <pre><code>spotdl download [playlistUrl]\n</code></pre> <p>example:</p> <pre><code>spotdl download https://open.spotify.com/playlist/37i9dQZF1E8UXBoz02kGID\n</code></pre> Artist <p>To download all songs from an artist run</p> <pre><code>spotdl download [artistUrl]\n</code></pre> <p>example:</p> <pre><code>spotdl download https://open.spotify.com/artist/1Xyo4u8uXC1ZmMpatF05PJ\n</code></pre> Search <p>To search for and download a song, run, with quotation marks</p> <pre><code>spotdl download '[songQuery]'\n</code></pre> <p>example:</p> <pre><code>spotdl download 'The Weeknd - Blinding Lights'\n</code></pre> YouTube link with Spotify metadata <p>To download YouTube video with metadata from Spotify, run</p> <p>Noting the quote <code>\"</code> are required</p> <pre><code>spotdl download \"YouTubeURL|SpotifyURL\"\n</code></pre> <p>example:</p> <pre><code>spotdl download \"https://www.youtube.com/watch?v=XXYlFuWEuKI|https://open.spotify.com/track/0VjIjW4GlUZAMYd2vXMi3b?si=b5c0790edc8f4904\"\n</code></pre> Liked songs <p>To download liked Spotify songs run</p> <p><code>--user-auth</code> is required</p> <pre><code>spotdl download saved --user-auth\n</code></pre> All user playlists <p>To download all user playlists run</p> <p><code>--user-auth</code> is required</p> <pre><code>spotdl download all-user-playlists --user-auth\n</code></pre> All user saved albums <p>To download all user saved albums run</p> <p><code>--user-auth</code> is required</p> <pre><code>spotdl download all-user-saved-albums --user-auth\n</code></pre> <p>You can queue up multiple download tasks by separating the arguments with spaces</p> <pre><code>spotdl download [songQuery1] [albumUrl] [songQuery2] ... (order does not matter)\n</code></pre> <p>example:</p> <pre><code>spotdl download 'The Weeknd - Blinding Lights' https://open.spotify.com/playlist/37i9dQZF1E8UXBoz02kGID ...\n</code></pre>"},{"location":"usage/#audio-formats-and-quality","title":"Audio Formats and Quality","text":"<p>Files are downloaded in MP3 format for the best compatibility across different platforms/players, but spotDL also supports other output formats like M4A and OPUS.</p> <p>Note: spotDL never downloads songs in a bitrate higher than 128kbps, except for those with YTMusic Premium, where 256 kbps is available for M4A format.</p> <p>Note that using the <code>--bitrate</code> flag will convert the file to the specified bitrate, so it may result in larger file sizes with no significant change in quality. If you prefer smaller file sizes, consider using the default bitrate or a lower value.</p> <p>Converting files might not be ideal for some users who prefer the files in their original quality.</p> <p>Alternatively, you can use the <code>--bitrate disable</code> option to skip the conversion step for certain file formats such as M4A/OPUS.</p>"},{"location":"usage/#youtube-music-premium","title":"YouTube Music Premium","text":"<p>YouTube Music Premium users can use their account to download songs with a higher bitrate (256kbps).</p> <p>To download music in higher quality follow the steps below:</p> <ol> <li> <p>Change quality in YouTube Music settings to highest possible.</p> </li> <li> <p>Get cookies.txt for https://music.youtube.com.</p> <p>You can use Get cookies.txt extension or cookies.txt for this. More info here</p> </li> <li> <p>Add <code>--cookie-file cookies.txt</code> option to your spotDL command line options</p> <p>Replace cookies.txt with the actual name of your cookies file</p> </li> <li> <p>Change the audio format to either M4A or OPUS to get the raw HQ file</p> </li> </ol> <p>Note To get the best audio possible you should use M4A/OPUS audio format with <code>--bitrate disable</code></p>"},{"location":"usage/#syncing","title":"Syncing","text":"<p>Sync function for the console. Keep local files up to date with playlists/albums/etc. This will download new songs and remove the ones that are no longer present in the playlists/albums/etc</p> Initialize Synchronization <p>To create the sync file run</p> <pre><code>spotdl sync [query] --save-file [fileName]\n</code></pre> <p>Example:</p> <pre><code>spotdl sync https://open.spotify.com/playlist/37i9dQZF1E8UXBoz02kGID --save-file \"the-weeknd.sync.spotdl\"\n</code></pre> <p>Note: The sync file has to end with .spotdl</p> Syncing <p>To sync the songs run</p> <pre><code>spotdl sync [fileName]\n</code></pre> <p>Example:</p> <pre><code>spotdl sync \"the-weeknd.sync.spotdl\"\n</code></pre> <p>You can append <code>--sync-without-deleting</code> if you don't want to remove songs that are no longer present</p> <p>Example:</p> <pre><code>spotdl sync \"the-weeknd.sync.spotdl\" --sync-without-deleting\n</code></pre>"},{"location":"usage/#saving","title":"Saving","text":"<p>Saves the songs metadata to a file for further use.</p> <pre><code>spotdl save [query] --save-file [fileName]\n</code></pre> <p>example:</p> <pre><code>spotdl save 'The Weeknd - Blinding Lights' --save-file 'the-weeknd.spotdl'\n</code></pre> Preloading <p>Preload the download url to speed up the download process.</p> <pre><code>spotdl save [query] --save-file [fileName] --preload\n</code></pre> <p>example:</p> <pre><code>spotdl save 'The Weeknd - Blinding Lights' --save-file 'the-weeknd.spotdl' --preload\n</code></pre>"},{"location":"usage/#web-ui-user-interface","title":"Web UI (User Interface)","text":"<p>To start the web UI, run</p> <pre><code>spotdl web\n</code></pre>"},{"location":"usage/#download-location","title":"Download Location","text":"<p>By default, the web UI downloads files to a special directory, to overwrite this behavior add option <code>--web-use-output-dir</code>, which will make output directory follow <code>--output</code></p>"},{"location":"usage/#config-file","title":"Config file","text":""},{"location":"usage/#config-file-location","title":"Config file location","text":"<p>The config file is located at <code>C:\\Users\\user\\.spotdl\\config.json</code> or <code>~/.spotdl/config.json</code> under linux</p> <p>Note: If you want to use XDG_DATA_HOME directory, run <code>mkdir $XDG_DATA_HOME/spotdl</code>, next time you run spotdl it will be automatically used.</p>"},{"location":"usage/#generate-a-config-file","title":"Generate a config file","text":"<p>To generate a config file, run</p> <pre><code>spotdl --generate-config\n</code></pre> <p>Note: This will overwrite the existing config file.</p>"},{"location":"usage/#loading-config","title":"Loading config","text":"<p>Config file gets loaded automatically if it already exists, or if you've passed <code>--config</code> flag</p> <p>If you don't want config to load automatically change <code>load_config</code> option in config file to false</p> <pre><code>{\n    \"load_config\": false\n}\n</code></pre>"},{"location":"usage/#default-config","title":"Default config","text":"<pre><code>{\n    \"client_id\": \"f8a606e5583643beaa27ce62c48e3fc1\",\n    \"client_secret\": \"f6f4c8f73f0649939286cf417c811607\",\n    \"auth_token\": null,\n    \"user_auth\": false,\n    \"headless\": false,\n    \"cache_path\": \"/Users/username/.spotdl/.spotipy\",\n    \"no_cache\": false,\n    \"max_retries\": 3,\n    \"use_cache_file\": false,\n    \"audio_providers\": [\n        \"youtube-music\"\n    ],\n    \"lyrics_providers\": [\n        \"genius\",\n        \"azlyrics\",\n        \"musixmatch\"\n    ],\n    \"playlist_numbering\": false,\n    \"scan_for_songs\": false,\n    \"m3u\": null,\n    \"output\": \"{artists} - {title}.{output-ext}\",\n    \"overwrite\": \"skip\",\n    \"search_query\": null,\n    \"ffmpeg\": \"ffmpeg\",\n    \"bitrate\": \"128k\",\n    \"ffmpeg_args\": null,\n    \"format\": \"mp3\",\n    \"save_file\": null,\n    \"filter_results\": true,\n    \"album_type\": null,\n    \"threads\": 4,\n    \"cookie_file\": null,\n    \"restrict\": null,\n    \"print_errors\": false,\n    \"sponsor_block\": false,\n    \"preload\": false,\n    \"archive\": null,\n    \"load_config\": true,\n    \"log_level\": \"INFO\",\n    \"simple_tui\": false,\n    \"fetch_albums\": false,\n    \"id3_separator\": \"/\",\n    \"ytm_data\": false,\n    \"add_unavailable\": false,\n    \"generate_lrc\": false,\n    \"force_update_metadata\": false,\n    \"only_verified_results\": false,\n    \"sync_without_deleting\": false,\n    \"max_filename_length\": null,\n    \"yt_dlp_args\": null,\n    \"detect_formats\": null,\n    \"save_errors\": null,\n    \"ignore_albums\": null,\n    \"proxy\": null,\n    \"skip_explicit\": false,\n    \"log_format\": null,\n    \"redownload\": false,\n    \"skip_album_art\": false,\n    \"create_skip_file\": false,\n    \"respect_skip_file\": false,\n    \"web_use_output_dir\": false,\n    \"port\": 8800,\n    \"host\": \"localhost\",\n    \"keep_alive\": false,\n    \"enable_tls\": false,\n    \"key_file\": null,\n    \"cert_file\": null,\n    \"ca_file\": null,\n    \"allowed_origins\": null,\n    \"keep_sessions\": false,\n    \"force_update_gui\": false,\n    \"web_gui_repo\": null,\n    \"web_gui_location\": null\n}\n</code></pre>"},{"location":"usage/#output-variables","title":"<code>output</code> variables","text":"<p>The <code>output</code> key supports several variables:</p> Variable Explanation Example <code>{title}</code> Song title Dark Horse <code>{artists}</code> Song artists Katy Perry, Juicy J <code>{artist}</code> Primary artist Katy Perry <code>{album}</code> Album name PRISM <code>{album-artist}</code> Primary artist of the album Katy Perry <code>{genre}</code> Genre dance pop <code>{disc-number}</code> Useful for multi-disc releases 1 <code>{disc-count}</code> Total number of discs in the album 1 <code>{duration}</code> Duration of the song in seconds 215.672 <code>{year}</code> Year of release 2013 <code>{original-date}</code> Date of original release 2013-01-01 <code>{track-number}</code> Track number in the album 06 <code>{tracks-count}</code> Total number of tracks in the album 13 <code>{isrc}</code> International Standard Recording Code USUM71311296 <code>{track-id}</code> Spotify song ID 4jbmgIyjGoXjY01XxatOx6 <code>{publisher}</code> Record label Capitol Records (CAP) <code>{list-length}</code> Number of items in a playlist 10 <code>{list-position}</code> Position of the song in a playlist 1 <code>{list-name}</code> Name of the playlist Saved <code>{output-ext}</code> File extension mp3"},{"location":"usage/#cli-command-line-interface","title":"CLI (Command Line Interface)","text":""},{"location":"usage/#command-line-options","title":"Command line options","text":"<pre><code>options:\n  -h, --help            show this help message and exit\n\nMain options:\n  {download,save,web,sync,meta,url}\n                        The operation to perform.\n                        download: Download the songs to the disk and embed metadata.\n                        save: Saves the songs metadata to a file for further use.\n                        web: Starts a web interface to simplify the download process.\n                        sync: Removes songs that are no longer present, downloads new ones\n                        meta: Update your audio files with metadata\n                        url: Get the download URL for songs\n\n  query                 Spotify/YouTube URL for a song/playlist/album/artist/etc. to download.\n\n                        For album/playlist/artist searching, include 'album:', 'playlist:', 'artist:'\n                        (ie. 'album:the album name' you can mix these options to get more accurate results).\n\n                        To download liked songs use 'saved' as the query, to download all user playlists\n                        use 'all-user-playlists, to download playlists that the user has created\n                        use 'all-saved-playlists', to download all user liked playlists\n                        use 'all-user-followed-artists', to download all user saved albums use 'all-user-saved-albums'\n\n                        For manual audio matching, you can use the format 'YouTubeURL|SpotifyURL'\n                        You can only use album/playlist/tracks urls when downloading/matching youtube urls.\n                        When using youtube url without spotify url, you won't be able to use `--fetch-albums` option.\n\n  --audio [{youtube,youtube-music,slider-kz,soundcloud,bandcamp,piped} ...]\n                        The audio provider to use. You can provide more than one for fallback.\n  --lyrics [{genius,musixmatch,azlyrics,synced} ...]\n                        The lyrics provider to use. You can provide more than one for fallback. Synced lyrics might not work correctly with some music players. For such cases it's better\n                        to use `--generate-lrc` option.\n  --genius-access-token GENIUS_TOKEN\n                        Lets you choose your own Genius access token.\n  --config              Use the config file to download songs. It's located under C:\\Users\\user\\.spotdl\\config.json or ~/.spotdl/config.json under linux\n  --search-query SEARCH_QUERY\n                        The search query to use, available variables: {title}, {artists}, {artist}, {album}, {album-artist}, {genre}, {disc-number}, {disc-count}, {duration}, {year},\n                        {original-date}, {track-number}, {tracks-count}, {isrc}, {track-id}, {publisher}, {list-length}, {list-position}, {list-name}, {output-ext}\n  --dont-filter-results\n                        Disable filtering results.\n  --album-type {single,album}\n                        Type of the album to search for. (album, single)\n  --only-verified-results\n                        Use only verified results. (Not all providers support this)\n\nSpotify options:\n  --user-auth           Login to Spotify using OAuth.\n  --client-id CLIENT_ID\n                        The client id to use when logging in to Spotify.\n  --client-secret CLIENT_SECRET\n                        The client secret to use when logging in to Spotify.\n  --auth-token AUTH_TOKEN\n                        The authorization token to use directly to log in to Spotify.\n  --cache-path CACHE_PATH\n                        The path where spotipy cache file will be stored.\n  --no-cache            Disable caching (both requests and token).\n  --max-retries MAX_RETRIES\n                        The maximum number of retries to perform when getting metadata.\n  --headless            Run in headless mode.\n  --use-cache-file      Use the cache file to get metadata. It's located under C:\\Users\\user\\.spotdl\\.spotify_cache or ~/.spotdl/.spotify_cache under linux. It only caches tracks and\n                        gets updated whenever spotDL gets metadata from Spotify. (It may provide outdated metadata use with caution)\n\nFFmpeg options:\n  --ffmpeg FFMPEG       The ffmpeg executable to use.\n  --threads THREADS     The number of threads to use when downloading songs.\n  --bitrate {auto,disable,8k,16k,24k,32k,40k,48k,64k,80k,96k,112k,128k,160k,192k,224k,256k,320k,0,1,2,3,4,5,6,7,8,9}\n                        The constant/variable bitrate to use for the output file. Values from 0 to 9 are variable bitrates. Auto will use the bitrate of the original file. Disable will\n                        disable the bitrate option. (In case of m4a and opus files, auto and disable will skip the conversion)\n  --ffmpeg-args FFMPEG_ARGS\n                        Additional ffmpeg arguments passed as a string.\n\nOutput options:\n  --format {mp3,flac,ogg,opus,m4a,wav}\n                        The format to download the song in.\n  --save-file SAVE_FILE\n                        The file to save/load the songs data from/to. It has to end with .spotdl. If combined with the download operation, it will save the songs data to the file.\n                        Required for save/sync (use - to print to stdout when using save).\n  --preload             Preload the download url to speed up the download process.\n  --output OUTPUT       Specify the downloaded file name format, available variables: {title}, {artists}, {artist}, {album}, {album-artist}, {genre}, {disc-number}, {disc-count},\n                        {duration}, {year}, {original-date}, {track-number}, {tracks-count}, {isrc}, {track-id}, {publisher}, {list-length}, {list-position}, {list-name}, {output-ext}\n  --m3u [M3U]           Name of the m3u file to save the songs to. Defaults to {list[0]}.m3u8 If you want to generate a m3u for each list in the query use {list}, If you want to generate\n                        a m3u file based on the first list in the query use {list[0]}, (0 is the first list in the query, 1 is the second, etc. songs don't count towards the list number)\n  --cookie-file COOKIE_FILE\n                        Path to cookies file.\n  --overwrite {skip,metadata,force}\n                        How to handle existing/duplicate files. (When combined with --scan-for-songs force will remove all duplicates, and metadata will only apply metadata to the latest\n                        song and will remove the rest. )\n  --restrict [{strict,ascii,none}]\n                        Restrict filenames to a sanitized set of characters for better compatibility\n  --print-errors        Print errors (wrong songs, failed downloads etc) on exit, useful for long playlist\n  --save-errors SAVE_ERRORS\n                        Save errors (wrong songs, failed downloads etc) to a file\n  --sponsor-block       Use the sponsor block to download songs from yt/ytm.\n  --archive ARCHIVE     Specify the file name for an archive of already downloaded songs\n  --playlist-numbering  Sets each track in a playlist to have the playlist's name as its album, and album art as the playlist's icon\n  --playlist-retain-track-cover\n                        Sets each track in a playlist to have the playlist's name as its album, while retaining album art of each track\n  --scan-for-songs      Scan the output directory for existing files. This option should be combined with the --overwrite option to control how existing files are handled. (Output\n                        directory is the last directory that is not a template variable in the output template)\n  --fetch-albums        Fetch all albums from songs in query\n  --id3-separator ID3_SEPARATOR\n                        Change the separator used in the id3 tags. Only supported for mp3 files.\n  --ytm-data            Use ytm data instead of spotify data when downloading using ytm link.\n  --add-unavailable     Add unavailable songs to the m3u/archive files when downloading\n  --generate-lrc        Generate lrc files for downloaded songs. Requires `synced` provider to be present in the lyrics providers list.\n  --force-update-metadata\n                        Force update metadata for songs that already have metadata.\n  --sync-without-deleting\n                        Sync without deleting songs that are not in the query.\n  --max-filename-length MAX_FILENAME_LENGTH\n                        Max file name length. (This won't override the max file name length enforced by the OS)\n  --yt-dlp-args YT_DLP_ARGS\n                        Arguments to pass to yt-dlp\n  --detect-formats [{mp3,flac,ogg,opus,m4a,wav} ...]\n                        Detect already downloaded songs with file format different from the --format option (When combined with --m3u option, only first detected format will be added to\n                        m3u file)\n  --redownload          to redownload the local song in diffrent format using --format for meta operation\n  --skip-album-art      skip downloading album art for meta operation\n  --ignore-albums [IGNORE_ALBUMS ...]\n                        ignores the song of the given albums\n  --skip-explicit       Skip explicit songs\n  --proxy PROXY         Http(s) proxy server for download song. Example: http://host:port\n  --create-skip-file    Create skip file for successfully downloaded file\n  --respect-skip-file   If a file with the extension .skip exists, skip download\n  --sync-remove-lrc     Remove lrc files when using sync operation when downloading songs\n\nWeb options:\n  --host HOST           The host to use for the web server.\n  --port PORT           The port to run the web server on.\n  --keep-alive          Keep the web server alive even when no clients are connected.\n  --allowed-origins [ALLOWED_ORIGINS ...]\n                        The allowed origins for the web server.\n  --web-use-output-dir  Use the output directory instead of the session directory for downloads. (This might cause issues if you have multiple users using the web-ui at the same time)\n  --keep-sessions       Keep the session directory after the web server is closed.\n  --force-update-gui    Refresh the web server directory with a fresh git checkout\n  --web-gui-repo WEB_GUI_REPO\n                        Custom web gui repo to use for the web server. Example: https://github.com/spotdl/web-ui/tree/master/dist\n  --web-gui-location WEB_GUI_LOCATION\n                        Path to the web gui directory to use for the web server.\n  --enable-tls          Enable TLS on the web server.\n  --cert-file CERT_FILE\n                        File Path to the TLS Certificate (PEM format).\n  --key-file KEY_FILE   File Path to the TLS Private Key (PEM format).\n  --ca-file CA_FILE     File Path to the TLS Certificate Authority File (PEM format).\n\nMisc options:\n  --log-level {CRITICAL,FATAL,ERROR,WARN,WARNING,INFO,MATCH,DEBUG,NOTSET}\n                        Select log level.\n  --simple-tui          Use a simple tui.\n  --log-format LOG_FORMAT\n                        Custom logging format to use. More info: https://docs.python.org/3/library/logging.html#logrecord-attributes\n\nOther options:\n  --download-ffmpeg     Download ffmpeg to spotdl directory.\n  --generate-config     Generate a config file. This will overwrite current config if present.\n  --check-for-updates   Check for new version.\n  --profile             Run in profile mode. Useful for debugging.\n  --version, -v         Show the version number and exit.\n</code></pre>"},{"location":"reference/","title":"__init__","text":"<p>Init module for spotdl. This module contains the main entry point for spotdl. And Spotdl class</p>"},{"location":"reference/#spotdl.Spotdl","title":"<code>Spotdl(client_id, client_secret, user_auth=False, cache_path=None, no_cache=False, headless=False, downloader_settings=None, loop=None)</code>","text":"<p>Spotdl class, which simplifies the process of downloading songs from Spotify.</p> <pre><code>from spotdl import Spotdl\n\nspotdl = Spotdl(client_id='your-client-id', client_secret='your-client-secret')\n\nsongs = spotdl.search(['joji - test drive',\n    'https://open.spotify.com/track/4cOdK2wGLETKBW3PvgPWqT'])\n\nresults = spotdl.download_songs(songs)\nsong, path = spotdl.download(songs[0])\n</code></pre>"},{"location":"reference/#spotdl.Spotdl--arguments","title":"Arguments","text":"<ul> <li>client_id: Spotify client id</li> <li>client_secret: Spotify client secret</li> <li>user_auth: If true, user will be prompted to authenticate</li> <li>cache_path: Path to cache directory</li> <li>no_cache: If true, no cache will be used</li> <li>headless: If true, no browser will be opened</li> <li>downloader_settings: Settings for the downloader</li> <li>loop: Event loop to use</li> </ul> Source code in <code>spotdl/__init__.py</code> <pre><code>def __init__(\n    self,\n    client_id: str,\n    client_secret: str,\n    user_auth: bool = False,\n    cache_path: Optional[str] = None,\n    no_cache: bool = False,\n    headless: bool = False,\n    downloader_settings: Optional[\n        Union[DownloaderOptionalOptions, DownloaderOptions]\n    ] = None,\n    loop: Optional[asyncio.AbstractEventLoop] = None,\n):\n    \"\"\"\n    Initialize the Spotdl class\n\n    ### Arguments\n    - client_id: Spotify client id\n    - client_secret: Spotify client secret\n    - user_auth: If true, user will be prompted to authenticate\n    - cache_path: Path to cache directory\n    - no_cache: If true, no cache will be used\n    - headless: If true, no browser will be opened\n    - downloader_settings: Settings for the downloader\n    - loop: Event loop to use\n    \"\"\"\n\n    if downloader_settings is None:\n        downloader_settings = {}\n\n    # Initialize spotify client\n    SpotifyClient.init(\n        client_id=client_id,\n        client_secret=client_secret,\n        user_auth=user_auth,\n        cache_path=cache_path,\n        no_cache=no_cache,\n        headless=headless,\n    )\n\n    # Initialize downloader\n    self.downloader = Downloader(\n        settings=downloader_settings,\n        loop=loop,\n    )\n</code></pre>"},{"location":"reference/#spotdl.Spotdl.download","title":"<code>download(song)</code>","text":"<p>Download and convert song to the output format.</p>"},{"location":"reference/#spotdl.Spotdl.download--arguments","title":"Arguments","text":"<ul> <li>song: Song object</li> </ul>"},{"location":"reference/#spotdl.Spotdl.download--returns","title":"Returns","text":"<ul> <li>A tuple containing the song and the path to the downloaded file if successful.</li> </ul> Source code in <code>spotdl/__init__.py</code> <pre><code>def download(self, song: Song) -&gt; Tuple[Song, Optional[Path]]:\n    \"\"\"\n    Download and convert song to the output format.\n\n    ### Arguments\n    - song: Song object\n\n    ### Returns\n    - A tuple containing the song and the path to the downloaded file if successful.\n    \"\"\"\n\n    return self.downloader.download_song(song)\n</code></pre>"},{"location":"reference/#spotdl.Spotdl.download_songs","title":"<code>download_songs(songs)</code>","text":"<p>Download and convert songs to the output format.</p>"},{"location":"reference/#spotdl.Spotdl.download_songs--arguments","title":"Arguments","text":"<ul> <li>songs: List of Song objects</li> </ul>"},{"location":"reference/#spotdl.Spotdl.download_songs--returns","title":"Returns","text":"<ul> <li>A list of tuples containing the song and the path to the downloaded file if successful.</li> </ul> Source code in <code>spotdl/__init__.py</code> <pre><code>def download_songs(self, songs: List[Song]) -&gt; List[Tuple[Song, Optional[Path]]]:\n    \"\"\"\n    Download and convert songs to the output format.\n\n    ### Arguments\n    - songs: List of Song objects\n\n    ### Returns\n    - A list of tuples containing the song and the path to the downloaded file if successful.\n    \"\"\"\n\n    return self.downloader.download_multiple_songs(songs)\n</code></pre>"},{"location":"reference/#spotdl.Spotdl.get_download_urls","title":"<code>get_download_urls(songs)</code>","text":"<p>Get the download urls for a list of songs.</p>"},{"location":"reference/#spotdl.Spotdl.get_download_urls--arguments","title":"Arguments","text":"<ul> <li>songs: List of Song objects</li> </ul>"},{"location":"reference/#spotdl.Spotdl.get_download_urls--returns","title":"Returns","text":"<ul> <li>A list of urls if successful.</li> </ul>"},{"location":"reference/#spotdl.Spotdl.get_download_urls--notes","title":"Notes","text":"<ul> <li>This function is multi-threaded.</li> </ul> Source code in <code>spotdl/__init__.py</code> <pre><code>def get_download_urls(self, songs: List[Song]) -&gt; List[Optional[str]]:\n    \"\"\"\n    Get the download urls for a list of songs.\n\n    ### Arguments\n    - songs: List of Song objects\n\n    ### Returns\n    - A list of urls if successful.\n\n    ### Notes\n    - This function is multi-threaded.\n    \"\"\"\n\n    urls: List[Optional[str]] = []\n    with concurrent.futures.ThreadPoolExecutor(\n        max_workers=self.downloader.settings[\"threads\"]\n    ) as executor:\n        future_to_song = {\n            executor.submit(self.downloader.search, song): song for song in songs\n        }\n        for future in concurrent.futures.as_completed(future_to_song):\n            song = future_to_song[future]\n            try:\n                data = future.result()\n                urls.append(data)\n            except Exception as exc:\n                logger.error(\"%s generated an exception: %s\", song, exc)\n\n    return urls\n</code></pre>"},{"location":"reference/#spotdl.Spotdl.search","title":"<code>search(query)</code>","text":"<p>Search for songs.</p>"},{"location":"reference/#spotdl.Spotdl.search--arguments","title":"Arguments","text":"<ul> <li>query: List of search queries</li> </ul>"},{"location":"reference/#spotdl.Spotdl.search--returns","title":"Returns","text":"<ul> <li>A list of Song objects</li> </ul>"},{"location":"reference/#spotdl.Spotdl.search--notes","title":"Notes","text":"<ul> <li>query can be a list of song titles, urls, uris</li> </ul> Source code in <code>spotdl/__init__.py</code> <pre><code>def search(self, query: List[str]) -&gt; List[Song]:\n    \"\"\"\n    Search for songs.\n\n    ### Arguments\n    - query: List of search queries\n\n    ### Returns\n    - A list of Song objects\n\n    ### Notes\n    - query can be a list of song titles, urls, uris\n    \"\"\"\n\n    return parse_query(\n        query=query,\n        threads=self.downloader.settings[\"threads\"],\n        use_ytm_data=self.downloader.settings[\"ytm_data\"],\n        playlist_numbering=self.downloader.settings[\"playlist_numbering\"],\n        album_type=self.downloader.settings[\"album_type\"],\n        playlist_retain_track_cover=self.downloader.settings[\n            \"playlist_retain_track_cover\"\n        ],\n    )\n</code></pre>"},{"location":"reference/#spotdl.console_entry_point","title":"<code>console_entry_point()</code>","text":"<p>Entry point for the console. With profile flag, it runs the code with cProfile.</p> Source code in <code>spotdl/console/entry_point.py</code> <pre><code>def console_entry_point():\n    \"\"\"\n    Entry point for the console. With profile flag, it runs the code with cProfile.\n    \"\"\"\n\n    if \"--profile\" in sys.argv:\n        with cProfile.Profile() as profile:\n            entry_point()\n\n        stats = pstats.Stats(profile)\n        stats.sort_stats(pstats.SortKey.TIME)\n        stats.dump_stats(\"spotdl.profile\")\n    else:\n        entry_point()\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>__init__</li> <li>providers<ul> <li>audio<ul> <li>bandcamp</li> <li>soundcloud</li> <li>piped</li> <li>ytmusic</li> <li>youtube</li> <li>sliderkz</li> <li>base</li> </ul> </li> <li>lyrics<ul> <li>synced</li> <li>musixmatch</li> <li>genius</li> <li>azlyrics</li> <li>base</li> </ul> </li> </ul> </li> <li>console<ul> <li>entry_point</li> <li>download</li> <li>meta</li> <li>url</li> <li>save</li> <li>web</li> <li>sync</li> </ul> </li> <li>download<ul> <li>downloader</li> <li>progress_handler</li> </ul> </li> <li>types<ul> <li>playlist</li> <li>song</li> <li>saved</li> <li>artist</li> <li>result</li> <li>options</li> <li>album</li> </ul> </li> <li>utils<ul> <li>metadata</li> <li>arguments</li> <li>m3u</li> <li>static</li> <li>lrc</li> <li>downloader</li> <li>logging</li> <li>ffmpeg</li> <li>console</li> <li>archive</li> <li>search</li> <li>spotify</li> <li>github</li> <li>web</li> <li>formatter</li> <li>matching</li> <li>config</li> </ul> </li> </ul>"},{"location":"reference/console/","title":"console","text":"<p>Console module, contains the console entry point and different subcommands.</p>"},{"location":"reference/console/#spotdl.console.console_entry_point","title":"<code>console_entry_point()</code>","text":"<p>Entry point for the console. With profile flag, it runs the code with cProfile.</p> Source code in <code>spotdl/console/entry_point.py</code> <pre><code>def console_entry_point():\n    \"\"\"\n    Entry point for the console. With profile flag, it runs the code with cProfile.\n    \"\"\"\n\n    if \"--profile\" in sys.argv:\n        with cProfile.Profile() as profile:\n            entry_point()\n\n        stats = pstats.Stats(profile)\n        stats.sort_stats(pstats.SortKey.TIME)\n        stats.dump_stats(\"spotdl.profile\")\n    else:\n        entry_point()\n</code></pre>"},{"location":"reference/console/download/","title":"download","text":"<p>Download module for the console.</p>"},{"location":"reference/console/download/#spotdl.console.download.download","title":"<code>download(query, downloader)</code>","text":"<p>Find songs with the provided audio provider and save them to the disk.</p>"},{"location":"reference/console/download/#spotdl.console.download.download--arguments","title":"Arguments","text":"<ul> <li>query: list of strings to search for.</li> </ul> Source code in <code>spotdl/console/download.py</code> <pre><code>def download(\n    query: List[str],\n    downloader: Downloader,\n) -&gt; None:\n    \"\"\"\n    Find songs with the provided audio provider and save them to the disk.\n\n    ### Arguments\n    - query: list of strings to search for.\n    \"\"\"\n\n    # Parse the query\n    songs = get_simple_songs(\n        query,\n        use_ytm_data=downloader.settings[\"ytm_data\"],\n        playlist_numbering=downloader.settings[\"playlist_numbering\"],\n        albums_to_ignore=downloader.settings[\"ignore_albums\"],\n        album_type=downloader.settings[\"album_type\"],\n        playlist_retain_track_cover=downloader.settings[\"playlist_retain_track_cover\"],\n    )\n\n    # Download the songs\n    downloader.download_multiple_songs(songs)\n</code></pre>"},{"location":"reference/console/entry_point/","title":"entry_point","text":"<p>Module that holds the entry point for the console.</p>"},{"location":"reference/console/entry_point/#spotdl.console.entry_point.console_entry_point","title":"<code>console_entry_point()</code>","text":"<p>Entry point for the console. With profile flag, it runs the code with cProfile.</p> Source code in <code>spotdl/console/entry_point.py</code> <pre><code>def console_entry_point():\n    \"\"\"\n    Entry point for the console. With profile flag, it runs the code with cProfile.\n    \"\"\"\n\n    if \"--profile\" in sys.argv:\n        with cProfile.Profile() as profile:\n            entry_point()\n\n        stats = pstats.Stats(profile)\n        stats.sort_stats(pstats.SortKey.TIME)\n        stats.dump_stats(\"spotdl.profile\")\n    else:\n        entry_point()\n</code></pre>"},{"location":"reference/console/entry_point/#spotdl.console.entry_point.entry_point","title":"<code>entry_point()</code>","text":"<p>Console entry point for spotdl. This is where the magic happens.</p> Source code in <code>spotdl/console/entry_point.py</code> <pre><code>def entry_point():\n    \"\"\"\n    Console entry point for spotdl. This is where the magic happens.\n    \"\"\"\n\n    # Create config file if it doesn't exist\n    generate_initial_config()\n\n    # Check if sys.argv contains an action\n    # If it does, we run the action and exit\n    try:\n        action_to_run = next(\n            action for action_name, action in ACTIONS.items() if action_name in sys.argv\n        )\n    except StopIteration:\n        action_to_run = None\n\n    if action_to_run:\n        action_to_run()\n        return None\n\n    # Parse the arguments\n    arguments = parse_arguments()\n\n    # Create settings dicts\n    spotify_settings, downloader_settings, web_settings = create_settings(arguments)\n\n    init_logging(downloader_settings[\"log_level\"], downloader_settings[\"log_format\"])\n\n    # If the application is frozen, we check for ffmpeg\n    # if it's not present download it create config file\n    if is_executable():\n        if is_ffmpeg_installed() is False:\n            download_ffmpeg()\n\n    # Check if ffmpeg is installed\n    if is_ffmpeg_installed(downloader_settings[\"ffmpeg\"]) is False:\n        raise FFmpegError(\n            \"FFmpeg is not installed. Please run `spotdl --download-ffmpeg` to install it, \"\n            \"or `spotdl --ffmpeg /path/to/ffmpeg` to specify the path to ffmpeg.\"\n        )\n\n    # Check if we are not blocked by ytm\n    if \"youtube-music\" in downloader_settings[\"audio_providers\"]:\n        if not check_ytmusic_connection():\n            raise DownloaderError(\n                \"You are blocked by YouTube Music. \"\n                \"Please use a VPN, change youtube-music to piped, or use other audio providers\"\n            )\n\n    # Initialize spotify client\n    SpotifyClient.init(**spotify_settings)\n    spotify_client = SpotifyClient()\n\n    # If the application is frozen start web ui\n    # or if the operation is `web`\n    if is_executable() or arguments.operation == \"web\":\n\n        # Default to the current directory when running a frozen application\n        if is_executable():\n            web_settings[\"web_use_output_dir\"] = True\n\n        # Start web ui\n        web(web_settings, downloader_settings)\n\n        return None\n\n    # Check if save file is present and if it's valid\n    if isinstance(downloader_settings[\"save_file\"], str) and (\n        not downloader_settings[\"save_file\"].endswith(\".spotdl\")\n        and not downloader_settings[\"save_file\"] == \"-\"\n    ):\n        raise DownloaderError(\"Save file has to end with .spotdl\")\n\n    # Check if the user is logged in\n    if (\n        arguments.query\n        and \"saved\" in arguments.query\n        and not spotify_settings[\"user_auth\"]\n    ):\n        raise SpotifyError(\n            \"You must be logged in to use the saved query. \"\n            \"Log in by adding the --user-auth flag\"\n        )\n\n    # Initialize the downloader\n    # for download, load and preload operations\n    downloader = Downloader(downloader_settings)\n\n    def graceful_exit(_signal, _frame):\n        if spotify_settings[\"use_cache_file\"]:\n            save_spotify_cache(spotify_client.cache)\n\n        downloader.progress_handler.close()\n        sys.exit(0)\n\n    signal.signal(signal.SIGINT, graceful_exit)\n    signal.signal(signal.SIGTERM, graceful_exit)\n\n    start_time = time.perf_counter()\n\n    try:\n        # Pick the operation to perform\n        # based on the name and run it!\n        OPERATIONS[arguments.operation](\n            query=arguments.query,\n            downloader=downloader,\n        )\n    except Exception as exc:\n        if downloader_settings[\"save_errors\"]:\n            with open(\n                downloader_settings[\"save_errors\"], \"a\", encoding=\"utf-8\"\n            ) as error_file:\n                error_file.write(\"\\n\".join([exc + \"\\n\" for exc in exc.args]))\n\n            logger.debug(\"Saved errors to %s\", downloader_settings[\"save_errors\"])\n\n        end_time = time.perf_counter()\n        logger.debug(\"Took %d seconds\", end_time - start_time)\n\n        downloader.progress_handler.close()\n        logger.exception(\"An error occurred\")\n\n        sys.exit(1)\n\n    end_time = time.perf_counter()\n    logger.debug(\"Took %d seconds\", end_time - start_time)\n\n    if spotify_settings[\"use_cache_file\"]:\n        save_spotify_cache(spotify_client.cache)\n\n    downloader.progress_handler.close()\n\n    return None\n</code></pre>"},{"location":"reference/console/meta/","title":"meta","text":"<p>Sync Lyrics module for the console</p>"},{"location":"reference/console/meta/#spotdl.console.meta.meta","title":"<code>meta(query, downloader)</code>","text":"<p>This function applies metadata to the selected songs based on the file name. If song already has metadata, missing metadata is added</p>"},{"location":"reference/console/meta/#spotdl.console.meta.meta--arguments","title":"Arguments","text":"<ul> <li>query: list of strings to search for.</li> <li>downloader: Already initialized downloader instance.</li> </ul>"},{"location":"reference/console/meta/#spotdl.console.meta.meta--notes","title":"Notes","text":"<ul> <li>This function is multi-threaded.</li> </ul> Source code in <code>spotdl/console/meta.py</code> <pre><code>def meta(query: List[str], downloader: Downloader) -&gt; None:\n    \"\"\"\n    This function applies metadata to the selected songs\n    based on the file name.\n    If song already has metadata, missing metadata is added\n\n    ### Arguments\n    - query: list of strings to search for.\n    - downloader: Already initialized downloader instance.\n\n    ### Notes\n    - This function is multi-threaded.\n    \"\"\"\n\n    # Create a list of all songs from all paths in query\n    paths: List[Path] = []\n    for path in query:\n        test_path = Path(path)\n        if not test_path.exists():\n            logger.error(\"Path does not exist: %s\", path)\n            continue\n\n        if test_path.is_dir():\n            for out_format in FFMPEG_FORMATS:\n                paths.extend(test_path.glob(f\"*.{out_format}\"))\n        elif test_path.is_file():\n            if test_path.suffix.split(\".\")[-1] not in FFMPEG_FORMATS:\n                logger.error(\"File is not a supported audio format: %s\", path)\n                continue\n\n            paths.append(test_path)\n\n    def process_file(file: Path):\n        # metadata of the file, url is present in the file.\n        song_meta = get_file_metadata(file, downloader.settings[\"id3_separator\"])\n\n        # Check if song has metadata\n        # and if it has all the required fields\n        # if it has all of these fields, we can assume that the metadata is correct\n        if song_meta and not downloader.settings[\"force_update_metadata\"]:\n            if (\n                song_meta.get(\"artist\")\n                and song_meta.get(\"artists\")\n                and song_meta.get(\"name\")\n                and song_meta.get(\"lyrics\")\n                and song_meta.get(\"album_art\")\n            ):\n                logger.info(\"Song already has metadata: %s\", file.name)\n                if downloader.settings[\"generate_lrc\"]:\n                    lrc_file = file.with_suffix(\".lrc\")\n                    if lrc_file.exists():\n                        logger.info(\"Lrc file already exists for %s\", file.name)\n                        return None\n\n                    song = Song.from_missing_data(\n                        name=song_meta[\"name\"],\n                        artists=song_meta[\"artists\"],\n                        artist=song_meta[\"artist\"],\n                    )\n\n                    generate_lrc(song, file)\n                    if lrc_file.exists():\n                        logger.info(\"Saved lrc file for %s\", song.display_name)\n                    else:\n                        logger.info(\"Could not find lrc file for %s\", song.display_name)\n\n                return None\n\n        # Same as above\n        if (\n            not song_meta\n            or None\n            in [\n                song_meta.get(\"name\"),\n                song_meta.get(\"album_art\"),\n                song_meta.get(\"artist\"),\n                song_meta.get(\"artists\"),\n                song_meta.get(\"track_number\"),\n            ]\n            or downloader.settings[\"force_update_metadata\"]\n        ):\n            # Song does not have metadata, or it is missing some fields\n            # or we are forcing update of metadata\n            # so we search for it\n            logger.debug(\"Searching metadata for %s\", file.name)\n            search_results = get_search_results(file.stem)\n            if not search_results:\n                logger.error(\"Could not find metadata for %s\", file.name)\n                return None\n\n            song = search_results[0]\n        else:\n            # Song has metadata, so we use it to reinitialize the song object\n            # and fill in the missing metadata\n            try:\n                song = reinit_song(Song.from_missing_data(**song_meta))\n            except QueryError:\n                logger.error(\"Could not find metadata for %s\", file.name)\n                return None\n\n        # Check if the song has lyric\n        # if not use downloader to find lyrics\n        if song_meta is None or song_meta.get(\"lyrics\") is None:\n            logger.debug(\"Fetching lyrics for %s\", song.display_name)\n            song.lyrics = downloader.search_lyrics(song)\n            if song.lyrics:\n                logger.info(\"Found lyrics for song: %s\", song.display_name)\n        else:\n            song.lyrics = song_meta.get(\"lyrics\")\n\n        # Apply metadata to the song\n        embed_metadata(file, song, skip_album_art=downloader.settings[\"skip_album_art\"])\n\n        logger.info(\"Applied metadata to %s\", file.name)\n\n        if downloader.settings[\"generate_lrc\"]:\n            lrc_file = file.with_suffix(\".lrc\")\n            if lrc_file.exists():\n                logger.info(\"Lrc file already exists for %s\", file.name)\n                return None\n\n            generate_lrc(song, file)\n            if lrc_file.exists():\n                logger.info(\"Saved lrc file for %s\", song.display_name)\n            else:\n                logger.info(\"Could not find lrc file for %s\", song.display_name)\n        return None\n\n    async def pool_worker(file_path: Path) -&gt; None:\n        async with downloader.semaphore:\n            # The following function calls blocking code, which would block whole event loop.\n            # Therefore it has to be called in a separate thread via ThreadPoolExecutor. This\n            # is not a problem, since GIL is released for the I/O operations, so it shouldn't\n            # hurt performance.\n            await downloader.loop.run_in_executor(None, process_file, file_path)\n\n    tasks = [pool_worker(path) for path in paths]\n\n    # call all task asynchronously, and wait until all are finished\n    downloader.loop.run_until_complete(asyncio.gather(*tasks))\n\n    # to re-download the local songs\n    if downloader.settings[\"redownload\"]:\n        songs_url: List[str] = []\n        for file in paths:\n            meta_data = get_file_metadata(\n                Path(file), downloader.settings[\"id3_separator\"]\n            )\n            if meta_data and meta_data[\"url\"]:\n                songs_url.append(meta_data[\"url\"])\n\n        songs_list = parse_query(\n            query=songs_url,\n            threads=downloader.settings[\"threads\"],\n            use_ytm_data=downloader.settings[\"ytm_data\"],\n            playlist_numbering=downloader.settings[\"playlist_numbering\"],\n            album_type=downloader.settings[\"album_type\"],\n            playlist_retain_track_cover=downloader.settings[\n                \"playlist_retain_track_cover\"\n            ],\n        )\n\n        downloader.download_multiple_songs(songs_list)\n</code></pre>"},{"location":"reference/console/save/","title":"save","text":"<p>Save module for the console.</p>"},{"location":"reference/console/save/#spotdl.console.save.save","title":"<code>save(query, downloader)</code>","text":"<p>Save metadata from spotify to the disk.</p>"},{"location":"reference/console/save/#spotdl.console.save.save--arguments","title":"Arguments","text":"<ul> <li>query: list of strings to search for.</li> <li>downloader: Already initialized downloader instance.</li> </ul>"},{"location":"reference/console/save/#spotdl.console.save.save--notes","title":"Notes","text":"<ul> <li>This function is multi-threaded.</li> </ul> Source code in <code>spotdl/console/save.py</code> <pre><code>def save(\n    query: List[str],\n    downloader: Downloader,\n) -&gt; None:\n    \"\"\"\n    Save metadata from spotify to the disk.\n\n    ### Arguments\n    - query: list of strings to search for.\n    - downloader: Already initialized downloader instance.\n\n    ### Notes\n    - This function is multi-threaded.\n    \"\"\"\n\n    save_path = downloader.settings[\"save_file\"]\n    m3u_file = downloader.settings[\"m3u\"]\n\n    to_stdout = save_path == \"-\"\n\n    if save_path is None and not to_stdout:\n        raise DownloaderError(\"Save file is not specified\")\n\n    # Parse the query\n    songs = parse_query(\n        query=query,\n        threads=downloader.settings[\"threads\"],\n        use_ytm_data=downloader.settings[\"ytm_data\"],\n        playlist_numbering=downloader.settings[\"playlist_numbering\"],\n        album_type=downloader.settings[\"album_type\"],\n        playlist_retain_track_cover=downloader.settings[\"playlist_retain_track_cover\"],\n    )\n    save_data = [song.json for song in songs]\n\n    def process_song(song: Song):\n        download_url = None\n        if downloader.settings[\"preload\"]:\n            try:\n                download_url = downloader.search(song)\n                if download_url is None:\n                    logger.error(\"Could not find a match for %s\", song.display_name)\n                    return None\n\n                logger.info(\"Found url for %s: %s\", song.display_name, download_url)\n            except Exception as exception:\n                logger.error(\n                    \"%s generated an exception: %s\", song.display_name, exception\n                )\n                return None\n\n        lyrics = None\n        try:\n            lyrics = downloader.search_lyrics(song)\n            if lyrics is None:\n                logger.debug(\n                    \"No lyrics found for %s, lyrics providers: %s\",\n                    song.display_name,\n                    \", \".join(\n                        [lprovider.name for lprovider in downloader.lyrics_providers]\n                    ),\n                )\n        except Exception as exception:\n            logger.debug(\"Could not search for lyrics: %s\", exception)\n\n        return {**song.json, \"download_url\": download_url, \"lyrics\": lyrics}\n\n    async def pool_worker(song: Song):\n        async with downloader.semaphore:\n            # The following function calls blocking code, which would block whole event loop.\n            # Therefore it has to be called in a separate thread via ThreadPoolExecutor. This\n            # is not a problem, since GIL is released for the I/O operations, so it shouldn't\n            # hurt performance.\n            return await downloader.loop.run_in_executor(None, process_song, song)\n\n    tasks = [pool_worker(song) for song in songs]\n\n    # call all task asynchronously, and wait until all are finished\n    save_data = list(downloader.loop.run_until_complete(asyncio.gather(*tasks)))\n\n    if to_stdout:\n        # Print the songs to stdout\n        print(json.dumps(save_data, indent=4, ensure_ascii=False))\n    elif save_path:\n        # Save the songs to a file\n        with open(save_path, \"w\", encoding=\"utf-8\") as save_file:\n            json.dump(save_data, save_file, indent=4, ensure_ascii=False)\n\n    if m3u_file:\n        gen_m3u_files(\n            songs,\n            m3u_file,\n            downloader.settings[\"output\"],\n            downloader.settings[\"format\"],\n            downloader.settings[\"restrict\"],\n            False,\n        )\n\n    if not to_stdout:\n        logger.info(\n            \"Saved %s song%s to %s\",\n            len(save_data),\n            \"s\" if len(save_data) &gt; 1 else \"\",\n            save_path,\n        )\n</code></pre>"},{"location":"reference/console/sync/","title":"sync","text":"<p>Sync module for the console.</p>"},{"location":"reference/console/sync/#spotdl.console.sync.sync","title":"<code>sync(query, downloader)</code>","text":"<p>Sync function for the console. It will download the songs and remove the ones that are no longer present in the playlists/albums/etc</p>"},{"location":"reference/console/sync/#spotdl.console.sync.sync--arguments","title":"Arguments","text":"<ul> <li>query: list of strings to search for.</li> <li>downloader: Already initialized downloader instance.</li> </ul> Source code in <code>spotdl/console/sync.py</code> <pre><code>def sync(\n    query: List[str],\n    downloader: Downloader,\n) -&gt; None:\n    \"\"\"\n    Sync function for the console.\n    It will download the songs and remove the ones that are no longer\n    present in the playlists/albums/etc\n\n\n    ### Arguments\n    - query: list of strings to search for.\n    - downloader: Already initialized downloader instance.\n    \"\"\"\n\n    save_path = downloader.settings[\"save_file\"]\n    downloader.settings[\"save_file\"] = None\n\n    m3u_file = downloader.settings[\"m3u\"]\n    downloader.settings[\"m3u\"] = None\n\n    # Query and save file\n    # Create initial sync file\n    if query and save_path:\n        if any(req for req in query if req.endswith(\".spotdl\")):\n            # If the query contains a .spotdl file, and we are about to create\n            # .spotdl file, raise an error.\n            raise ValueError(\n                \"Cannot create a sync file with a .spotdl file in the query.\"\n            )\n\n        # Parse the query\n        songs_list = parse_query(\n            query=query,\n            threads=downloader.settings[\"threads\"],\n            use_ytm_data=downloader.settings[\"ytm_data\"],\n            playlist_numbering=downloader.settings[\"playlist_numbering\"],\n            album_type=downloader.settings[\"album_type\"],\n            playlist_retain_track_cover=downloader.settings[\n                \"playlist_retain_track_cover\"\n            ],\n        )\n\n        # Create sync file\n        with open(save_path, \"w\", encoding=\"utf-8\") as save_file:\n            json.dump(\n                {\n                    \"type\": \"sync\",\n                    \"query\": query,\n                    \"songs\": [song.json for song in songs_list],\n                },\n                save_file,\n                indent=4,\n                ensure_ascii=False,\n            )\n\n        # Perform initial download\n        downloader.download_multiple_songs(songs_list)\n\n        # Create m3u file\n        if m3u_file:\n            gen_m3u_files(\n                songs_list,\n                m3u_file,\n                downloader.settings[\"output\"],\n                downloader.settings[\"format\"],\n                downloader.settings[\"restrict\"],\n                False,\n            )\n\n        return None\n\n    # If the query is a single file, download it\n    if (  # pylint: disable=R1702\n        len(query) == 1  # pylint: disable=R1702\n        and query[0].endswith(\".spotdl\")  # pylint: disable=R1702\n        and not save_path  # pylint: disable=R1702\n    ):\n        # Load the sync file\n        with open(query[0], \"r\", encoding=\"utf-8\") as sync_file:\n            sync_data = json.load(sync_file)\n\n        # Verify the sync file\n        if (\n            not isinstance(sync_data, dict)\n            or sync_data.get(\"type\") != \"sync\"\n            or sync_data.get(\"songs\") is None\n        ):\n            raise ValueError(\"Sync file is not a valid sync file.\")\n\n        # Parse the query\n        songs_playlist = parse_query(\n            query=sync_data[\"query\"],\n            threads=downloader.settings[\"threads\"],\n            use_ytm_data=downloader.settings[\"ytm_data\"],\n            playlist_numbering=downloader.settings[\"playlist_numbering\"],\n            album_type=downloader.settings[\"album_type\"],\n            playlist_retain_track_cover=downloader.settings[\n                \"playlist_retain_track_cover\"\n            ],\n        )\n\n        # Get the names and URLs of previously downloaded songs from the sync file\n        old_files = []\n        for entry in sync_data[\"songs\"]:\n            file_name = create_file_name(\n                Song.from_dict(entry),\n                downloader.settings[\"output\"],\n                downloader.settings[\"format\"],\n                downloader.settings[\"restrict\"],\n            )\n\n            old_files.append((file_name, entry[\"url\"]))\n\n        new_urls = [song.url for song in songs_playlist]\n\n        # Delete all song files whose URL is no longer part of the latest playlist\n        if not downloader.settings[\"sync_without_deleting\"]:\n            # Rename songs that have \"{list-length}\", \"{list-position}\", \"{list-name}\",\n            # in the output path so that we don't have to download them again,\n            # and to avoid mangling the directory structure.\n            to_rename: List[Tuple[Path, Path]] = []\n            to_delete = []\n            for path, url in old_files:\n                if url not in new_urls:\n                    to_delete.append(path)\n                else:\n                    new_song = songs_playlist[new_urls.index(url)]\n\n                    new_path = create_file_name(\n                        Song.from_dict(new_song.json),\n                        downloader.settings[\"output\"],\n                        downloader.settings[\"format\"],\n                        downloader.settings[\"restrict\"],\n                    )\n\n                    if path != new_path:\n                        to_rename.append((path, new_path))\n\n            # fix later Downloading duplicate songs in the same playlist\n            # will trigger a re-download of the song. To fix this we have to copy the song\n            # to the new location without removing the old one.\n            for old_path, new_path in to_rename:\n                if old_path.exists():\n                    logger.info(\"Renaming %s to %s\", f\"'{old_path}'\", f\"'{new_path}'\")\n                    if new_path.exists():\n                        old_path.unlink()\n                        continue\n\n                    try:\n                        old_path.rename(new_path)\n                    except (PermissionError, OSError) as exc:\n                        logger.debug(\n                            \"Could not rename temp file: %s, error: %s\", old_path, exc\n                        )\n                else:\n                    logger.debug(\"%s does not exist.\", old_path)\n\n                if downloader.settings[\"sync_remove_lrc\"]:\n                    lrc_file = old_path.with_suffix(\".lrc\")\n                    new_lrc_file = new_path.with_suffix(\".lrc\")\n                    if lrc_file.exists():\n                        logger.debug(\n                            \"Renaming lrc %s to %s\",\n                            f\"'{lrc_file}'\",\n                            f\"'{new_lrc_file}'\",\n                        )\n                        try:\n                            lrc_file.rename(new_lrc_file)\n                        except (PermissionError, OSError) as exc:\n                            logger.debug(\n                                \"Could not rename lrc file: %s, error: %s\",\n                                lrc_file,\n                                exc,\n                            )\n                    else:\n                        logger.debug(\"%s does not exist.\", lrc_file)\n\n            for file in to_delete:\n                if file.exists():\n                    logger.info(\"Deleting %s\", file)\n                    try:\n                        file.unlink()\n                    except (PermissionError, OSError) as exc:\n                        logger.debug(\n                            \"Could not remove temp file: %s, error: %s\", file, exc\n                        )\n                else:\n                    logger.debug(\"%s does not exist.\", file)\n\n                if downloader.settings[\"sync_remove_lrc\"]:\n                    lrc_file = file.with_suffix(\".lrc\")\n                    if lrc_file.exists():\n                        logger.debug(\"Deleting lrc %s\", lrc_file)\n                        try:\n                            lrc_file.unlink()\n                        except (PermissionError, OSError) as exc:\n                            logger.debug(\n                                \"Could not remove lrc file: %s, error: %s\",\n                                lrc_file,\n                                exc,\n                            )\n                    else:\n                        logger.debug(\"%s does not exist.\", lrc_file)\n\n            if len(to_delete) == 0:\n                logger.info(\"Nothing to delete...\")\n            else:\n                logger.info(\"%s old songs were deleted.\", len(to_delete))\n\n        if m3u_file:\n            gen_m3u_files(\n                songs_playlist,\n                m3u_file,\n                downloader.settings[\"output\"],\n                downloader.settings[\"format\"],\n                downloader.settings[\"restrict\"],\n                False,\n            )\n\n        # Write the new sync file\n        with open(query[0], \"w\", encoding=\"utf-8\") as save_file:\n            json.dump(\n                {\n                    \"type\": \"sync\",\n                    \"query\": sync_data[\"query\"],\n                    \"songs\": [song.json for song in songs_playlist],\n                },\n                save_file,\n                indent=4,\n                ensure_ascii=False,\n            )\n\n        downloader.download_multiple_songs(songs_playlist)\n\n        return None\n\n    raise ValueError(\n        \"Wrong combination of arguments. \"\n        \"Either provide a query and a save path. Or a single sync file in the query\"\n    )\n</code></pre>"},{"location":"reference/console/url/","title":"url","text":"<p>Url module for the console.</p>"},{"location":"reference/console/url/#spotdl.console.url.url","title":"<code>url(query, downloader)</code>","text":"<p>Print download url for the provided songs.</p>"},{"location":"reference/console/url/#spotdl.console.url.url--arguments","title":"Arguments","text":"<ul> <li>query: list of strings to search for.</li> </ul> Source code in <code>spotdl/console/url.py</code> <pre><code>def url(\n    query: List[str],\n    downloader: Downloader,\n) -&gt; None:\n    \"\"\"\n    Print download url for the provided songs.\n\n    ### Arguments\n    - query: list of strings to search for.\n    \"\"\"\n\n    # Parse the query\n    songs = parse_query(\n        query=query,\n        threads=downloader.settings[\"threads\"],\n        use_ytm_data=downloader.settings[\"ytm_data\"],\n        playlist_numbering=downloader.settings[\"playlist_numbering\"],\n        album_type=downloader.settings[\"album_type\"],\n        playlist_retain_track_cover=downloader.settings[\"playlist_retain_track_cover\"],\n    )\n\n    def process_song(song: Song):\n        try:\n            data = downloader.search(song)\n            if data is None:\n                logger.error(\"Could not find a match for %s\", song.display_name)\n\n                return None\n\n            audio_provider = downloader.audio_providers[0]\n            download_url = audio_provider.get_download_metadata(data)[\"url\"]\n\n            print(download_url)\n        except Exception as exception:\n            logger.error(\"%s generated an exception: %s\", song.display_name, exception)\n\n        return None\n\n    async def pool_worker(song: Song):\n        async with downloader.semaphore:\n            # The following function calls blocking code, which would block whole event loop.\n            # Therefore it has to be called in a separate thread via ThreadPoolExecutor. This\n            # is not a problem, since GIL is released for the I/O operations, so it shouldn't\n            # hurt performance.\n            return await downloader.loop.run_in_executor(None, process_song, song)\n\n    tasks = [pool_worker(song) for song in songs]\n    downloader.loop.run_until_complete(asyncio.gather(*tasks))\n</code></pre>"},{"location":"reference/console/web/","title":"web","text":"<p>Web module for the console.</p>"},{"location":"reference/console/web/#spotdl.console.web.web","title":"<code>web(web_settings, downloader_settings)</code>","text":"<p>Run the web server.</p>"},{"location":"reference/console/web/#spotdl.console.web.web--arguments","title":"Arguments","text":"<ul> <li>web_settings: Web server settings.</li> <li>downloader_settings: Downloader settings.</li> </ul> Source code in <code>spotdl/console/web.py</code> <pre><code>def web(web_settings: WebOptions, downloader_settings: DownloaderOptions):\n    \"\"\"\n    Run the web server.\n\n    ### Arguments\n    - web_settings: Web server settings.\n    - downloader_settings: Downloader settings.\n    \"\"\"\n\n    # Apply the fix for mime types\n    fix_mime_types()\n\n    # Set up the app loggers\n    uvicorn_logger = logging.getLogger(\"uvicorn\")\n    uvicorn_logger.propagate = False\n\n    spotipy_logger = logging.getLogger(\"spotipy\")\n    spotipy_logger.setLevel(logging.NOTSET)\n\n    # Initialize the web server settings\n    app_state.web_settings = web_settings\n    app_state.logger = uvicorn_logger\n\n    # Create the event loop\n    app_state.loop = (\n        asyncio.new_event_loop()\n        if sys.platform != \"win32\"\n        else asyncio.ProactorEventLoop()  # type: ignore\n    )\n\n    downloader_settings[\"simple_tui\"] = True\n\n    # Download web app from GitHub if not already downloaded or force flag set\n    web_app_dir = get_web_ui_path()\n    dist_dir = web_app_dir / \"dist\"\n    if (not dist_dir.exists() or web_settings[\"force_update_gui\"]) and web_settings[\n        \"web_gui_location\"\n    ] is None:\n        if web_settings[\"web_gui_repo\"] is None:\n            gui_repo = \"https://github.com/spotdl/web-ui/tree/master/dist\"\n        else:\n            gui_repo = web_settings[\"web_gui_repo\"]\n\n        logger.info(\"Updating web app from %s\", gui_repo)\n\n        download_github_dir(\n            gui_repo,\n            output_dir=str(web_app_dir),\n        )\n        web_app_dir = Path(os.path.join(web_app_dir, \"dist\")).resolve()\n    elif web_settings[\"web_gui_location\"]:\n        web_app_dir = Path(web_settings[\"web_gui_location\"]).resolve()\n        logger.info(\"Using custom web app location: %s\", web_app_dir)\n    else:\n        logger.info(\n            \"Using cached web app. To update use the `--force-update-gui` flag.\"\n        )\n        web_app_dir = Path(os.path.join(web_app_dir, \"dist\")).resolve()\n\n    app_state.api = FastAPI(\n        title=\"spotDL\",\n        description=\"Download music from Spotify\",\n        version=__version__,\n        dependencies=[Depends(get_current_state)],\n    )\n\n    app_state.api.include_router(router)\n\n    # Add the CORS middleware\n    app_state.api.add_middleware(\n        CORSMiddleware,\n        allow_origins=(\n            ALLOWED_ORIGINS + web_settings[\"allowed_origins\"]\n            if web_settings[\"allowed_origins\"]\n            else ALLOWED_ORIGINS\n        ),\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n\n    # Add the static files\n    app_state.api.mount(\n        \"/\",\n        SPAStaticFiles(directory=web_app_dir, html=True),\n        name=\"static\",\n    )\n    protocol = \"http\"\n    config = Config(\n        app=app_state.api,\n        host=web_settings[\"host\"],\n        port=web_settings[\"port\"],\n        workers=1,\n        log_level=NAME_TO_LEVEL[downloader_settings[\"log_level\"]],\n        loop=app_state.loop,  # type: ignore\n    )\n    if web_settings[\"enable_tls\"]:\n        logger.info(\"Enabeling TLS\")\n        protocol = \"https\"\n        config.ssl_certfile = web_settings[\"cert_file\"]\n        config.ssl_keyfile = web_settings[\"key_file\"]\n        config.ssl_ca_certs = web_settings[\"ca_file\"]\n\n    app_state.server = Server(config)\n\n    app_state.downloader_settings = downloader_settings\n\n    # Open the web browser\n    webbrowser.open(f\"{protocol}://{web_settings['host']}:{web_settings['port']}/\")\n\n    if not web_settings[\"web_use_output_dir\"]:\n        logger.info(\n            \"Files are stored in temporary directory \"\n            \"and will be deleted after the program exits \"\n            \"to save them to current directory permanently \"\n            \"enable the `web_use_output_dir` option \"\n        )\n    else:\n        logger.info(\n            \"Files are stored in current directory \"\n            \"to save them to temporary directory \"\n            \"disable the `web_use_output_dir` option \"\n        )\n\n    logger.info(\"Starting web server \\n\")\n\n    # Start the web server\n    app_state.loop.run_until_complete(app_state.server.serve())\n</code></pre>"},{"location":"reference/download/","title":"download","text":"<p>Download module that holds the downloader and progress handler modules.</p>"},{"location":"reference/download/downloader/","title":"downloader","text":"<p>Downloader module, this is where all the downloading pre/post processing happens etc.</p>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader","title":"<code>Downloader(settings=None, loop=None)</code>","text":"<p>Downloader class, this is where all the downloading pre/post processing happens etc. It handles the downloading/moving songs, multithreading, metadata embedding etc.</p>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader--arguments","title":"Arguments","text":"<ul> <li>settings: The settings to use.</li> <li>loop: The event loop to use.</li> </ul>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader--notes","title":"Notes","text":"<ul> <li><code>search-query</code> uses the same format as <code>output</code>.</li> <li>if <code>audio_provider</code> or <code>lyrics_provider</code> is a list, then if no match is found,     the next provider in the list will be used.</li> </ul> Source code in <code>spotdl/download/downloader.py</code> <pre><code>def __init__(\n    self,\n    settings: Optional[Union[DownloaderOptionalOptions, DownloaderOptions]] = None,\n    loop: Optional[asyncio.AbstractEventLoop] = None,\n):\n    \"\"\"\n    Initialize the Downloader class.\n\n    ### Arguments\n    - settings: The settings to use.\n    - loop: The event loop to use.\n\n    ### Notes\n    - `search-query` uses the same format as `output`.\n    - if `audio_provider` or `lyrics_provider` is a list, then if no match is found,\n        the next provider in the list will be used.\n    \"\"\"\n\n    if settings is None:\n        settings = {}\n\n    # Create settings dictionary, fill in missing values with defaults\n    # from spotdl.types.options.DOWNLOADER_OPTIONS\n    self.settings: DownloaderOptions = DownloaderOptions(\n        **create_settings_type(\n            Namespace(config=False), dict(settings), DOWNLOADER_OPTIONS\n        )  # type: ignore\n    )\n\n    # Handle deprecated values in config file\n    modernize_settings(self.settings)\n    logger.debug(\"Downloader settings: %s\", self.settings)\n\n    # If no audio providers specified, raise an error\n    if len(self.settings[\"audio_providers\"]) == 0:\n        raise DownloaderError(\n            \"No audio providers specified. Please specify at least one.\"\n        )\n\n    # If ffmpeg is the default value and it's not installed\n    # try to use the spotdl's ffmpeg\n    self.ffmpeg = self.settings[\"ffmpeg\"]\n    if self.ffmpeg == \"ffmpeg\" and shutil.which(\"ffmpeg\") is None:\n        ffmpeg_exec = get_ffmpeg_path()\n        if ffmpeg_exec is None:\n            raise DownloaderError(\"ffmpeg is not installed\")\n\n        self.ffmpeg = str(ffmpeg_exec.absolute())\n\n    logger.debug(\"FFmpeg path: %s\", self.ffmpeg)\n\n    self.loop = loop or (\n        asyncio.new_event_loop()\n        if sys.platform != \"win32\"\n        else asyncio.ProactorEventLoop()  # type: ignore\n    )\n\n    if loop is None:\n        asyncio.set_event_loop(self.loop)\n\n    # semaphore is required to limit concurrent asyncio executions\n    self.semaphore = asyncio.Semaphore(self.settings[\"threads\"])\n\n    self.progress_handler = ProgressHandler(self.settings[\"simple_tui\"])\n\n    # Gather already present songs\n    self.scan_formats = self.settings[\"detect_formats\"] or [self.settings[\"format\"]]\n    self.known_songs: Dict[str, List[Path]] = {}\n    if self.settings[\"scan_for_songs\"]:\n        logger.info(\"Scanning for known songs, this might take a while...\")\n        for scan_format in self.scan_formats:\n            logger.debug(\"Scanning for %s files\", scan_format)\n\n            found_files = gather_known_songs(self.settings[\"output\"], scan_format)\n\n            logger.debug(\"Found %s %s files\", len(found_files), scan_format)\n\n            for song_url, song_paths in found_files.items():\n                known_paths = self.known_songs.get(song_url)\n                if known_paths is None:\n                    self.known_songs[song_url] = song_paths\n                else:\n                    self.known_songs[song_url].extend(song_paths)\n\n    logger.debug(\"Found %s known songs\", len(self.known_songs))\n\n    # Initialize lyrics providers\n    self.lyrics_providers: List[LyricsProvider] = []\n    for lyrics_provider in self.settings[\"lyrics_providers\"]:\n        lyrics_class = LYRICS_PROVIDERS.get(lyrics_provider)\n        if lyrics_class is None:\n            raise DownloaderError(f\"Invalid lyrics provider: {lyrics_provider}\")\n        if lyrics_provider == \"genius\":\n            access_token = self.settings.get(\"genius_token\")\n            if not access_token:\n                raise DownloaderError(\"Genius token not found in settings\")\n            self.lyrics_providers.append(Genius(access_token))\n        else:\n            self.lyrics_providers.append(lyrics_class())\n\n    # Initialize audio providers\n    self.audio_providers: List[AudioProvider] = []\n    for audio_provider in self.settings[\"audio_providers\"]:\n        audio_class = AUDIO_PROVIDERS.get(audio_provider)\n        if audio_class is None:\n            raise DownloaderError(f\"Invalid audio provider: {audio_provider}\")\n\n        self.audio_providers.append(\n            audio_class(\n                output_format=self.settings[\"format\"],\n                cookie_file=self.settings[\"cookie_file\"],\n                search_query=self.settings[\"search_query\"],\n                filter_results=self.settings[\"filter_results\"],\n                yt_dlp_args=self.settings[\"yt_dlp_args\"],\n            )\n        )\n\n    # Initialize list of errors\n    self.errors: List[str] = []\n\n    # Initialize proxy server\n    proxy = self.settings[\"proxy\"]\n    proxies = None\n    if proxy:\n        if not re.match(\n            pattern=r\"^(http|https):\\/\\/(?:(\\w+)(?::(\\w+))?@)?((?:\\d{1,3})(?:\\.\\d{1,3}){3})(?::(\\d{1,5}))?$\",  # pylint: disable=C0301\n            string=proxy,\n        ):\n            raise DownloaderError(f\"Invalid proxy server: {proxy}\")\n        proxies = {\"http\": proxy, \"https\": proxy}\n        logger.info(\"Setting proxy server: %s\", proxy)\n\n    GlobalConfig.set_parameter(\"proxies\", proxies)\n\n    # Initialize archive\n    self.url_archive = Archive()\n    if self.settings[\"archive\"]:\n        self.url_archive.load(self.settings[\"archive\"])\n\n    logger.debug(\"Archive: %d urls\", len(self.url_archive))\n\n    logger.debug(\"Downloader initialized\")\n</code></pre>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.download_multiple_songs","title":"<code>download_multiple_songs(songs)</code>","text":"<p>Download multiple songs to the temp directory.</p>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.download_multiple_songs--arguments","title":"Arguments","text":"<ul> <li>songs: The songs to download.</li> </ul>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.download_multiple_songs--returns","title":"Returns","text":"<ul> <li>list of tuples with the song and the path to the downloaded file if successful.</li> </ul> Source code in <code>spotdl/download/downloader.py</code> <pre><code>def download_multiple_songs(\n    self, songs: List[Song]\n) -&gt; List[Tuple[Song, Optional[Path]]]:\n    \"\"\"\n    Download multiple songs to the temp directory.\n\n    ### Arguments\n    - songs: The songs to download.\n\n    ### Returns\n    - list of tuples with the song and the path to the downloaded file if successful.\n    \"\"\"\n\n    if self.settings[\"fetch_albums\"]:\n        albums = set(song.album_id for song in songs if song.album_id is not None)\n        logger.info(\n            \"Fetching %d album%s\", len(albums), \"s\" if len(albums) &gt; 1 else \"\"\n        )\n\n        songs.extend(songs_from_albums(list(albums)))\n\n        # Remove duplicates\n        return_obj = {}\n        for song in songs:\n            return_obj[song.url] = song\n\n        songs = list(return_obj.values())\n\n    logger.debug(\"Downloading %d songs\", len(songs))\n\n    if self.settings[\"archive\"]:\n        songs = [song for song in songs if song.url not in self.url_archive]\n        logger.debug(\"Filtered %d songs with archive\", len(songs))\n\n    self.progress_handler.set_song_count(len(songs))\n\n    # Create tasks list\n    tasks = [self.pool_download(song) for song in songs]\n\n    # Call all task asynchronously, and wait until all are finished\n    results = list(self.loop.run_until_complete(asyncio.gather(*tasks)))\n\n    # Print errors\n    if self.settings[\"print_errors\"]:\n        for error in self.errors:\n            logger.error(error)\n\n    if self.settings[\"save_errors\"]:\n        with open(\n            self.settings[\"save_errors\"], \"a\", encoding=\"utf-8\"\n        ) as error_file:\n            if len(self.errors) &gt; 0:\n                error_file.write(\n                    f\"{datetime.datetime.now().strftime('%Y-%m-%d-%H-%M-%S')}\\n\"\n                )\n            for error in self.errors:\n                error_file.write(f\"{error}\\n\")\n\n        logger.info(\"Saved errors to %s\", self.settings[\"save_errors\"])\n\n    # Save archive\n    if self.settings[\"archive\"]:\n        for result in results:\n            if result[1] or self.settings[\"add_unavailable\"]:\n                self.url_archive.add(result[0].url)\n\n        self.url_archive.save(self.settings[\"archive\"])\n        logger.info(\n            \"Saved archive with %d urls to %s\",\n            len(self.url_archive),\n            self.settings[\"archive\"],\n        )\n\n    # Create m3u playlist\n    if self.settings[\"m3u\"]:\n        song_list = [\n            song\n            for song, path in results\n            if path or self.settings[\"add_unavailable\"]\n        ]\n\n        gen_m3u_files(\n            song_list,\n            self.settings[\"m3u\"],\n            self.settings[\"output\"],\n            self.settings[\"format\"],\n            self.settings[\"restrict\"],\n            False,\n            self.settings[\"detect_formats\"],\n        )\n\n    # Save results to a file\n    if self.settings[\"save_file\"]:\n        with open(self.settings[\"save_file\"], \"w\", encoding=\"utf-8\") as save_file:\n            json.dump([song.json for song, _ in results], save_file, indent=4)\n\n        logger.info(\"Saved results to %s\", self.settings[\"save_file\"])\n\n    return results\n</code></pre>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.download_song","title":"<code>download_song(song)</code>","text":"<p>Download a single song.</p>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.download_song--arguments","title":"Arguments","text":"<ul> <li>song: The song to download.</li> </ul>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.download_song--returns","title":"Returns","text":"<ul> <li>tuple with the song and the path to the downloaded file if successful.</li> </ul> Source code in <code>spotdl/download/downloader.py</code> <pre><code>def download_song(self, song: Song) -&gt; Tuple[Song, Optional[Path]]:\n    \"\"\"\n    Download a single song.\n\n    ### Arguments\n    - song: The song to download.\n\n    ### Returns\n    - tuple with the song and the path to the downloaded file if successful.\n    \"\"\"\n\n    self.progress_handler.set_song_count(1)\n\n    results = self.download_multiple_songs([song])\n\n    return results[0]\n</code></pre>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.pool_download","title":"<code>pool_download(song)</code>  <code>async</code>","text":"<p>Run asynchronous task in a pool to make sure that all processes.</p>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.pool_download--arguments","title":"Arguments","text":"<ul> <li>song: The song to download.</li> </ul>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.pool_download--returns","title":"Returns","text":"<ul> <li>tuple with the song and the path to the downloaded file if successful.</li> </ul>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.pool_download--notes","title":"Notes","text":"<ul> <li>This method calls <code>self.search_and_download</code> in a new thread.</li> </ul> Source code in <code>spotdl/download/downloader.py</code> <pre><code>async def pool_download(self, song: Song) -&gt; Tuple[Song, Optional[Path]]:\n    \"\"\"\n    Run asynchronous task in a pool to make sure that all processes.\n\n    ### Arguments\n    - song: The song to download.\n\n    ### Returns\n    - tuple with the song and the path to the downloaded file if successful.\n\n    ### Notes\n    - This method calls `self.search_and_download` in a new thread.\n    \"\"\"\n\n    # tasks that cannot acquire semaphore will wait here until it's free\n    # only certain amount of tasks can acquire the semaphore at the same time\n    async with self.semaphore:\n        return await self.loop.run_in_executor(None, self.search_and_download, song)\n</code></pre>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search","title":"<code>search(song)</code>","text":"<p>Search for a song using all available providers.</p>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search--arguments","title":"Arguments","text":"<ul> <li>song: The song to search for.</li> </ul>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search--returns","title":"Returns","text":"<ul> <li>tuple with download url and audio provider if successful.</li> </ul> Source code in <code>spotdl/download/downloader.py</code> <pre><code>def search(self, song: Song) -&gt; str:\n    \"\"\"\n    Search for a song using all available providers.\n\n    ### Arguments\n    - song: The song to search for.\n\n    ### Returns\n    - tuple with download url and audio provider if successful.\n    \"\"\"\n\n    for audio_provider in self.audio_providers:\n        url = audio_provider.search(song, self.settings[\"only_verified_results\"])\n        if url:\n            return url\n\n        logger.debug(\"%s failed to find %s\", audio_provider.name, song.display_name)\n\n    raise LookupError(f\"No results found for song: {song.display_name}\")\n</code></pre>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search_and_download","title":"<code>search_and_download(song)</code>","text":"<p>Search for the song and download it.</p>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search_and_download--arguments","title":"Arguments","text":"<ul> <li>song: The song to download.</li> </ul>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search_and_download--returns","title":"Returns","text":"<ul> <li>tuple with the song and the path to the downloaded file if successful.</li> </ul>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search_and_download--notes","title":"Notes","text":"<ul> <li>This function is synchronous.</li> </ul> Source code in <code>spotdl/download/downloader.py</code> <pre><code>def search_and_download(  # pylint: disable=R0911\n    self, song: Song\n) -&gt; Tuple[Song, Optional[Path]]:\n    \"\"\"\n    Search for the song and download it.\n\n    ### Arguments\n    - song: The song to download.\n\n    ### Returns\n    - tuple with the song and the path to the downloaded file if successful.\n\n    ### Notes\n    - This function is synchronous.\n    \"\"\"\n\n    # Check if song has name/artist and url/song_id\n    if not (song.name and (song.artists or song.artist)) and not (\n        song.url or song.song_id\n    ):\n        logger.error(\"Song is missing required fields: %s\", song.display_name)\n        self.errors.append(f\"Song is missing required fields: {song.display_name}\")\n        return song, None\n\n    # Reinitialize the song object if it's missing metadata\n    # Or if we are fetching albums\n    if (\n        (song.name is None and song.url)\n        or self.settings[\"fetch_albums\"]\n        or any(\n            x is None\n            for x in [\n                song.genres,\n                song.disc_count,\n                song.tracks_count,\n                song.track_number,\n                song.album_id,\n                song.album_artist,\n            ]\n        )\n    ):\n        song = reinit_song(song)\n\n    # Create the output file path\n    output_file = create_file_name(\n        song=song,\n        template=self.settings[\"output\"],\n        file_extension=self.settings[\"format\"],\n        restrict=self.settings[\"restrict\"],\n        file_name_length=self.settings[\"max_filename_length\"],\n    )\n\n    if song.explicit is True and self.settings[\"skip_explicit\"] is True:\n        logger.info(\"Skipping explicit song: %s\", song.display_name)\n        return song, None\n\n    # Initialize the progress tracker\n    display_progress_tracker = self.progress_handler.get_new_tracker(song)\n\n    try:\n        # Create the temp folder path\n        temp_folder = get_temp_path()\n\n        # Check if there is an already existing song file, with the same spotify URL in its\n        # metadata, but saved under a different name. If so, save its path.\n        dup_song_paths: List[Path] = self.known_songs.get(song.url, [])\n\n        # Remove files from the list that have the same path as the output file\n        dup_song_paths = [\n            dup_song_path\n            for dup_song_path in dup_song_paths\n            if (dup_song_path.absolute() != output_file.absolute())\n            and dup_song_path.exists()\n        ]\n\n        # Checking if file already exists in all subfolders of output directory\n        file_exists = output_file.exists() or dup_song_paths\n        if not self.settings[\"scan_for_songs\"]:\n            for file_extension in self.scan_formats:\n                ext_path = output_file.with_suffix(f\".{file_extension}\")\n                if ext_path.exists():\n                    dup_song_paths.append(ext_path)\n\n        if dup_song_paths:\n            logger.debug(\n                \"Found duplicate songs for %s at %s\",\n                song.display_name,\n                \", \".join(\n                    [f\"'{str(dup_song_path)}'\" for dup_song_path in dup_song_paths]\n                ),\n            )\n\n        # If the file already exists and we don't want to overwrite it,\n        # we can skip the download\n        if (  # pylint: disable=R1705\n            Path(str(output_file.absolute()) + \".skip\").exists()\n            and self.settings[\"respect_skip_file\"]\n        ):\n            logger.info(\n                \"Skipping %s (skip file found) %s\",\n                song.display_name,\n                \"\",\n            )\n\n            return song, output_file if output_file.exists() else None\n\n        elif file_exists and self.settings[\"overwrite\"] == \"skip\":\n            logger.info(\n                \"Skipping %s (file already exists) %s\",\n                song.display_name,\n                \"(duplicate)\" if dup_song_paths else \"\",\n            )\n\n            display_progress_tracker.notify_download_skip()\n            return song, output_file\n\n        # Don't skip if the file exists and overwrite is set to force\n        if file_exists and self.settings[\"overwrite\"] == \"force\":\n            logger.info(\n                \"Overwriting %s %s\",\n                song.display_name,\n                \" (duplicate)\" if dup_song_paths else \"\",\n            )\n\n            # If the duplicate song path is not None, we can delete the old file\n            for dup_song_path in dup_song_paths:\n                try:\n                    logger.info(\"Removing duplicate file: %s\", dup_song_path)\n\n                    dup_song_path.unlink()\n                except (PermissionError, OSError, Exception) as exc:\n                    logger.debug(\n                        \"Could not remove duplicate file: %s, error: %s\",\n                        dup_song_path,\n                        exc,\n                    )\n\n        # Find song lyrics and add them to the song object\n        try:\n            lyrics = self.search_lyrics(song)\n            if lyrics is None:\n                logger.debug(\n                    \"No lyrics found for %s, lyrics providers: %s\",\n                    song.display_name,\n                    \", \".join(\n                        [lprovider.name for lprovider in self.lyrics_providers]\n                    ),\n                )\n            else:\n                song.lyrics = lyrics\n        except Exception as exc:\n            logger.debug(\"Could not search for lyrics: %s\", exc)\n\n        # If the file already exists and we want to overwrite the metadata,\n        # we can skip the download\n        if file_exists and self.settings[\"overwrite\"] == \"metadata\":\n            most_recent_duplicate: Optional[Path] = None\n            if dup_song_paths:\n                # Get the most recent duplicate song path and remove the rest\n                most_recent_duplicate = max(\n                    dup_song_paths,\n                    key=lambda dup_song_path: dup_song_path.stat().st_mtime\n                    and dup_song_path.suffix == output_file.suffix,\n                )\n\n                # Remove the rest of the duplicate song paths\n                for old_song_path in dup_song_paths:\n                    if most_recent_duplicate == old_song_path:\n                        continue\n\n                    try:\n                        logger.info(\"Removing duplicate file: %s\", old_song_path)\n                        old_song_path.unlink()\n                    except (PermissionError, OSError) as exc:\n                        logger.debug(\n                            \"Could not remove duplicate file: %s, error: %s\",\n                            old_song_path,\n                            exc,\n                        )\n\n                # Move the old file to the new location\n                if (\n                    most_recent_duplicate\n                    and most_recent_duplicate.suffix == output_file.suffix\n                ):\n                    most_recent_duplicate.replace(\n                        output_file.with_suffix(f\".{self.settings['format']}\")\n                    )\n\n            if (\n                most_recent_duplicate\n                and most_recent_duplicate.suffix != output_file.suffix\n            ):\n                logger.info(\n                    \"Could not move duplicate file: %s, different file extension\",\n                    most_recent_duplicate,\n                )\n\n                display_progress_tracker.notify_complete()\n\n                return song, None\n\n            # Update the metadata\n            embed_metadata(\n                output_file=output_file,\n                song=song,\n                skip_album_art=self.settings[\"skip_album_art\"],\n            )\n\n            logger.info(\n                f\"Updated metadata for {song.display_name}\"\n                f\", moved to new location: {output_file}\"\n                if most_recent_duplicate\n                else \"\"\n            )\n\n            display_progress_tracker.notify_complete()\n\n            return song, output_file\n\n        # Create the output directory if it doesn't exist\n        output_file.parent.mkdir(parents=True, exist_ok=True)\n        if song.download_url is None:\n            download_url = self.search(song)\n        else:\n            download_url = song.download_url\n\n        # Initialize audio downloader\n        audio_downloader: Union[AudioProvider, Piped]\n        if self.settings[\"audio_providers\"][0] == \"piped\":\n            audio_downloader = Piped(\n                output_format=self.settings[\"format\"],\n                cookie_file=self.settings[\"cookie_file\"],\n                search_query=self.settings[\"search_query\"],\n                filter_results=self.settings[\"filter_results\"],\n                yt_dlp_args=self.settings[\"yt_dlp_args\"],\n            )\n        else:\n            audio_downloader = AudioProvider(\n                output_format=self.settings[\"format\"],\n                cookie_file=self.settings[\"cookie_file\"],\n                search_query=self.settings[\"search_query\"],\n                filter_results=self.settings[\"filter_results\"],\n                yt_dlp_args=self.settings[\"yt_dlp_args\"],\n            )\n\n        logger.debug(\"Downloading %s using %s\", song.display_name, download_url)\n\n        # Add progress hook to the audio provider\n        audio_downloader.audio_handler.add_progress_hook(\n            display_progress_tracker.yt_dlp_progress_hook\n        )\n\n        download_info = audio_downloader.get_download_metadata(\n            download_url, download=True\n        )\n\n        temp_file = Path(\n            temp_folder / f\"{download_info['id']}.{download_info['ext']}\"\n        )\n\n        if download_info is None:\n            logger.debug(\n                \"No download info found for %s, url: %s\",\n                song.display_name,\n                download_url,\n            )\n\n            raise DownloaderError(\n                f\"yt-dlp failed to get metadata for: {song.name} - {song.artist}\"\n            )\n\n        display_progress_tracker.notify_download_complete()\n\n        # Copy the downloaded file to the output file\n        # if the temp file and output file have the same extension\n        # and the bitrate is set to auto or disable\n        # Don't copy if the audio provider is piped\n        # unless the bitrate is set to disable\n        if (\n            self.settings[\"bitrate\"] in [\"auto\", \"disable\", None]\n            and temp_file.suffix == output_file.suffix\n        ) and not (\n            self.settings[\"audio_providers\"][0] == \"piped\"\n            and self.settings[\"bitrate\"] != \"disable\"\n        ):\n            shutil.move(str(temp_file), output_file)\n            success = True\n            result = None\n        else:\n            if self.settings[\"bitrate\"] in [\"auto\", None]:\n                # Use the bitrate from the download info if it exists\n                # otherwise use `copy`\n                bitrate = (\n                    f\"{int(download_info['abr'])}k\"\n                    if download_info.get(\"abr\")\n                    else \"128k\"\n                )\n            elif self.settings[\"bitrate\"] == \"disable\":\n                bitrate = None\n            else:\n                bitrate = str(self.settings[\"bitrate\"])\n\n            # Convert the downloaded file to the output format\n            success, result = convert(\n                input_file=temp_file,\n                output_file=output_file,\n                ffmpeg=self.ffmpeg,\n                output_format=self.settings[\"format\"],\n                bitrate=bitrate,\n                ffmpeg_args=self.settings[\"ffmpeg_args\"],\n                progress_handler=display_progress_tracker.ffmpeg_progress_hook,\n            )\n\n            if self.settings[\"create_skip_file\"]:\n                with open(\n                    str(output_file) + \".skip\", mode=\"w\", encoding=\"utf-8\"\n                ) as _:\n                    pass\n\n        # Remove the temp file\n        if temp_file.exists():\n            try:\n                temp_file.unlink()\n            except (PermissionError, OSError) as exc:\n                logger.debug(\n                    \"Could not remove temp file: %s, error: %s\", temp_file, exc\n                )\n\n                raise DownloaderError(\n                    f\"Could not remove temp file: {temp_file}, possible duplicate song\"\n                ) from exc\n\n        if not success and result:\n            # If the conversion failed and there is an error message\n            # create a file with the error message\n            # and save it in the errors directory\n            # raise an exception with file path\n            file_name = (\n                get_errors_path()\n                / f\"ffmpeg_error_{datetime.datetime.now().strftime('%Y-%m-%d-%H-%M-%S')}.txt\"\n            )\n\n            error_message = \"\"\n            for key, value in result.items():\n                error_message += f\"### {key}:\\n{str(value).strip()}\\n\\n\"\n\n            with open(file_name, \"w\", encoding=\"utf-8\") as error_path:\n                error_path.write(error_message)\n\n            # Remove the file that failed to convert\n            if output_file.exists():\n                output_file.unlink()\n\n            raise FFmpegError(\n                f\"Failed to convert {song.display_name}, \"\n                f\"you can find error here: {str(file_name.absolute())}\"\n            )\n\n        download_info[\"filepath\"] = str(output_file)\n\n        # Set the song's download url\n        if song.download_url is None:\n            song.download_url = download_url\n\n        display_progress_tracker.notify_conversion_complete()\n\n        # SponsorBlock post processor\n        if self.settings[\"sponsor_block\"]:\n            # Initialize the sponsorblock post processor\n            post_processor = SponsorBlockPP(\n                audio_downloader.audio_handler, SPONSOR_BLOCK_CATEGORIES\n            )\n\n            # Run the post processor to get the sponsor segments\n            _, download_info = post_processor.run(download_info)\n            chapters = download_info[\"sponsorblock_chapters\"]\n\n            # If there are sponsor segments, remove them\n            if len(chapters) &gt; 0:\n                logger.info(\n                    \"Removing %s sponsor segments for %s\",\n                    len(chapters),\n                    song.display_name,\n                )\n\n                # Initialize the modify chapters post processor\n                modify_chapters = ModifyChaptersPP(\n                    downloader=audio_downloader.audio_handler,\n                    remove_sponsor_segments=SPONSOR_BLOCK_CATEGORIES,\n                )\n\n                # Run the post processor to remove the sponsor segments\n                # this returns a list of files to delete\n                files_to_delete, download_info = modify_chapters.run(download_info)\n\n                # Delete the files that were created by the post processor\n                for file_to_delete in files_to_delete:\n                    Path(file_to_delete).unlink()\n\n        try:\n            embed_metadata(\n                output_file,\n                song,\n                id3_separator=self.settings[\"id3_separator\"],\n                skip_album_art=self.settings[\"skip_album_art\"],\n            )\n        except Exception as exception:\n            raise MetadataError(\n                \"Failed to embed metadata to the song\"\n            ) from exception\n\n        if self.settings[\"generate_lrc\"]:\n            generate_lrc(song, output_file)\n\n        display_progress_tracker.notify_complete()\n\n        # Add the song to the known songs\n        self.known_songs.get(song.url, []).append(output_file)\n\n        logger.info('Downloaded \"%s\": %s', song.display_name, song.download_url)\n\n        return song, output_file\n    except (Exception, UnicodeEncodeError) as exception:\n        if isinstance(exception, UnicodeEncodeError):\n            exception_cause = exception\n            exception = DownloaderError(\n                \"You may need to add PYTHONIOENCODING=utf-8 to your environment\"\n            )\n\n            exception.__cause__ = exception_cause\n\n        display_progress_tracker.notify_error(\n            traceback.format_exc(), exception, True\n        )\n        self.errors.append(\n            f\"{song.url} - {exception.__class__.__name__}: {exception}\"\n        )\n        return song, None\n</code></pre>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search_lyrics","title":"<code>search_lyrics(song)</code>","text":"<p>Search for lyrics using all available providers.</p>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search_lyrics--arguments","title":"Arguments","text":"<ul> <li>song: The song to search for.</li> </ul>"},{"location":"reference/download/downloader/#spotdl.download.downloader.Downloader.search_lyrics--returns","title":"Returns","text":"<ul> <li>lyrics if successful else None.</li> </ul> Source code in <code>spotdl/download/downloader.py</code> <pre><code>def search_lyrics(self, song: Song) -&gt; Optional[str]:\n    \"\"\"\n    Search for lyrics using all available providers.\n\n    ### Arguments\n    - song: The song to search for.\n\n    ### Returns\n    - lyrics if successful else None.\n    \"\"\"\n\n    for lyrics_provider in self.lyrics_providers:\n        lyrics = lyrics_provider.get_lyrics(song.name, song.artists)\n        if lyrics:\n            logger.debug(\n                \"Found lyrics for %s on %s\", song.display_name, lyrics_provider.name\n            )\n\n            return lyrics\n\n        logger.debug(\n            \"%s failed to find lyrics for %s\",\n            lyrics_provider.name,\n            song.display_name,\n        )\n\n    return None\n</code></pre>"},{"location":"reference/download/downloader/#spotdl.download.downloader.DownloaderError","title":"<code>DownloaderError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all exceptions related to downloaders.</p>"},{"location":"reference/download/progress_handler/","title":"progress_handler","text":"<p>Module that holds the ProgressHandler class and Song Tracker class.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler","title":"<code>ProgressHandler(simple_tui=False, update_callback=None, web_ui=False)</code>","text":"<p>Class for handling the progress of a download, including the progress bar.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler--arguments","title":"Arguments","text":"<ul> <li>simple_tui: Whether or not to use the simple TUI.</li> <li>update_callback: A callback to call when the progress bar is updated.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def __init__(\n    self,\n    simple_tui: bool = False,\n    update_callback: Optional[Callable[[Any, str], None]] = None,\n    web_ui: bool = False,\n):\n    \"\"\"\n    Initialize the progress handler.\n\n    ### Arguments\n    - simple_tui: Whether or not to use the simple TUI.\n    - update_callback: A callback to call when the progress bar is updated.\n    \"\"\"\n\n    self.songs: List[Song] = []\n    self.song_count: int = 0\n    self.overall_progress = 0\n    self.overall_total = 100\n    self.overall_completed_tasks = 0\n    self.update_callback = update_callback\n    self.previous_overall = self.overall_completed_tasks\n\n    self.simple_tui = simple_tui\n    self.web_ui = web_ui\n    self.quiet = logger.getEffectiveLevel() &lt; 10\n    self.overall_task_id: Optional[TaskID] = None\n\n    if not self.simple_tui:\n        console = get_console()\n\n        self.rich_progress_bar = Progress(\n            SizedTextColumn(\n                \"[white]{task.description}\",\n                overflow=\"ellipsis\",\n                width=int(console.width / 3),\n            ),\n            SizedTextColumn(\n                \"{task.fields[message]}\", width=18, style=\"nonimportant\"\n            ),\n            BarColumn(bar_width=None, finished_style=\"green\"),\n            \"[progress.percentage]{task.percentage:&gt;3.0f}%\",\n            TimeRemainingColumn(),\n            # Normally when you exit the progress context manager (or call stop())\n            # the last refreshed display remains in the terminal with the cursor on\n            # the following line. You can also make the progress display disappear on\n            # exit by setting transient=True on the Progress constructor\n            transient=True,\n        )\n\n        # Basically a wrapper for rich's: with ... as ...\n        self.rich_progress_bar.__enter__()\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.add_song","title":"<code>add_song(song)</code>","text":"<p>Adds a song to the list of songs.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.add_song--arguments","title":"Arguments","text":"<ul> <li>song: The song to add.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def add_song(self, song: Song) -&gt; None:\n    \"\"\"\n    Adds a song to the list of songs.\n\n    ### Arguments\n    - song: The song to add.\n    \"\"\"\n\n    self.songs.append(song)\n    self.set_song_count(len(self.songs))\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.close","title":"<code>close()</code>","text":"<p>Close the Tui Progress Handler.</p> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"\n    Close the Tui Progress Handler.\n    \"\"\"\n\n    if not self.simple_tui:\n        self.rich_progress_bar.stop()\n\n    logging.shutdown()\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.get_new_tracker","title":"<code>get_new_tracker(song)</code>","text":"<p>Get a new progress tracker.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.get_new_tracker--arguments","title":"Arguments","text":"<ul> <li>song: The song to track.</li> </ul>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.get_new_tracker--returns","title":"Returns","text":"<ul> <li>A new progress tracker.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def get_new_tracker(self, song: Song) -&gt; \"SongTracker\":\n    \"\"\"\n    Get a new progress tracker.\n\n    ### Arguments\n    - song: The song to track.\n\n    ### Returns\n    - A new progress tracker.\n    \"\"\"\n\n    return SongTracker(self, song)\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.set_song_count","title":"<code>set_song_count(count)</code>","text":"<p>Set the number of songs to download.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.set_song_count--arguments","title":"Arguments","text":"<ul> <li>count: The number of songs to download.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def set_song_count(self, count: int) -&gt; None:\n    \"\"\"\n    Set the number of songs to download.\n\n    ### Arguments\n    - count: The number of songs to download.\n    \"\"\"\n\n    self.song_count = count\n    self.overall_total = 100 * count\n\n    if not self.simple_tui:\n        if self.song_count &gt; 4:\n            self.overall_task_id = self.rich_progress_bar.add_task(\n                description=\"Total\",\n                message=(\n                    f\"{self.overall_completed_tasks}/{int(self.overall_total / 100)} \"\n                    \"complete\"\n                ),\n                total=self.overall_total,\n                visible=(not self.quiet),\n            )\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.set_songs","title":"<code>set_songs(songs)</code>","text":"<p>Sets the list of songs to be downloaded.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.set_songs--arguments","title":"Arguments","text":"<ul> <li>songs: The list of songs to download.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def set_songs(self, songs: List[Song]) -&gt; None:\n    \"\"\"\n    Sets the list of songs to be downloaded.\n\n    ### Arguments\n    - songs: The list of songs to download.\n    \"\"\"\n\n    self.songs = songs\n    self.set_song_count(len(songs))\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandler.update_overall","title":"<code>update_overall()</code>","text":"<p>Update the overall progress bar.</p> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def update_overall(self) -&gt; None:\n    \"\"\"\n    Update the overall progress bar.\n    \"\"\"\n\n    if not self.simple_tui:\n        # If the overall progress bar exists\n        if self.overall_task_id is not None:\n            self.rich_progress_bar.update(\n                self.overall_task_id,\n                message=f\"{self.overall_completed_tasks}/\"\n                f\"{int(self.overall_total / 100)} \"\n                \"complete\",\n                completed=self.overall_progress,\n            )\n    else:\n        if self.previous_overall != self.overall_completed_tasks:\n            logger.info(\n                \"%s/%s complete\", self.overall_completed_tasks, self.song_count\n            )\n            self.previous_overall = self.overall_completed_tasks\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.ProgressHandlerError","title":"<code>ProgressHandlerError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all exceptions raised by ProgressHandler subclasses.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SizedTextColumn","title":"<code>SizedTextColumn(text_format, style='none', justify='left', markup=True, highlighter=None, overflow=None, width=20)</code>","text":"<p>               Bases: <code>ProgressColumn</code></p> <p>Custom sized text column based on the Rich library.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SizedTextColumn--arguments","title":"Arguments","text":"<ul> <li>text_format: The format string to use for the text.</li> <li>style: The style to use for the text.</li> <li>justify: The justification to use for the text.</li> <li>markup: Whether or not the text should be rendered as markup.</li> <li>highlighter: A Highlighter to use for highlighting the text.</li> <li>overflow: The overflow method to use for truncating the text.</li> <li>width: The maximum width of the text.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def __init__(\n    self,\n    text_format: str,\n    style: StyleType = \"none\",\n    justify: JustifyMethod = \"left\",\n    markup: bool = True,\n    highlighter: Optional[Highlighter] = None,\n    overflow: Optional[OverflowMethod] = None,\n    width: int = 20,\n) -&gt; None:\n    \"\"\"\n    A column containing text.\n\n    ### Arguments\n    - text_format: The format string to use for the text.\n    - style: The style to use for the text.\n    - justify: The justification to use for the text.\n    - markup: Whether or not the text should be rendered as markup.\n    - highlighter: A Highlighter to use for highlighting the text.\n    - overflow: The overflow method to use for truncating the text.\n    - width: The maximum width of the text.\n    \"\"\"\n\n    self.text_format = text_format\n    self.justify: JustifyMethod = justify\n    self.style = style\n    self.markup = markup\n    self.highlighter = highlighter\n    self.overflow: Optional[OverflowMethod] = overflow\n    self.width = width\n    super().__init__()\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SizedTextColumn.render","title":"<code>render(task)</code>","text":"<p>Render the Column.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SizedTextColumn.render--arguments","title":"Arguments","text":"<ul> <li>task: The Task to render.</li> </ul>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SizedTextColumn.render--returns","title":"Returns","text":"<ul> <li>A Text object.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def render(self, task: Task) -&gt; Text:\n    \"\"\"\n    Render the Column.\n\n    ### Arguments\n    - task: The Task to render.\n\n    ### Returns\n    - A Text object.\n    \"\"\"\n\n    _text = self.text_format.format(task=task)\n    if self.markup:\n        text = Text.from_markup(_text, style=self.style, justify=self.justify)\n    else:\n        text = Text(_text, style=self.style, justify=self.justify)\n    if self.highlighter:\n        self.highlighter.highlight(text)\n\n    text.truncate(max_width=self.width, overflow=self.overflow, pad=True)\n    return text\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker","title":"<code>SongTracker(parent, song)</code>","text":"<p>Class to track the progress of a song.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker--arguments","title":"Arguments","text":"<ul> <li>parent: The parent Tui Progress Handler.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def __init__(self, parent, song: Song) -&gt; None:\n    \"\"\"\n    Initialize the Tui Song Tracker.\n\n    ### Arguments\n    - parent: The parent Tui Progress Handler.\n    \"\"\"\n\n    self.parent: \"ProgressHandler\" = parent\n    self.song = song\n\n    # Clean up the song name\n    # from weird unicode characters\n    self.song_name = \"\".join(\n        char\n        for char in self.song.display_name\n        if char not in [chr(i) for i in BAD_CHARS]\n    )\n\n    self.progress: int = 0\n    self.old_progress: int = 0\n    self.status = \"\"\n\n    if not self.parent.simple_tui:\n        self.task_id = self.parent.rich_progress_bar.add_task(\n            description=escape(self.song_name),\n            message=\"Processing\",\n            total=100,\n            completed=self.progress,\n            start=False,\n            visible=(not self.parent.quiet),\n        )\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.ffmpeg_progress_hook","title":"<code>ffmpeg_progress_hook(progress)</code>","text":"<p>Updates the progress.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.ffmpeg_progress_hook--arguments","title":"Arguments","text":"<ul> <li>progress: The progress to update to.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def ffmpeg_progress_hook(self, progress: int) -&gt; None:\n    \"\"\"\n    Updates the progress.\n\n    ### Arguments\n    - progress: The progress to update to.\n    \"\"\"\n\n    if self.parent.simple_tui and not self.parent.web_ui:\n        self.progress = 50\n    else:\n        self.progress = 50 + int(progress * 0.45)\n\n    self.update(\"Converting\")\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_complete","title":"<code>notify_complete(status='Done')</code>","text":"<p>Notifies the progress handler that the song has been downloaded and converted.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_complete--arguments","title":"Arguments","text":"<ul> <li>status: The status to display.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def notify_complete(self, status=\"Done\") -&gt; None:\n    \"\"\"\n    Notifies the progress handler that the song has been downloaded and converted.\n\n    ### Arguments\n    - status: The status to display.\n    \"\"\"\n\n    self.progress = 100\n    self.update(status)\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_conversion_complete","title":"<code>notify_conversion_complete(status='Embedding metadata')</code>","text":"<p>Notifies the progress handler that the song has been converted.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_conversion_complete--arguments","title":"Arguments","text":"<ul> <li>status: The status to display.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def notify_conversion_complete(self, status=\"Embedding metadata\") -&gt; None:\n    \"\"\"\n    Notifies the progress handler that the song has been converted.\n\n    ### Arguments\n    - status: The status to display.\n    \"\"\"\n\n    self.progress = 95\n    self.update(status)\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_download_complete","title":"<code>notify_download_complete(status='Converting')</code>","text":"<p>Notifies the progress handler that the song has been downloaded.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_download_complete--arguments","title":"Arguments","text":"<ul> <li>status: The status to display.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def notify_download_complete(self, status=\"Converting\") -&gt; None:\n    \"\"\"\n    Notifies the progress handler that the song has been downloaded.\n\n    ### Arguments\n    - status: The status to display.\n    \"\"\"\n\n    self.progress = 50\n    self.update(status)\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_download_skip","title":"<code>notify_download_skip(status='Skipped')</code>","text":"<p>Notifies the progress handler that the song has been skipped.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_download_skip--arguments","title":"Arguments","text":"<ul> <li>status: The status to display.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def notify_download_skip(self, status=\"Skipped\") -&gt; None:\n    \"\"\"\n    Notifies the progress handler that the song has been skipped.\n\n    ### Arguments\n    - status: The status to display.\n    \"\"\"\n\n    self.progress = 100\n    self.update(status)\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_error","title":"<code>notify_error(message, traceback, finish=False)</code>","text":"<p>Logs an error message.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.notify_error--arguments","title":"Arguments","text":"<ul> <li>message: The message to log.</li> <li>traceback: The traceback of the error.</li> <li>finish: Whether to finish the task.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def notify_error(\n    self, message: str, traceback: Exception, finish: bool = False\n) -&gt; None:\n    \"\"\"\n    Logs an error message.\n\n    ### Arguments\n    - message: The message to log.\n    - traceback: The traceback of the error.\n    - finish: Whether to finish the task.\n    \"\"\"\n\n    self.update(\"Error\")\n    if finish:\n        self.progress = 100\n\n    if logger.getEffectiveLevel() == logging.DEBUG:\n        logger.exception(message)\n    else:\n        logger.error(\"%s: %s\", traceback.__class__.__name__, traceback)\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.update","title":"<code>update(message='')</code>","text":"<p>Called at every event.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.update--arguments","title":"Arguments","text":"<ul> <li>message: The message to display.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def update(self, message=\"\"):\n    \"\"\"\n    Called at every event.\n\n    ### Arguments\n    - message: The message to display.\n    \"\"\"\n\n    old_message = self.status\n    self.status = message\n\n    # The change in progress since last update\n    delta = self.progress - self.old_progress\n\n    if not self.parent.simple_tui:\n        # Update the progress bar\n        # `start_task` called everytime to ensure progress is remove from indeterminate state\n        self.parent.rich_progress_bar.start_task(self.task_id)\n        self.parent.rich_progress_bar.update(\n            self.task_id,\n            description=escape(self.song_name),\n            message=message,\n            completed=self.progress,\n        )\n\n        # If task is complete\n        if self.progress == 100 or message == \"Error\":\n            self.parent.overall_completed_tasks += 1\n            self.parent.rich_progress_bar.remove_task(self.task_id)\n    else:\n        # If task is complete\n        if self.progress == 100 or message == \"Error\":\n            self.parent.overall_completed_tasks += 1\n\n        # When running web ui print progress\n        # only one time when downloading/converting/embedding\n        if self.parent.web_ui and old_message != self.status:\n            logger.info(\"%s: %s\", self.song_name, message)\n        elif not self.parent.web_ui and delta:\n            logger.info(\"%s: %s\", self.song_name, message)\n\n    # Update the overall progress bar\n    if self.parent.song_count == self.parent.overall_completed_tasks:\n        self.parent.overall_progress = self.parent.song_count * 100\n    else:\n        self.parent.overall_progress += delta\n\n    self.parent.update_overall()\n    self.old_progress = self.progress\n\n    if self.parent.update_callback:\n        self.parent.update_callback(self, message)\n</code></pre>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.yt_dlp_progress_hook","title":"<code>yt_dlp_progress_hook(data)</code>","text":"<p>Updates the progress.</p>"},{"location":"reference/download/progress_handler/#spotdl.download.progress_handler.SongTracker.yt_dlp_progress_hook--arguments","title":"Arguments","text":"<ul> <li>progress: The progress to update to.</li> </ul> Source code in <code>spotdl/download/progress_handler.py</code> <pre><code>def yt_dlp_progress_hook(self, data: Dict[str, Any]) -&gt; None:\n    \"\"\"\n    Updates the progress.\n\n    ### Arguments\n    - progress: The progress to update to.\n    \"\"\"\n\n    if data[\"status\"] == \"downloading\":\n        file_bytes = data.get(\"total_bytes\")\n        if file_bytes is None:\n            file_bytes = data.get(\"total_bytes_estimate\")\n\n        downloaded_bytes = data.get(\"downloaded_bytes\")\n        if self.parent.simple_tui and not self.parent.web_ui:\n            self.progress = 50\n        elif file_bytes and downloaded_bytes:\n            self.progress = downloaded_bytes / file_bytes * 50\n\n        self.update(\"Downloading\")\n</code></pre>"},{"location":"reference/providers/","title":"providers","text":"<p>Different types of data providers for spotdl.</p>"},{"location":"reference/providers/audio/","title":"audio","text":"<p>Audio providers for spotdl.</p>"},{"location":"reference/providers/audio/#spotdl.providers.audio.AudioProvider","title":"<code>AudioProvider(output_format='mp3', cookie_file=None, search_query=None, filter_results=True, yt_dlp_args=None)</code>","text":"<p>Base class for all other providers. Provides some common functionality. Handles the yt-dlp audio handler.</p>"},{"location":"reference/providers/audio/#spotdl.providers.audio.AudioProvider--arguments","title":"Arguments","text":"<ul> <li>output_directory: The directory to save the downloaded songs to.</li> <li>output_format: The format to save the downloaded songs in.</li> <li>cookie_file: The path to a file containing cookies to be used by YTDL.</li> <li>search_query: The query to use when searching for songs.</li> <li>filter_results: Whether to filter results.</li> </ul> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def __init__(\n    self,\n    output_format: str = \"mp3\",\n    cookie_file: Optional[str] = None,\n    search_query: Optional[str] = None,\n    filter_results: bool = True,\n    yt_dlp_args: Optional[str] = None,\n) -&gt; None:\n    \"\"\"\n    Base class for audio providers.\n\n    ### Arguments\n    - output_directory: The directory to save the downloaded songs to.\n    - output_format: The format to save the downloaded songs in.\n    - cookie_file: The path to a file containing cookies to be used by YTDL.\n    - search_query: The query to use when searching for songs.\n    - filter_results: Whether to filter results.\n    \"\"\"\n\n    self.output_format = output_format\n    self.cookie_file = cookie_file\n    self.search_query = search_query\n    self.filter_results = filter_results\n\n    if self.output_format == \"m4a\":\n        ytdl_format = \"bestaudio[ext=m4a]/bestaudio/best\"\n    elif self.output_format == \"opus\":\n        ytdl_format = \"bestaudio[ext=webm]/bestaudio/best\"\n    else:\n        ytdl_format = \"bestaudio\"\n\n    yt_dlp_options = {\n        \"format\": ytdl_format,\n        \"quiet\": True,\n        \"no_warnings\": True,\n        \"encoding\": \"UTF-8\",\n        \"logger\": YTDLLogger(),\n        \"cookiefile\": self.cookie_file,\n        \"outtmpl\": str((get_temp_path() / \"%(id)s.%(ext)s\").resolve()),\n        \"retries\": 5,\n        \"extractor_args\": {},\n    }\n\n    if yt_dlp_args:\n        yt_dlp_options = args_to_ytdlp_options(\n            shlex.split(yt_dlp_args), yt_dlp_options\n        )\n\n    self.audio_handler = YoutubeDL(yt_dlp_options)\n</code></pre>"},{"location":"reference/providers/audio/#spotdl.providers.audio.AudioProvider.name","title":"<code>name</code>  <code>property</code>","text":"<p>Get the name of the provider.</p>"},{"location":"reference/providers/audio/#spotdl.providers.audio.AudioProvider.name--returns","title":"Returns","text":"<ul> <li>The name of the provider.</li> </ul>"},{"location":"reference/providers/audio/#spotdl.providers.audio.AudioProvider.get_best_result","title":"<code>get_best_result(results)</code>","text":"<p>Get the best match from the results using views and average match</p>"},{"location":"reference/providers/audio/#spotdl.providers.audio.AudioProvider.get_best_result--arguments","title":"Arguments","text":"<ul> <li>results: A dictionary of results and their scores</li> </ul>"},{"location":"reference/providers/audio/#spotdl.providers.audio.AudioProvider.get_best_result--returns","title":"Returns","text":"<ul> <li>The best match URL and its score</li> </ul> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def get_best_result(self, results: Dict[Result, float]) -&gt; Tuple[Result, float]:\n    \"\"\"\n    Get the best match from the results\n    using views and average match\n\n    ### Arguments\n    - results: A dictionary of results and their scores\n\n    ### Returns\n    - The best match URL and its score\n    \"\"\"\n\n    best_results = get_best_matches(results, 8)\n\n    # If we have only one result, return it\n    if len(best_results) == 1:\n        return best_results[0][0], best_results[0][1]\n\n    # Initial best result based on the average match\n    best_result = best_results[0]\n\n    # If the best result has a score higher than 80%\n    # and it's a isrc search, return it\n    if best_result[1] &gt; 80 and best_result[0].isrc_search:\n        return best_result[0], best_result[1]\n\n    # If we have more than one result,\n    # return the one with the highest score\n    # and most views\n    if len(best_results) &gt; 1:\n        views: List[int] = []\n        for best_result in best_results:\n            if best_result[0].views:\n                views.append(best_result[0].views)\n            else:\n                views.append(self.get_views(best_result[0].url))\n\n        highest_views = max(views)\n        lowest_views = min(views)\n\n        if highest_views in (0, lowest_views):\n            return best_result[0], best_result[1]\n\n        weighted_results: List[Tuple[Result, float]] = []\n        for index, best_result in enumerate(best_results):\n            result_views = views[index]\n            views_score = (\n                (result_views - lowest_views) / (highest_views - lowest_views)\n            ) * 15\n            score = min(best_result[1] + views_score, 100)\n            weighted_results.append((best_result[0], score))\n\n        # Now we return the result with the highest score\n        return max(weighted_results, key=lambda x: x[1])\n\n    return best_result[0], best_result[1]\n</code></pre>"},{"location":"reference/providers/audio/#spotdl.providers.audio.AudioProvider.get_download_metadata","title":"<code>get_download_metadata(url, download=False)</code>","text":"<p>Get metadata for a download using yt-dlp.</p>"},{"location":"reference/providers/audio/#spotdl.providers.audio.AudioProvider.get_download_metadata--arguments","title":"Arguments","text":"<ul> <li>url: The url to get metadata for.</li> </ul>"},{"location":"reference/providers/audio/#spotdl.providers.audio.AudioProvider.get_download_metadata--returns","title":"Returns","text":"<ul> <li>A dictionary containing the metadata.</li> </ul> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def get_download_metadata(self, url: str, download: bool = False) -&gt; Dict:\n    \"\"\"\n    Get metadata for a download using yt-dlp.\n\n    ### Arguments\n    - url: The url to get metadata for.\n\n    ### Returns\n    - A dictionary containing the metadata.\n    \"\"\"\n\n    try:\n        data = self.audio_handler.extract_info(url, download=download)\n\n        if data:\n            return data\n    except Exception as exception:\n        logger.debug(exception)\n        raise AudioProviderError(f\"YT-DLP download error - {url}\") from exception\n\n    raise AudioProviderError(f\"No metadata found for the provided url {url}\")\n</code></pre>"},{"location":"reference/providers/audio/#spotdl.providers.audio.AudioProvider.get_results","title":"<code>get_results(search_term, **kwargs)</code>","text":"<p>Get results from audio provider.</p>"},{"location":"reference/providers/audio/#spotdl.providers.audio.AudioProvider.get_results--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to use.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/audio/#spotdl.providers.audio.AudioProvider.get_results--returns","title":"Returns","text":"<ul> <li>A list of results.</li> </ul> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def get_results(self, search_term: str, **kwargs) -&gt; List[Result]:\n    \"\"\"\n    Get results from audio provider.\n\n    ### Arguments\n    - search_term: The search term to use.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - A list of results.\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/providers/audio/#spotdl.providers.audio.AudioProvider.get_views","title":"<code>get_views(url)</code>","text":"<p>Get the number of views for a video.</p>"},{"location":"reference/providers/audio/#spotdl.providers.audio.AudioProvider.get_views--arguments","title":"Arguments","text":"<ul> <li>url: The url of the video.</li> </ul>"},{"location":"reference/providers/audio/#spotdl.providers.audio.AudioProvider.get_views--returns","title":"Returns","text":"<ul> <li>The number of views.</li> </ul> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def get_views(self, url: str) -&gt; int:\n    \"\"\"\n    Get the number of views for a video.\n\n    ### Arguments\n    - url: The url of the video.\n\n    ### Returns\n    - The number of views.\n    \"\"\"\n\n    data = self.get_download_metadata(url)\n\n    return data[\"view_count\"]\n</code></pre>"},{"location":"reference/providers/audio/#spotdl.providers.audio.AudioProvider.search","title":"<code>search(song, only_verified=False)</code>","text":"<p>Search for a song and return best match.</p>"},{"location":"reference/providers/audio/#spotdl.providers.audio.AudioProvider.search--arguments","title":"Arguments","text":"<ul> <li>song: The song to search for.</li> </ul>"},{"location":"reference/providers/audio/#spotdl.providers.audio.AudioProvider.search--returns","title":"Returns","text":"<ul> <li>The url of the best match or None if no match was found.</li> </ul> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def search(self, song: Song, only_verified: bool = False) -&gt; Optional[str]:\n    \"\"\"\n    Search for a song and return best match.\n\n    ### Arguments\n    - song: The song to search for.\n\n    ### Returns\n    - The url of the best match or None if no match was found.\n    \"\"\"\n\n    # Create initial search query\n    search_query = create_song_title(song.name, song.artists).lower()\n    if self.search_query:\n        search_query = create_search_query(\n            song, self.search_query, False, None, True\n        )\n\n    logger.debug(\"[%s] Searching for %s\", song.song_id, search_query)\n\n    isrc_urls: List[str] = []\n\n    # search for song using isrc if it's available\n    if song.isrc and self.SUPPORTS_ISRC and not self.search_query:\n        isrc_results = self.get_results(song.isrc)\n\n        if only_verified:\n            isrc_results = [result for result in isrc_results if result.verified]\n            logger.debug(\n                \"[%s] Filtered to %s verified ISRC results\",\n                song.song_id,\n                len(isrc_results),\n            )\n\n        isrc_urls = [result.url for result in isrc_results]\n        logger.debug(\n            \"[%s] Found %s results for ISRC %s\",\n            song.song_id,\n            len(isrc_results),\n            song.isrc,\n        )\n\n        if len(isrc_results) == 1 and isrc_results[0].verified:\n            # If we only have one verified result, return it\n            # What's the chance of it being wrong?\n            logger.debug(\n                \"[%s] Returning only ISRC result %s\",\n                song.song_id,\n                isrc_results[0].url,\n            )\n\n            return isrc_results[0].url\n\n        if len(isrc_results) &gt; 0:\n            sorted_isrc_results = order_results(\n                isrc_results, song, self.search_query\n            )\n\n            # get the best result, if the score is above 80 return it\n            best_isrc_results = sorted(\n                sorted_isrc_results.items(), key=lambda x: x[1], reverse=True\n            )\n\n            logger.debug(\n                \"[%s] Filtered to %s ISRC results\",\n                song.song_id,\n                len(best_isrc_results),\n            )\n\n            if len(best_isrc_results) &gt; 0:\n                best_isrc = best_isrc_results[0]\n                if best_isrc[1] &gt; 80.0:\n                    logger.debug(\n                        \"[%s] Best ISRC result is %s with score %s\",\n                        song.song_id,\n                        best_isrc[0].url,\n                        best_isrc[1],\n                    )\n\n                    return best_isrc[0].url\n\n    results: Dict[Result, float] = {}\n    for options in self.GET_RESULTS_OPTS:\n        # Query YTM by songs only first, this way if we get correct result on the first try\n        # we don't have to make another request\n        search_results = self.get_results(search_query, **options)\n\n        if only_verified:\n            search_results = [\n                result for result in search_results if result.verified\n            ]\n\n        logger.debug(\n            \"[%s] Found %s results for search query %s with options %s\",\n            song.song_id,\n            len(search_results),\n            search_query,\n            options,\n        )\n\n        # Check if any of the search results is in the\n        # first isrc results, since they are not hashable we have to check\n        # by name\n        isrc_result = next(\n            (result for result in search_results if result.url in isrc_urls),\n            None,\n        )\n\n        if isrc_result:\n            logger.debug(\n                \"[%s] Best ISRC result is %s\", song.song_id, isrc_result.url\n            )\n\n            return isrc_result.url\n\n        logger.debug(\n            \"[%s] Have to filter results: %s\", song.song_id, self.filter_results\n        )\n\n        if self.filter_results:\n            # Order results\n            new_results = order_results(search_results, song, self.search_query)\n        else:\n            new_results = {}\n            if len(search_results) &gt; 0:\n                new_results = {search_results[0]: 100.0}\n\n        logger.debug(\"[%s] Filtered to %s results\", song.song_id, len(new_results))\n\n        # song type results are always more accurate than video type,\n        # so if we get score of 80 or above\n        # we are almost 100% sure that this is the correct link\n        if len(new_results) != 0:\n            # get the result with highest score\n            best_result, best_score = self.get_best_result(new_results)\n            logger.debug(\n                \"[%s] Best result is %s with score %s\",\n                song.song_id,\n                best_result.url,\n                best_score,\n            )\n\n            if best_score &gt;= 80 and best_result.verified:\n                logger.debug(\n                    \"[%s] Returning verified best result %s with score %s\",\n                    song.song_id,\n                    best_result.url,\n                    best_score,\n                )\n\n                return best_result.url\n\n            # Update final results with new results\n            results.update(new_results)\n\n    # No matches found\n    if not results:\n        logger.debug(\"[%s] No results found\", song.song_id)\n        return None\n\n    # get the result with highest score\n    best_result, best_score = self.get_best_result(results)\n    logger.debug(\n        \"[%s] Returning best result %s with score %s\",\n        song.song_id,\n        best_result.url,\n        best_score,\n    )\n\n    return best_result.url\n</code></pre>"},{"location":"reference/providers/audio/#spotdl.providers.audio.AudioProviderError","title":"<code>AudioProviderError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all exceptions related to audio searching/downloading.</p>"},{"location":"reference/providers/audio/#spotdl.providers.audio.BandCamp","title":"<code>BandCamp(output_format='mp3', cookie_file=None, search_query=None, filter_results=True, yt_dlp_args=None)</code>","text":"<p>               Bases: <code>AudioProvider</code></p> <p>SoundCloud audio provider class</p> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def __init__(\n    self,\n    output_format: str = \"mp3\",\n    cookie_file: Optional[str] = None,\n    search_query: Optional[str] = None,\n    filter_results: bool = True,\n    yt_dlp_args: Optional[str] = None,\n) -&gt; None:\n    \"\"\"\n    Base class for audio providers.\n\n    ### Arguments\n    - output_directory: The directory to save the downloaded songs to.\n    - output_format: The format to save the downloaded songs in.\n    - cookie_file: The path to a file containing cookies to be used by YTDL.\n    - search_query: The query to use when searching for songs.\n    - filter_results: Whether to filter results.\n    \"\"\"\n\n    self.output_format = output_format\n    self.cookie_file = cookie_file\n    self.search_query = search_query\n    self.filter_results = filter_results\n\n    if self.output_format == \"m4a\":\n        ytdl_format = \"bestaudio[ext=m4a]/bestaudio/best\"\n    elif self.output_format == \"opus\":\n        ytdl_format = \"bestaudio[ext=webm]/bestaudio/best\"\n    else:\n        ytdl_format = \"bestaudio\"\n\n    yt_dlp_options = {\n        \"format\": ytdl_format,\n        \"quiet\": True,\n        \"no_warnings\": True,\n        \"encoding\": \"UTF-8\",\n        \"logger\": YTDLLogger(),\n        \"cookiefile\": self.cookie_file,\n        \"outtmpl\": str((get_temp_path() / \"%(id)s.%(ext)s\").resolve()),\n        \"retries\": 5,\n        \"extractor_args\": {},\n    }\n\n    if yt_dlp_args:\n        yt_dlp_options = args_to_ytdlp_options(\n            shlex.split(yt_dlp_args), yt_dlp_options\n        )\n\n    self.audio_handler = YoutubeDL(yt_dlp_options)\n</code></pre>"},{"location":"reference/providers/audio/#spotdl.providers.audio.BandCamp.get_results","title":"<code>get_results(search_term, *_args, **_kwargs)</code>","text":"<p>Get results from slider.kz</p>"},{"location":"reference/providers/audio/#spotdl.providers.audio.BandCamp.get_results--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to search for.</li> <li>args: Unused.</li> <li>kwargs: Unused.</li> </ul>"},{"location":"reference/providers/audio/#spotdl.providers.audio.BandCamp.get_results--returns","title":"Returns","text":"<ul> <li>A list of slider.kz results if found, None otherwise.</li> </ul> Source code in <code>spotdl/providers/audio/bandcamp.py</code> <pre><code>def get_results(self, search_term: str, *_args, **_kwargs) -&gt; List[Result]:\n    \"\"\"\n    Get results from slider.kz\n\n    ### Arguments\n    - search_term: The search term to search for.\n    - args: Unused.\n    - kwargs: Unused.\n\n    ### Returns\n    - A list of slider.kz results if found, None otherwise.\n    \"\"\"\n\n    try:\n        results = search(search_term)\n    except KeyError:\n        return []\n    except Exception as exc:\n        logger.error(\"Failed to get results from BandCamp\", exc_info=exc)\n        return []\n\n    simplified_results: List[Result] = []\n    for result in results:\n        track = BandCampTrack(int(result[0]), int(result[1]))\n\n        simplified_results.append(\n            Result(\n                source=\"bandcamp\",\n                url=track.track_url,\n                verified=False,\n                name=track.track_title,\n                duration=track.track_duration_seconds,\n                author=track.artist_title,\n                result_id=track.track_url,\n                search_query=search_term,\n                album=track.album_title,\n                artists=tuple(track.artist_title.split(\", \")),\n            )\n        )\n\n    return simplified_results\n</code></pre>"},{"location":"reference/providers/audio/#spotdl.providers.audio.Piped","title":"<code>Piped(output_format='mp3', cookie_file=None, search_query=None, filter_results=True, yt_dlp_args=None)</code>","text":"<p>               Bases: <code>AudioProvider</code></p> <p>YouTube Music audio provider class</p>"},{"location":"reference/providers/audio/#spotdl.providers.audio.Piped--arguments","title":"Arguments","text":"<ul> <li>output_directory: The directory to save the downloaded songs to.</li> <li>output_format: The format to save the downloaded songs in.</li> <li>cookie_file: The path to a file containing cookies to be used by YTDL.</li> <li>search_query: The query to use when searching for songs.</li> <li>filter_results: Whether to filter results.</li> </ul> Source code in <code>spotdl/providers/audio/piped.py</code> <pre><code>def __init__(  # pylint: disable=super-init-not-called\n    self,\n    output_format: str = \"mp3\",\n    cookie_file: Optional[str] = None,\n    search_query: Optional[str] = None,\n    filter_results: bool = True,\n    yt_dlp_args: Optional[str] = None,\n) -&gt; None:\n    \"\"\"\n    Pipe audio provider class\n\n    ### Arguments\n    - output_directory: The directory to save the downloaded songs to.\n    - output_format: The format to save the downloaded songs in.\n    - cookie_file: The path to a file containing cookies to be used by YTDL.\n    - search_query: The query to use when searching for songs.\n    - filter_results: Whether to filter results.\n    \"\"\"\n\n    self.output_format = output_format\n    self.cookie_file = cookie_file\n    self.search_query = search_query\n    self.filter_results = filter_results\n\n    if self.output_format == \"m4a\":\n        ytdl_format = \"best[ext=m4a]/best\"\n    elif self.output_format == \"opus\":\n        ytdl_format = \"best[ext=webm]/best\"\n    else:\n        ytdl_format = \"best\"\n\n    yt_dlp_options = {\n        \"format\": ytdl_format,\n        \"quiet\": True,\n        \"no_warnings\": True,\n        \"encoding\": \"UTF-8\",\n        \"logger\": YTDLLogger(),\n        \"cookiefile\": self.cookie_file,\n        \"outtmpl\": f\"{get_temp_path()}/%(id)s.%(ext)s\",\n        \"retries\": 5,\n    }\n\n    if yt_dlp_args:\n        user_options = args_to_ytdlp_options(shlex.split(yt_dlp_args))\n        yt_dlp_options.update(user_options)\n\n    self.audio_handler = YoutubeDL(yt_dlp_options)\n    self.session = requests.Session()\n</code></pre>"},{"location":"reference/providers/audio/#spotdl.providers.audio.Piped.get_download_metadata","title":"<code>get_download_metadata(url, download=False)</code>","text":"<p>Get metadata for a download using yt-dlp.</p>"},{"location":"reference/providers/audio/#spotdl.providers.audio.Piped.get_download_metadata--arguments","title":"Arguments","text":"<ul> <li>url: The url to get metadata for.</li> </ul>"},{"location":"reference/providers/audio/#spotdl.providers.audio.Piped.get_download_metadata--returns","title":"Returns","text":"<ul> <li>A dictionary containing the metadata.</li> </ul> Source code in <code>spotdl/providers/audio/piped.py</code> <pre><code>def get_download_metadata(self, url: str, download: bool = False) -&gt; Dict:\n    \"\"\"\n    Get metadata for a download using yt-dlp.\n\n    ### Arguments\n    - url: The url to get metadata for.\n\n    ### Returns\n    - A dictionary containing the metadata.\n    \"\"\"\n\n    url_id = url.split(\"?v=\")[1]\n    piped_response = requests.get(\n        f\"https://piped.video/streams/{url_id}\",\n        timeout=10,\n        proxies=GlobalConfig.get_parameter(\"proxies\"),\n    )\n\n    if piped_response.status_code != 200:\n        raise AudioProviderError(\n            f\"Failed to get metadata for {url} from Piped: {piped_response.text}\"\n        )\n\n    piped_data = piped_response.json()\n\n    yt_dlp_json = {\n        \"title\": piped_data[\"title\"],\n        \"id\": url_id,\n        \"view_count\": piped_data[\"views\"],\n        \"extractor\": \"Generic\",\n        \"formats\": [],\n    }\n\n    for audio_stream in piped_data[\"audioStreams\"]:\n        yt_dlp_json[\"formats\"].append(\n            {\n                \"url\": audio_stream[\"url\"],\n                \"ext\": \"webm\" if audio_stream[\"codec\"] == \"opus\" else \"m4a\",\n                \"abr\": audio_stream[\"quality\"].split(\" \")[0],\n                \"filesize\": audio_stream[\"contentLength\"],\n            }\n        )\n\n    return self.audio_handler.process_video_result(yt_dlp_json, download=download)\n</code></pre>"},{"location":"reference/providers/audio/#spotdl.providers.audio.Piped.get_results","title":"<code>get_results(search_term, **kwargs)</code>","text":"<p>Get results from YouTube Music API and simplify them</p>"},{"location":"reference/providers/audio/#spotdl.providers.audio.Piped.get_results--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to search for.</li> <li>kwargs: other keyword arguments passed to the <code>YTMusic.search</code> method.</li> </ul>"},{"location":"reference/providers/audio/#spotdl.providers.audio.Piped.get_results--returns","title":"Returns","text":"<ul> <li>A list of simplified results (dicts)</li> </ul> Source code in <code>spotdl/providers/audio/piped.py</code> <pre><code>def get_results(self, search_term: str, **kwargs) -&gt; List[Result]:\n    \"\"\"\n    Get results from YouTube Music API and simplify them\n\n    ### Arguments\n    - search_term: The search term to search for.\n    - kwargs: other keyword arguments passed to the `YTMusic.search` method.\n\n    ### Returns\n    - A list of simplified results (dicts)\n    \"\"\"\n\n    if kwargs is None:\n        kwargs = {}\n\n    params = {\"q\": search_term, **kwargs}\n    if params.get(\"filter\") is None:\n        params[\"filter\"] = \"music_videos\"\n\n    response = self.session.get(\n        \"https://piped.video/search\",\n        params=params,\n        headers=HEADERS,\n        timeout=20,\n    )\n\n    if response.status_code != 200:\n        raise AudioProviderError(\n            f\"Failed to get results for {search_term} from Piped: {response.text}\"\n        )\n\n    search_results = response.json()\n\n    # Simplify results\n    results = []\n    for result in search_results[\"items\"]:\n        if result[\"type\"] != \"stream\":\n            continue\n\n        isrc_result = ISRC_REGEX.search(search_term)\n\n        results.append(\n            Result(\n                source=\"piped\",\n                url=f\"https://piped.video{result['url']}\",\n                verified=kwargs.get(\"filter\") == \"music_songs\",\n                name=result[\"title\"],\n                duration=result[\"duration\"],\n                author=result[\"uploaderName\"],\n                result_id=result[\"url\"].split(\"?v=\")[1],\n                artists=(\n                    (result[\"uploaderName\"],)\n                    if kwargs.get(\"filter\") == \"music_songs\"\n                    else None\n                ),\n                isrc_search=isrc_result is not None,\n                search_query=search_term,\n            )\n        )\n\n    return results\n</code></pre>"},{"location":"reference/providers/audio/#spotdl.providers.audio.SoundCloud","title":"<code>SoundCloud(*args, **kwargs)</code>","text":"<p>               Bases: <code>AudioProvider</code></p> <p>SoundCloud audio provider class</p>"},{"location":"reference/providers/audio/#spotdl.providers.audio.SoundCloud--arguments","title":"Arguments","text":"<ul> <li>args: Arguments passed to the <code>AudioProvider</code> class.</li> <li>kwargs: Keyword arguments passed to the <code>AudioProvider</code> class.</li> </ul> Source code in <code>spotdl/providers/audio/soundcloud.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Initialize the SoundCloud API\n\n    ### Arguments\n    - args: Arguments passed to the `AudioProvider` class.\n    - kwargs: Keyword arguments passed to the `AudioProvider` class.\n    \"\"\"\n\n    super().__init__(*args, **kwargs)\n    self.client = SoundCloudClient()\n</code></pre>"},{"location":"reference/providers/audio/#spotdl.providers.audio.SoundCloud.get_results","title":"<code>get_results(search_term, *_args, **_kwargs)</code>","text":"<p>Get results from slider.kz</p>"},{"location":"reference/providers/audio/#spotdl.providers.audio.SoundCloud.get_results--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to search for.</li> <li>args: Unused.</li> <li>kwargs: Unused.</li> </ul>"},{"location":"reference/providers/audio/#spotdl.providers.audio.SoundCloud.get_results--returns","title":"Returns","text":"<ul> <li>A list of slider.kz results if found, None otherwise.</li> </ul> Source code in <code>spotdl/providers/audio/soundcloud.py</code> <pre><code>def get_results(self, search_term: str, *_args, **_kwargs) -&gt; List[Result]:\n    \"\"\"\n    Get results from slider.kz\n\n    ### Arguments\n    - search_term: The search term to search for.\n    - args: Unused.\n    - kwargs: Unused.\n\n    ### Returns\n    - A list of slider.kz results if found, None otherwise.\n    \"\"\"\n\n    results = list(islice(self.client.search(search_term), 20))\n    regex = r\"^(.+?)-|(\\(\\w+[\\s\\S]*\\))\"\n    # Because anyone can post on soundcloud, we do another search with an edited search\n    # The regex removes anything in brackets and the artist(s)'s name(s) if in the name\n    edited_search_term = re.sub(regex, \"\", search_term)\n    results.extend(list(islice(self.client.search(edited_search_term), 20)))\n\n    # Simplify results\n    simplified_results = []\n    for result in results:\n        if not isinstance(result, Track):\n            continue\n\n        # Ignore results that are not playable\n        if \"/preview/\" in result.media.transcodings[0].url:\n            continue\n\n        album = self.client.get_track_albums(result.id)\n\n        try:\n            album_name = next(album).title\n        except StopIteration:\n            album_name = None\n\n        simplified_results.append(\n            Result(\n                source=\"soundcloud\",\n                url=result.permalink_url,\n                name=result.title,\n                verified=result.user.verified,\n                duration=result.full_duration,\n                author=result.user.username,\n                result_id=str(result.id),\n                isrc_search=False,\n                search_query=search_term,\n                views=result.playback_count,\n                explicit=False,\n                album=album_name,\n            )\n        )\n\n    return simplified_results\n</code></pre>"},{"location":"reference/providers/audio/#spotdl.providers.audio.YTDLLogger","title":"<code>YTDLLogger</code>","text":"<p>Custom YT-dlp logger.</p>"},{"location":"reference/providers/audio/#spotdl.providers.audio.YTDLLogger.debug","title":"<code>debug(msg)</code>","text":"<p>YTDL uses this to print debug messages.</p> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def debug(self, msg):\n    \"\"\"\n    YTDL uses this to print debug messages.\n    \"\"\"\n\n    pass  # pylint: disable=W0107\n</code></pre>"},{"location":"reference/providers/audio/#spotdl.providers.audio.YTDLLogger.error","title":"<code>error(msg)</code>","text":"<p>YTDL uses this to print errors.</p> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def error(self, msg):\n    \"\"\"\n    YTDL uses this to print errors.\n    \"\"\"\n\n    raise AudioProviderError(msg)\n</code></pre>"},{"location":"reference/providers/audio/#spotdl.providers.audio.YTDLLogger.warning","title":"<code>warning(msg)</code>","text":"<p>YTDL uses this to print warnings.</p> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def warning(self, msg):\n    \"\"\"\n    YTDL uses this to print warnings.\n    \"\"\"\n\n    pass  # pylint: disable=W0107\n</code></pre>"},{"location":"reference/providers/audio/#spotdl.providers.audio.YouTube","title":"<code>YouTube(*args, **kwargs)</code>","text":"<p>               Bases: <code>AudioProvider</code></p> <p>YouTube audio provider class</p> Source code in <code>spotdl/providers/audio/youtube.py</code> <pre><code>def __init__(self, *args, **kwargs) -&gt; None:\n    \"\"\"\n    Initialize the YouTube audio provider\n    \"\"\"\n    super().__init__(*args, **kwargs)\n\n    # Set the client version to a specific version to avoid issues with pytube\n    # See #2323 or https://github.com/pytube/pytube/issues/296\n    innertube._default_clients['WEB'][\"context\"][\"client\"][\"clientVersion\"] = \"2.20230427.04.00\"\n</code></pre>"},{"location":"reference/providers/audio/#spotdl.providers.audio.YouTube.get_results","title":"<code>get_results(search_term, *_args, **_kwargs)</code>","text":"<p>Get results from YouTube</p>"},{"location":"reference/providers/audio/#spotdl.providers.audio.YouTube.get_results--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to search for.</li> <li>args: Unused.</li> <li>kwargs: Unused.</li> </ul>"},{"location":"reference/providers/audio/#spotdl.providers.audio.YouTube.get_results--returns","title":"Returns","text":"<ul> <li>A list of YouTube results if found, None otherwise.</li> </ul> Source code in <code>spotdl/providers/audio/youtube.py</code> <pre><code>def get_results(\n    self, search_term: str, *_args, **_kwargs\n) -&gt; List[Result]:  # pylint: disable=W0221\n    \"\"\"\n    Get results from YouTube\n\n    ### Arguments\n    - search_term: The search term to search for.\n    - args: Unused.\n    - kwargs: Unused.\n\n    ### Returns\n    - A list of YouTube results if found, None otherwise.\n    \"\"\"\n\n    search_results: Optional[List[PyTube]] = Search(search_term).results\n\n    if not search_results:\n        return []\n\n    results = []\n    for result in search_results:\n        if result.watch_url:\n            try:\n                duration = result.length\n            except Exception:\n                duration = 0\n\n            try:\n                views = result.views\n            except Exception:\n                views = 0\n\n            results.append(\n                Result(\n                    source=self.name,\n                    url=result.watch_url,\n                    verified=False,\n                    name=result.title,\n                    duration=duration,\n                    author=result.author,\n                    search_query=search_term,\n                    views=views,\n                    result_id=result.video_id,\n                )\n            )\n\n    return results\n</code></pre>"},{"location":"reference/providers/audio/#spotdl.providers.audio.YouTubeMusic","title":"<code>YouTubeMusic(*args, **kwargs)</code>","text":"<p>               Bases: <code>AudioProvider</code></p> <p>YouTube Music audio provider class</p>"},{"location":"reference/providers/audio/#spotdl.providers.audio.YouTubeMusic--arguments","title":"Arguments","text":"<ul> <li>args: Arguments passed to the <code>AudioProvider</code> class.</li> <li>kwargs: Keyword arguments passed to the <code>AudioProvider</code> class.</li> </ul> Source code in <code>spotdl/providers/audio/ytmusic.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Initialize the YouTube Music API\n\n    ### Arguments\n    - args: Arguments passed to the `AudioProvider` class.\n    - kwargs: Keyword arguments passed to the `AudioProvider` class.\n    \"\"\"\n\n    super().__init__(*args, **kwargs)\n\n    self.client = YTMusic(language=\"de\")\n</code></pre>"},{"location":"reference/providers/audio/#spotdl.providers.audio.YouTubeMusic.get_results","title":"<code>get_results(search_term, **kwargs)</code>","text":"<p>Get results from YouTube Music API and simplify them</p>"},{"location":"reference/providers/audio/#spotdl.providers.audio.YouTubeMusic.get_results--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to search for.</li> <li>kwargs: other keyword arguments passed to the <code>YTMusic.search</code> method.</li> </ul>"},{"location":"reference/providers/audio/#spotdl.providers.audio.YouTubeMusic.get_results--returns","title":"Returns","text":"<ul> <li>A list of simplified results (dicts)</li> </ul> Source code in <code>spotdl/providers/audio/ytmusic.py</code> <pre><code>def get_results(self, search_term: str, **kwargs) -&gt; List[Result]:\n    \"\"\"\n    Get results from YouTube Music API and simplify them\n\n    ### Arguments\n    - search_term: The search term to search for.\n    - kwargs: other keyword arguments passed to the `YTMusic.search` method.\n\n    ### Returns\n    - A list of simplified results (dicts)\n    \"\"\"\n\n    is_isrc_result = ISRC_REGEX.search(search_term) is not None\n    # if is_isrc_result:\n    #     print(\"FORCEFULLY SETTING FILTER TO SONGS\")\n    #     kwargs[\"filter\"] = \"songs\"\n\n    search_results = self.client.search(search_term, **kwargs)\n\n    # Simplify results\n    results = []\n    for result in search_results:\n        if (\n            result is None\n            or result.get(\"videoId\") is None\n            or result.get(\"artists\") in [[], None]\n        ):\n            continue\n\n        results.append(\n            Result(\n                source=self.name,\n                url=(\n                    f'https://{\"music\" if result[\"resultType\"] == \"song\" else \"www\"}'\n                    f\".youtube.com/watch?v={result['videoId']}\"\n                ),\n                verified=result.get(\"resultType\") == \"song\",\n                name=result[\"title\"],\n                result_id=result[\"videoId\"],\n                author=result[\"artists\"][0][\"name\"],\n                artists=tuple(map(lambda a: a[\"name\"], result[\"artists\"])),\n                duration=parse_duration(result.get(\"duration\")),\n                isrc_search=is_isrc_result,\n                search_query=search_term,\n                explicit=result.get(\"isExplicit\"),\n                album=(\n                    result.get(\"album\", {}).get(\"name\")\n                    if result.get(\"album\")\n                    else None\n                ),\n            )\n        )\n\n    return results\n</code></pre>"},{"location":"reference/providers/audio/bandcamp/","title":"bandcamp","text":"<p>BandCamp module for downloading and searching songs.</p>"},{"location":"reference/providers/audio/bandcamp/#spotdl.providers.audio.bandcamp.BandCamp","title":"<code>BandCamp(output_format='mp3', cookie_file=None, search_query=None, filter_results=True, yt_dlp_args=None)</code>","text":"<p>               Bases: <code>AudioProvider</code></p> <p>SoundCloud audio provider class</p> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def __init__(\n    self,\n    output_format: str = \"mp3\",\n    cookie_file: Optional[str] = None,\n    search_query: Optional[str] = None,\n    filter_results: bool = True,\n    yt_dlp_args: Optional[str] = None,\n) -&gt; None:\n    \"\"\"\n    Base class for audio providers.\n\n    ### Arguments\n    - output_directory: The directory to save the downloaded songs to.\n    - output_format: The format to save the downloaded songs in.\n    - cookie_file: The path to a file containing cookies to be used by YTDL.\n    - search_query: The query to use when searching for songs.\n    - filter_results: Whether to filter results.\n    \"\"\"\n\n    self.output_format = output_format\n    self.cookie_file = cookie_file\n    self.search_query = search_query\n    self.filter_results = filter_results\n\n    if self.output_format == \"m4a\":\n        ytdl_format = \"bestaudio[ext=m4a]/bestaudio/best\"\n    elif self.output_format == \"opus\":\n        ytdl_format = \"bestaudio[ext=webm]/bestaudio/best\"\n    else:\n        ytdl_format = \"bestaudio\"\n\n    yt_dlp_options = {\n        \"format\": ytdl_format,\n        \"quiet\": True,\n        \"no_warnings\": True,\n        \"encoding\": \"UTF-8\",\n        \"logger\": YTDLLogger(),\n        \"cookiefile\": self.cookie_file,\n        \"outtmpl\": str((get_temp_path() / \"%(id)s.%(ext)s\").resolve()),\n        \"retries\": 5,\n        \"extractor_args\": {},\n    }\n\n    if yt_dlp_args:\n        yt_dlp_options = args_to_ytdlp_options(\n            shlex.split(yt_dlp_args), yt_dlp_options\n        )\n\n    self.audio_handler = YoutubeDL(yt_dlp_options)\n</code></pre>"},{"location":"reference/providers/audio/bandcamp/#spotdl.providers.audio.bandcamp.BandCamp.get_results","title":"<code>get_results(search_term, *_args, **_kwargs)</code>","text":"<p>Get results from slider.kz</p>"},{"location":"reference/providers/audio/bandcamp/#spotdl.providers.audio.bandcamp.BandCamp.get_results--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to search for.</li> <li>args: Unused.</li> <li>kwargs: Unused.</li> </ul>"},{"location":"reference/providers/audio/bandcamp/#spotdl.providers.audio.bandcamp.BandCamp.get_results--returns","title":"Returns","text":"<ul> <li>A list of slider.kz results if found, None otherwise.</li> </ul> Source code in <code>spotdl/providers/audio/bandcamp.py</code> <pre><code>def get_results(self, search_term: str, *_args, **_kwargs) -&gt; List[Result]:\n    \"\"\"\n    Get results from slider.kz\n\n    ### Arguments\n    - search_term: The search term to search for.\n    - args: Unused.\n    - kwargs: Unused.\n\n    ### Returns\n    - A list of slider.kz results if found, None otherwise.\n    \"\"\"\n\n    try:\n        results = search(search_term)\n    except KeyError:\n        return []\n    except Exception as exc:\n        logger.error(\"Failed to get results from BandCamp\", exc_info=exc)\n        return []\n\n    simplified_results: List[Result] = []\n    for result in results:\n        track = BandCampTrack(int(result[0]), int(result[1]))\n\n        simplified_results.append(\n            Result(\n                source=\"bandcamp\",\n                url=track.track_url,\n                verified=False,\n                name=track.track_title,\n                duration=track.track_duration_seconds,\n                author=track.artist_title,\n                result_id=track.track_url,\n                search_query=search_term,\n                album=track.album_title,\n                artists=tuple(track.artist_title.split(\", \")),\n            )\n        )\n\n    return simplified_results\n</code></pre>"},{"location":"reference/providers/audio/bandcamp/#spotdl.providers.audio.bandcamp.BandCampTrack","title":"<code>BandCampTrack(artist_id, track_id)</code>","text":"<p>BandCamp track class based on the bandcamp_api library</p> Source code in <code>spotdl/providers/audio/bandcamp.py</code> <pre><code>def __init__(self, artist_id: int, track_id: int):\n    # object info\n    self.type = \"track\"\n\n    # track information\n    self.track_id: int = 0\n    self.track_title: str = \"\"\n    self.track_number: int = 0\n    self.track_duration_seconds: float = 0.00\n    self.track_streamable: Optional[bool] = None\n    self.has_lyrics: Optional[bool] = None\n    self.lyrics: str = \"\"\n    self.is_price_set: Optional[bool] = None\n    self.price: dict = {}\n    self.require_email: Optional[bool] = None\n    self.is_purchasable: Optional[bool] = None\n    self.is_free: Optional[bool] = None\n    self.is_preorder: Optional[bool] = None\n    self.tags: list = []\n    self.track_url: str = \"\"\n\n    # art\n    self.art_id: int = 0\n    self.art_url: str = \"\"\n\n    # artist information\n    self.artist_id: int = 0\n    self.artist_title: str = \"\"\n\n    # album information\n    self.album_id: int = 0\n    self.album_title: str = \"\"\n\n    # label\n    self.label_id: int = 0\n    self.label_title: str = \"\"\n\n    # about\n    self.about: str = \"\"\n    self.credits: str = \"\"\n    self.date_released_unix: int = 0\n\n    # advanced\n    self.date_last_modified_unix: int = 0\n    self.date_published_unix: int = 0\n    self.supporters: list = []\n\n    response = requests.get(\n        url=\"https://bandcamp.com/api/mobile/25/tralbum_details?band_id=\"\n        + str(artist_id)\n        + \"&amp;tralbum_id=\"\n        + str(track_id)\n        + \"&amp;tralbum_type=t\",\n        timeout=10,\n        proxies=GlobalConfig.get_parameter(\"proxies\"),\n    )\n    result = response.json()\n    self.track_id = result[\"id\"]\n    self.track_title = result[\"title\"]\n    self.track_number = result[\"tracks\"][0][\"track_num\"]\n    self.track_duration_seconds = result[\"tracks\"][0][\"duration\"]\n    self.track_streamable = result[\"tracks\"][0][\"is_streamable\"]\n    self.has_lyrics = result[\"tracks\"][0][\"has_lyrics\"]\n\n    # getting lyrics, if there is any\n    if self.has_lyrics is True:\n        resp = requests.get(\n            \"https://bandcamp.com/api/mobile/25/tralbum_lyrics?tralbum_id=\"\n            + str(self.track_id)\n            + \"&amp;tralbum_type=t\",\n            timeout=10,\n            proxies=GlobalConfig.get_parameter(\"proxies\"),\n        )\n        rjson = resp.json()\n        self.lyrics = rjson[\"lyrics\"][str(self.track_id)]\n\n    self.is_price_set = result[\"is_set_price\"]\n    self.price = {\"currency\": result[\"currency\"], \"amount\": result[\"price\"]}\n    self.require_email = result[\"require_email\"]\n    self.is_purchasable = result[\"is_purchasable\"]\n    self.is_free = result[\"free_download\"]\n    self.is_preorder = result[\"is_preorder\"]\n\n    for tag in result[\"tags\"]:\n        self.tags.append(tag[\"name\"])\n\n    self.art_id = result[\"art_id\"]\n    self.art_url = \"https://f4.bcbits.com/img/a\" + str(self.art_id) + \"_0.jpg\"\n\n    self.artist_id = result[\"band\"][\"band_id\"]\n    self.artist_title = result[\"band\"][\"name\"]\n\n    self.album_id = result[\"album_id\"]\n    self.album_title = result[\"album_title\"]\n\n    self.label_id = result[\"label_id\"]\n    self.label_title = result[\"label\"]\n\n    self.about = result[\"about\"]\n    self.credits = result[\"credits\"]\n\n    self.date_released_unix = result[\"release_date\"]\n\n    self.track_url = result[\"bandcamp_url\"]\n</code></pre>"},{"location":"reference/providers/audio/bandcamp/#spotdl.providers.audio.bandcamp.search","title":"<code>search(search_string='')</code>","text":"<p>I got this api url from the iOS app needs a way of removing characters that will screw up an url keep url safe characters</p>"},{"location":"reference/providers/audio/bandcamp/#spotdl.providers.audio.bandcamp.search--arguments","title":"Arguments","text":"<ul> <li>search_string: The search term to search for.</li> </ul>"},{"location":"reference/providers/audio/bandcamp/#spotdl.providers.audio.bandcamp.search--returns","title":"Returns","text":"<ul> <li>A list of artist and track ids if found</li> </ul> Source code in <code>spotdl/providers/audio/bandcamp.py</code> <pre><code>def search(search_string: str = \"\"):\n    \"\"\"\n    I got this api url from the iOS app\n    needs a way of removing characters\n    that will screw up an url\n    keep url safe characters\n\n    ### Arguments\n    - search_string: The search term to search for.\n\n    ### Returns\n    - A list of artist and track ids if found\n    \"\"\"\n\n    response = requests.get(\n        \"https://bandcamp.com/api/fuzzysearch/2/app_autocomplete?q=\"\n        + search_string\n        + \"&amp;param_with_locations=true\",\n        timeout=10,\n        proxies=GlobalConfig.get_parameter(\"proxies\"),\n    )\n\n    results = response.json()[\"results\"]\n\n    return_results: List[Tuple[str, str]] = []\n\n    for item in results:\n        if item[\"type\"] == \"t\":\n            return_results.append((item[\"band_id\"], item[\"id\"]))\n\n    return return_results\n</code></pre>"},{"location":"reference/providers/audio/base/","title":"base","text":"<p>Base audio provider module.</p>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider","title":"<code>AudioProvider(output_format='mp3', cookie_file=None, search_query=None, filter_results=True, yt_dlp_args=None)</code>","text":"<p>Base class for all other providers. Provides some common functionality. Handles the yt-dlp audio handler.</p>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider--arguments","title":"Arguments","text":"<ul> <li>output_directory: The directory to save the downloaded songs to.</li> <li>output_format: The format to save the downloaded songs in.</li> <li>cookie_file: The path to a file containing cookies to be used by YTDL.</li> <li>search_query: The query to use when searching for songs.</li> <li>filter_results: Whether to filter results.</li> </ul> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def __init__(\n    self,\n    output_format: str = \"mp3\",\n    cookie_file: Optional[str] = None,\n    search_query: Optional[str] = None,\n    filter_results: bool = True,\n    yt_dlp_args: Optional[str] = None,\n) -&gt; None:\n    \"\"\"\n    Base class for audio providers.\n\n    ### Arguments\n    - output_directory: The directory to save the downloaded songs to.\n    - output_format: The format to save the downloaded songs in.\n    - cookie_file: The path to a file containing cookies to be used by YTDL.\n    - search_query: The query to use when searching for songs.\n    - filter_results: Whether to filter results.\n    \"\"\"\n\n    self.output_format = output_format\n    self.cookie_file = cookie_file\n    self.search_query = search_query\n    self.filter_results = filter_results\n\n    if self.output_format == \"m4a\":\n        ytdl_format = \"bestaudio[ext=m4a]/bestaudio/best\"\n    elif self.output_format == \"opus\":\n        ytdl_format = \"bestaudio[ext=webm]/bestaudio/best\"\n    else:\n        ytdl_format = \"bestaudio\"\n\n    yt_dlp_options = {\n        \"format\": ytdl_format,\n        \"quiet\": True,\n        \"no_warnings\": True,\n        \"encoding\": \"UTF-8\",\n        \"logger\": YTDLLogger(),\n        \"cookiefile\": self.cookie_file,\n        \"outtmpl\": str((get_temp_path() / \"%(id)s.%(ext)s\").resolve()),\n        \"retries\": 5,\n        \"extractor_args\": {},\n    }\n\n    if yt_dlp_args:\n        yt_dlp_options = args_to_ytdlp_options(\n            shlex.split(yt_dlp_args), yt_dlp_options\n        )\n\n    self.audio_handler = YoutubeDL(yt_dlp_options)\n</code></pre>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.name","title":"<code>name</code>  <code>property</code>","text":"<p>Get the name of the provider.</p>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.name--returns","title":"Returns","text":"<ul> <li>The name of the provider.</li> </ul>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.get_best_result","title":"<code>get_best_result(results)</code>","text":"<p>Get the best match from the results using views and average match</p>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.get_best_result--arguments","title":"Arguments","text":"<ul> <li>results: A dictionary of results and their scores</li> </ul>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.get_best_result--returns","title":"Returns","text":"<ul> <li>The best match URL and its score</li> </ul> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def get_best_result(self, results: Dict[Result, float]) -&gt; Tuple[Result, float]:\n    \"\"\"\n    Get the best match from the results\n    using views and average match\n\n    ### Arguments\n    - results: A dictionary of results and their scores\n\n    ### Returns\n    - The best match URL and its score\n    \"\"\"\n\n    best_results = get_best_matches(results, 8)\n\n    # If we have only one result, return it\n    if len(best_results) == 1:\n        return best_results[0][0], best_results[0][1]\n\n    # Initial best result based on the average match\n    best_result = best_results[0]\n\n    # If the best result has a score higher than 80%\n    # and it's a isrc search, return it\n    if best_result[1] &gt; 80 and best_result[0].isrc_search:\n        return best_result[0], best_result[1]\n\n    # If we have more than one result,\n    # return the one with the highest score\n    # and most views\n    if len(best_results) &gt; 1:\n        views: List[int] = []\n        for best_result in best_results:\n            if best_result[0].views:\n                views.append(best_result[0].views)\n            else:\n                views.append(self.get_views(best_result[0].url))\n\n        highest_views = max(views)\n        lowest_views = min(views)\n\n        if highest_views in (0, lowest_views):\n            return best_result[0], best_result[1]\n\n        weighted_results: List[Tuple[Result, float]] = []\n        for index, best_result in enumerate(best_results):\n            result_views = views[index]\n            views_score = (\n                (result_views - lowest_views) / (highest_views - lowest_views)\n            ) * 15\n            score = min(best_result[1] + views_score, 100)\n            weighted_results.append((best_result[0], score))\n\n        # Now we return the result with the highest score\n        return max(weighted_results, key=lambda x: x[1])\n\n    return best_result[0], best_result[1]\n</code></pre>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.get_download_metadata","title":"<code>get_download_metadata(url, download=False)</code>","text":"<p>Get metadata for a download using yt-dlp.</p>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.get_download_metadata--arguments","title":"Arguments","text":"<ul> <li>url: The url to get metadata for.</li> </ul>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.get_download_metadata--returns","title":"Returns","text":"<ul> <li>A dictionary containing the metadata.</li> </ul> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def get_download_metadata(self, url: str, download: bool = False) -&gt; Dict:\n    \"\"\"\n    Get metadata for a download using yt-dlp.\n\n    ### Arguments\n    - url: The url to get metadata for.\n\n    ### Returns\n    - A dictionary containing the metadata.\n    \"\"\"\n\n    try:\n        data = self.audio_handler.extract_info(url, download=download)\n\n        if data:\n            return data\n    except Exception as exception:\n        logger.debug(exception)\n        raise AudioProviderError(f\"YT-DLP download error - {url}\") from exception\n\n    raise AudioProviderError(f\"No metadata found for the provided url {url}\")\n</code></pre>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.get_results","title":"<code>get_results(search_term, **kwargs)</code>","text":"<p>Get results from audio provider.</p>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.get_results--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to use.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.get_results--returns","title":"Returns","text":"<ul> <li>A list of results.</li> </ul> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def get_results(self, search_term: str, **kwargs) -&gt; List[Result]:\n    \"\"\"\n    Get results from audio provider.\n\n    ### Arguments\n    - search_term: The search term to use.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - A list of results.\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.get_views","title":"<code>get_views(url)</code>","text":"<p>Get the number of views for a video.</p>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.get_views--arguments","title":"Arguments","text":"<ul> <li>url: The url of the video.</li> </ul>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.get_views--returns","title":"Returns","text":"<ul> <li>The number of views.</li> </ul> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def get_views(self, url: str) -&gt; int:\n    \"\"\"\n    Get the number of views for a video.\n\n    ### Arguments\n    - url: The url of the video.\n\n    ### Returns\n    - The number of views.\n    \"\"\"\n\n    data = self.get_download_metadata(url)\n\n    return data[\"view_count\"]\n</code></pre>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.search","title":"<code>search(song, only_verified=False)</code>","text":"<p>Search for a song and return best match.</p>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.search--arguments","title":"Arguments","text":"<ul> <li>song: The song to search for.</li> </ul>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProvider.search--returns","title":"Returns","text":"<ul> <li>The url of the best match or None if no match was found.</li> </ul> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def search(self, song: Song, only_verified: bool = False) -&gt; Optional[str]:\n    \"\"\"\n    Search for a song and return best match.\n\n    ### Arguments\n    - song: The song to search for.\n\n    ### Returns\n    - The url of the best match or None if no match was found.\n    \"\"\"\n\n    # Create initial search query\n    search_query = create_song_title(song.name, song.artists).lower()\n    if self.search_query:\n        search_query = create_search_query(\n            song, self.search_query, False, None, True\n        )\n\n    logger.debug(\"[%s] Searching for %s\", song.song_id, search_query)\n\n    isrc_urls: List[str] = []\n\n    # search for song using isrc if it's available\n    if song.isrc and self.SUPPORTS_ISRC and not self.search_query:\n        isrc_results = self.get_results(song.isrc)\n\n        if only_verified:\n            isrc_results = [result for result in isrc_results if result.verified]\n            logger.debug(\n                \"[%s] Filtered to %s verified ISRC results\",\n                song.song_id,\n                len(isrc_results),\n            )\n\n        isrc_urls = [result.url for result in isrc_results]\n        logger.debug(\n            \"[%s] Found %s results for ISRC %s\",\n            song.song_id,\n            len(isrc_results),\n            song.isrc,\n        )\n\n        if len(isrc_results) == 1 and isrc_results[0].verified:\n            # If we only have one verified result, return it\n            # What's the chance of it being wrong?\n            logger.debug(\n                \"[%s] Returning only ISRC result %s\",\n                song.song_id,\n                isrc_results[0].url,\n            )\n\n            return isrc_results[0].url\n\n        if len(isrc_results) &gt; 0:\n            sorted_isrc_results = order_results(\n                isrc_results, song, self.search_query\n            )\n\n            # get the best result, if the score is above 80 return it\n            best_isrc_results = sorted(\n                sorted_isrc_results.items(), key=lambda x: x[1], reverse=True\n            )\n\n            logger.debug(\n                \"[%s] Filtered to %s ISRC results\",\n                song.song_id,\n                len(best_isrc_results),\n            )\n\n            if len(best_isrc_results) &gt; 0:\n                best_isrc = best_isrc_results[0]\n                if best_isrc[1] &gt; 80.0:\n                    logger.debug(\n                        \"[%s] Best ISRC result is %s with score %s\",\n                        song.song_id,\n                        best_isrc[0].url,\n                        best_isrc[1],\n                    )\n\n                    return best_isrc[0].url\n\n    results: Dict[Result, float] = {}\n    for options in self.GET_RESULTS_OPTS:\n        # Query YTM by songs only first, this way if we get correct result on the first try\n        # we don't have to make another request\n        search_results = self.get_results(search_query, **options)\n\n        if only_verified:\n            search_results = [\n                result for result in search_results if result.verified\n            ]\n\n        logger.debug(\n            \"[%s] Found %s results for search query %s with options %s\",\n            song.song_id,\n            len(search_results),\n            search_query,\n            options,\n        )\n\n        # Check if any of the search results is in the\n        # first isrc results, since they are not hashable we have to check\n        # by name\n        isrc_result = next(\n            (result for result in search_results if result.url in isrc_urls),\n            None,\n        )\n\n        if isrc_result:\n            logger.debug(\n                \"[%s] Best ISRC result is %s\", song.song_id, isrc_result.url\n            )\n\n            return isrc_result.url\n\n        logger.debug(\n            \"[%s] Have to filter results: %s\", song.song_id, self.filter_results\n        )\n\n        if self.filter_results:\n            # Order results\n            new_results = order_results(search_results, song, self.search_query)\n        else:\n            new_results = {}\n            if len(search_results) &gt; 0:\n                new_results = {search_results[0]: 100.0}\n\n        logger.debug(\"[%s] Filtered to %s results\", song.song_id, len(new_results))\n\n        # song type results are always more accurate than video type,\n        # so if we get score of 80 or above\n        # we are almost 100% sure that this is the correct link\n        if len(new_results) != 0:\n            # get the result with highest score\n            best_result, best_score = self.get_best_result(new_results)\n            logger.debug(\n                \"[%s] Best result is %s with score %s\",\n                song.song_id,\n                best_result.url,\n                best_score,\n            )\n\n            if best_score &gt;= 80 and best_result.verified:\n                logger.debug(\n                    \"[%s] Returning verified best result %s with score %s\",\n                    song.song_id,\n                    best_result.url,\n                    best_score,\n                )\n\n                return best_result.url\n\n            # Update final results with new results\n            results.update(new_results)\n\n    # No matches found\n    if not results:\n        logger.debug(\"[%s] No results found\", song.song_id)\n        return None\n\n    # get the result with highest score\n    best_result, best_score = self.get_best_result(results)\n    logger.debug(\n        \"[%s] Returning best result %s with score %s\",\n        song.song_id,\n        best_result.url,\n        best_score,\n    )\n\n    return best_result.url\n</code></pre>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.AudioProviderError","title":"<code>AudioProviderError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all exceptions related to audio searching/downloading.</p>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.YTDLLogger","title":"<code>YTDLLogger</code>","text":"<p>Custom YT-dlp logger.</p>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.YTDLLogger.debug","title":"<code>debug(msg)</code>","text":"<p>YTDL uses this to print debug messages.</p> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def debug(self, msg):\n    \"\"\"\n    YTDL uses this to print debug messages.\n    \"\"\"\n\n    pass  # pylint: disable=W0107\n</code></pre>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.YTDLLogger.error","title":"<code>error(msg)</code>","text":"<p>YTDL uses this to print errors.</p> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def error(self, msg):\n    \"\"\"\n    YTDL uses this to print errors.\n    \"\"\"\n\n    raise AudioProviderError(msg)\n</code></pre>"},{"location":"reference/providers/audio/base/#spotdl.providers.audio.base.YTDLLogger.warning","title":"<code>warning(msg)</code>","text":"<p>YTDL uses this to print warnings.</p> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def warning(self, msg):\n    \"\"\"\n    YTDL uses this to print warnings.\n    \"\"\"\n\n    pass  # pylint: disable=W0107\n</code></pre>"},{"location":"reference/providers/audio/piped/","title":"piped","text":"<p>Piped module for downloading and searching songs.</p>"},{"location":"reference/providers/audio/piped/#spotdl.providers.audio.piped.Piped","title":"<code>Piped(output_format='mp3', cookie_file=None, search_query=None, filter_results=True, yt_dlp_args=None)</code>","text":"<p>               Bases: <code>AudioProvider</code></p> <p>YouTube Music audio provider class</p>"},{"location":"reference/providers/audio/piped/#spotdl.providers.audio.piped.Piped--arguments","title":"Arguments","text":"<ul> <li>output_directory: The directory to save the downloaded songs to.</li> <li>output_format: The format to save the downloaded songs in.</li> <li>cookie_file: The path to a file containing cookies to be used by YTDL.</li> <li>search_query: The query to use when searching for songs.</li> <li>filter_results: Whether to filter results.</li> </ul> Source code in <code>spotdl/providers/audio/piped.py</code> <pre><code>def __init__(  # pylint: disable=super-init-not-called\n    self,\n    output_format: str = \"mp3\",\n    cookie_file: Optional[str] = None,\n    search_query: Optional[str] = None,\n    filter_results: bool = True,\n    yt_dlp_args: Optional[str] = None,\n) -&gt; None:\n    \"\"\"\n    Pipe audio provider class\n\n    ### Arguments\n    - output_directory: The directory to save the downloaded songs to.\n    - output_format: The format to save the downloaded songs in.\n    - cookie_file: The path to a file containing cookies to be used by YTDL.\n    - search_query: The query to use when searching for songs.\n    - filter_results: Whether to filter results.\n    \"\"\"\n\n    self.output_format = output_format\n    self.cookie_file = cookie_file\n    self.search_query = search_query\n    self.filter_results = filter_results\n\n    if self.output_format == \"m4a\":\n        ytdl_format = \"best[ext=m4a]/best\"\n    elif self.output_format == \"opus\":\n        ytdl_format = \"best[ext=webm]/best\"\n    else:\n        ytdl_format = \"best\"\n\n    yt_dlp_options = {\n        \"format\": ytdl_format,\n        \"quiet\": True,\n        \"no_warnings\": True,\n        \"encoding\": \"UTF-8\",\n        \"logger\": YTDLLogger(),\n        \"cookiefile\": self.cookie_file,\n        \"outtmpl\": f\"{get_temp_path()}/%(id)s.%(ext)s\",\n        \"retries\": 5,\n    }\n\n    if yt_dlp_args:\n        user_options = args_to_ytdlp_options(shlex.split(yt_dlp_args))\n        yt_dlp_options.update(user_options)\n\n    self.audio_handler = YoutubeDL(yt_dlp_options)\n    self.session = requests.Session()\n</code></pre>"},{"location":"reference/providers/audio/piped/#spotdl.providers.audio.piped.Piped.get_download_metadata","title":"<code>get_download_metadata(url, download=False)</code>","text":"<p>Get metadata for a download using yt-dlp.</p>"},{"location":"reference/providers/audio/piped/#spotdl.providers.audio.piped.Piped.get_download_metadata--arguments","title":"Arguments","text":"<ul> <li>url: The url to get metadata for.</li> </ul>"},{"location":"reference/providers/audio/piped/#spotdl.providers.audio.piped.Piped.get_download_metadata--returns","title":"Returns","text":"<ul> <li>A dictionary containing the metadata.</li> </ul> Source code in <code>spotdl/providers/audio/piped.py</code> <pre><code>def get_download_metadata(self, url: str, download: bool = False) -&gt; Dict:\n    \"\"\"\n    Get metadata for a download using yt-dlp.\n\n    ### Arguments\n    - url: The url to get metadata for.\n\n    ### Returns\n    - A dictionary containing the metadata.\n    \"\"\"\n\n    url_id = url.split(\"?v=\")[1]\n    piped_response = requests.get(\n        f\"https://piped.video/streams/{url_id}\",\n        timeout=10,\n        proxies=GlobalConfig.get_parameter(\"proxies\"),\n    )\n\n    if piped_response.status_code != 200:\n        raise AudioProviderError(\n            f\"Failed to get metadata for {url} from Piped: {piped_response.text}\"\n        )\n\n    piped_data = piped_response.json()\n\n    yt_dlp_json = {\n        \"title\": piped_data[\"title\"],\n        \"id\": url_id,\n        \"view_count\": piped_data[\"views\"],\n        \"extractor\": \"Generic\",\n        \"formats\": [],\n    }\n\n    for audio_stream in piped_data[\"audioStreams\"]:\n        yt_dlp_json[\"formats\"].append(\n            {\n                \"url\": audio_stream[\"url\"],\n                \"ext\": \"webm\" if audio_stream[\"codec\"] == \"opus\" else \"m4a\",\n                \"abr\": audio_stream[\"quality\"].split(\" \")[0],\n                \"filesize\": audio_stream[\"contentLength\"],\n            }\n        )\n\n    return self.audio_handler.process_video_result(yt_dlp_json, download=download)\n</code></pre>"},{"location":"reference/providers/audio/piped/#spotdl.providers.audio.piped.Piped.get_results","title":"<code>get_results(search_term, **kwargs)</code>","text":"<p>Get results from YouTube Music API and simplify them</p>"},{"location":"reference/providers/audio/piped/#spotdl.providers.audio.piped.Piped.get_results--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to search for.</li> <li>kwargs: other keyword arguments passed to the <code>YTMusic.search</code> method.</li> </ul>"},{"location":"reference/providers/audio/piped/#spotdl.providers.audio.piped.Piped.get_results--returns","title":"Returns","text":"<ul> <li>A list of simplified results (dicts)</li> </ul> Source code in <code>spotdl/providers/audio/piped.py</code> <pre><code>def get_results(self, search_term: str, **kwargs) -&gt; List[Result]:\n    \"\"\"\n    Get results from YouTube Music API and simplify them\n\n    ### Arguments\n    - search_term: The search term to search for.\n    - kwargs: other keyword arguments passed to the `YTMusic.search` method.\n\n    ### Returns\n    - A list of simplified results (dicts)\n    \"\"\"\n\n    if kwargs is None:\n        kwargs = {}\n\n    params = {\"q\": search_term, **kwargs}\n    if params.get(\"filter\") is None:\n        params[\"filter\"] = \"music_videos\"\n\n    response = self.session.get(\n        \"https://piped.video/search\",\n        params=params,\n        headers=HEADERS,\n        timeout=20,\n    )\n\n    if response.status_code != 200:\n        raise AudioProviderError(\n            f\"Failed to get results for {search_term} from Piped: {response.text}\"\n        )\n\n    search_results = response.json()\n\n    # Simplify results\n    results = []\n    for result in search_results[\"items\"]:\n        if result[\"type\"] != \"stream\":\n            continue\n\n        isrc_result = ISRC_REGEX.search(search_term)\n\n        results.append(\n            Result(\n                source=\"piped\",\n                url=f\"https://piped.video{result['url']}\",\n                verified=kwargs.get(\"filter\") == \"music_songs\",\n                name=result[\"title\"],\n                duration=result[\"duration\"],\n                author=result[\"uploaderName\"],\n                result_id=result[\"url\"].split(\"?v=\")[1],\n                artists=(\n                    (result[\"uploaderName\"],)\n                    if kwargs.get(\"filter\") == \"music_songs\"\n                    else None\n                ),\n                isrc_search=isrc_result is not None,\n                search_query=search_term,\n            )\n        )\n\n    return results\n</code></pre>"},{"location":"reference/providers/audio/sliderkz/","title":"sliderkz","text":"<p>SliderKZ module for downloading and searching songs.</p>"},{"location":"reference/providers/audio/sliderkz/#spotdl.providers.audio.sliderkz.SliderKZ","title":"<code>SliderKZ(output_format='mp3', cookie_file=None, search_query=None, filter_results=True, yt_dlp_args=None)</code>","text":"<p>               Bases: <code>AudioProvider</code></p> <p>Slider.kz audio provider class</p> Source code in <code>spotdl/providers/audio/base.py</code> <pre><code>def __init__(\n    self,\n    output_format: str = \"mp3\",\n    cookie_file: Optional[str] = None,\n    search_query: Optional[str] = None,\n    filter_results: bool = True,\n    yt_dlp_args: Optional[str] = None,\n) -&gt; None:\n    \"\"\"\n    Base class for audio providers.\n\n    ### Arguments\n    - output_directory: The directory to save the downloaded songs to.\n    - output_format: The format to save the downloaded songs in.\n    - cookie_file: The path to a file containing cookies to be used by YTDL.\n    - search_query: The query to use when searching for songs.\n    - filter_results: Whether to filter results.\n    \"\"\"\n\n    self.output_format = output_format\n    self.cookie_file = cookie_file\n    self.search_query = search_query\n    self.filter_results = filter_results\n\n    if self.output_format == \"m4a\":\n        ytdl_format = \"bestaudio[ext=m4a]/bestaudio/best\"\n    elif self.output_format == \"opus\":\n        ytdl_format = \"bestaudio[ext=webm]/bestaudio/best\"\n    else:\n        ytdl_format = \"bestaudio\"\n\n    yt_dlp_options = {\n        \"format\": ytdl_format,\n        \"quiet\": True,\n        \"no_warnings\": True,\n        \"encoding\": \"UTF-8\",\n        \"logger\": YTDLLogger(),\n        \"cookiefile\": self.cookie_file,\n        \"outtmpl\": str((get_temp_path() / \"%(id)s.%(ext)s\").resolve()),\n        \"retries\": 5,\n        \"extractor_args\": {},\n    }\n\n    if yt_dlp_args:\n        yt_dlp_options = args_to_ytdlp_options(\n            shlex.split(yt_dlp_args), yt_dlp_options\n        )\n\n    self.audio_handler = YoutubeDL(yt_dlp_options)\n</code></pre>"},{"location":"reference/providers/audio/sliderkz/#spotdl.providers.audio.sliderkz.SliderKZ.get_results","title":"<code>get_results(search_term, *_args, **_kwargs)</code>","text":"<p>Get results from slider.kz</p>"},{"location":"reference/providers/audio/sliderkz/#spotdl.providers.audio.sliderkz.SliderKZ.get_results--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to search for.</li> <li>args: Unused.</li> <li>kwargs: Unused.</li> </ul>"},{"location":"reference/providers/audio/sliderkz/#spotdl.providers.audio.sliderkz.SliderKZ.get_results--returns","title":"Returns","text":"<ul> <li>A list of slider.kz results if found, None otherwise.</li> </ul> Source code in <code>spotdl/providers/audio/sliderkz.py</code> <pre><code>def get_results(self, search_term: str, *_args, **_kwargs) -&gt; List[Result]:\n    \"\"\"\n    Get results from slider.kz\n\n    ### Arguments\n    - search_term: The search term to search for.\n    - args: Unused.\n    - kwargs: Unused.\n\n    ### Returns\n    - A list of slider.kz results if found, None otherwise.\n    \"\"\"\n\n    search_results = None\n    max_retries = 0\n\n    while not search_results and max_retries &lt; 3:\n        try:\n            search_response = requests.get(\n                url=\"https://hayqbhgr.slider.kz/vk_auth.php?q=\" + search_term,\n                headers=HEADERS,\n                timeout=5,\n                proxies=GlobalConfig.get_parameter(\"proxies\"),\n            )\n\n            # Check if the response is valid\n            if len(search_response.text) &gt; 30:\n                # Set the search results to the json response\n                # effectively breaking out of the loop\n                search_results = search_response.json()\n\n        except Exception as exc:\n            logger.debug(\n                \"Slider.kz search failed for query %s with error: %s. Retrying...\",\n                search_term,\n                exc,\n            )\n\n        max_retries += 1\n\n    if not search_results:\n        logger.debug(\"Slider.kz search failed for query %s\", search_term)\n        return []\n\n    results = []\n    for result in search_results[\"audios\"][\"\"]:\n        # urls from slider.kz sometimes are relative, so we need to add the domain\n        if \"https://\" not in result[\"url\"]:\n            result[\"url\"] = \"https://hayqbhgr.slider.kz/\" + result[\"url\"]\n\n        results.append(\n            Result(\n                source=\"slider.kz\",\n                url=result.get(\"url\"),\n                verified=False,\n                name=result.get(\"tit_art\"),\n                duration=int(result.get(\"duration\", -9999)),\n                author=\"slider.kz\",\n                result_id=result.get(\"id\"),\n                views=1,\n            )\n        )\n\n    return results\n</code></pre>"},{"location":"reference/providers/audio/soundcloud/","title":"soundcloud","text":"<p>SoundCloud module for downloading and searching songs.</p>"},{"location":"reference/providers/audio/soundcloud/#spotdl.providers.audio.soundcloud.SoundCloud","title":"<code>SoundCloud(*args, **kwargs)</code>","text":"<p>               Bases: <code>AudioProvider</code></p> <p>SoundCloud audio provider class</p>"},{"location":"reference/providers/audio/soundcloud/#spotdl.providers.audio.soundcloud.SoundCloud--arguments","title":"Arguments","text":"<ul> <li>args: Arguments passed to the <code>AudioProvider</code> class.</li> <li>kwargs: Keyword arguments passed to the <code>AudioProvider</code> class.</li> </ul> Source code in <code>spotdl/providers/audio/soundcloud.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Initialize the SoundCloud API\n\n    ### Arguments\n    - args: Arguments passed to the `AudioProvider` class.\n    - kwargs: Keyword arguments passed to the `AudioProvider` class.\n    \"\"\"\n\n    super().__init__(*args, **kwargs)\n    self.client = SoundCloudClient()\n</code></pre>"},{"location":"reference/providers/audio/soundcloud/#spotdl.providers.audio.soundcloud.SoundCloud.get_results","title":"<code>get_results(search_term, *_args, **_kwargs)</code>","text":"<p>Get results from slider.kz</p>"},{"location":"reference/providers/audio/soundcloud/#spotdl.providers.audio.soundcloud.SoundCloud.get_results--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to search for.</li> <li>args: Unused.</li> <li>kwargs: Unused.</li> </ul>"},{"location":"reference/providers/audio/soundcloud/#spotdl.providers.audio.soundcloud.SoundCloud.get_results--returns","title":"Returns","text":"<ul> <li>A list of slider.kz results if found, None otherwise.</li> </ul> Source code in <code>spotdl/providers/audio/soundcloud.py</code> <pre><code>def get_results(self, search_term: str, *_args, **_kwargs) -&gt; List[Result]:\n    \"\"\"\n    Get results from slider.kz\n\n    ### Arguments\n    - search_term: The search term to search for.\n    - args: Unused.\n    - kwargs: Unused.\n\n    ### Returns\n    - A list of slider.kz results if found, None otherwise.\n    \"\"\"\n\n    results = list(islice(self.client.search(search_term), 20))\n    regex = r\"^(.+?)-|(\\(\\w+[\\s\\S]*\\))\"\n    # Because anyone can post on soundcloud, we do another search with an edited search\n    # The regex removes anything in brackets and the artist(s)'s name(s) if in the name\n    edited_search_term = re.sub(regex, \"\", search_term)\n    results.extend(list(islice(self.client.search(edited_search_term), 20)))\n\n    # Simplify results\n    simplified_results = []\n    for result in results:\n        if not isinstance(result, Track):\n            continue\n\n        # Ignore results that are not playable\n        if \"/preview/\" in result.media.transcodings[0].url:\n            continue\n\n        album = self.client.get_track_albums(result.id)\n\n        try:\n            album_name = next(album).title\n        except StopIteration:\n            album_name = None\n\n        simplified_results.append(\n            Result(\n                source=\"soundcloud\",\n                url=result.permalink_url,\n                name=result.title,\n                verified=result.user.verified,\n                duration=result.full_duration,\n                author=result.user.username,\n                result_id=str(result.id),\n                isrc_search=False,\n                search_query=search_term,\n                views=result.playback_count,\n                explicit=False,\n                album=album_name,\n            )\n        )\n\n    return simplified_results\n</code></pre>"},{"location":"reference/providers/audio/youtube/","title":"youtube","text":"<p>Youtube module for downloading and searching songs.</p>"},{"location":"reference/providers/audio/youtube/#spotdl.providers.audio.youtube.YouTube","title":"<code>YouTube(*args, **kwargs)</code>","text":"<p>               Bases: <code>AudioProvider</code></p> <p>YouTube audio provider class</p> Source code in <code>spotdl/providers/audio/youtube.py</code> <pre><code>def __init__(self, *args, **kwargs) -&gt; None:\n    \"\"\"\n    Initialize the YouTube audio provider\n    \"\"\"\n    super().__init__(*args, **kwargs)\n\n    # Set the client version to a specific version to avoid issues with pytube\n    # See #2323 or https://github.com/pytube/pytube/issues/296\n    innertube._default_clients['WEB'][\"context\"][\"client\"][\"clientVersion\"] = \"2.20230427.04.00\"\n</code></pre>"},{"location":"reference/providers/audio/youtube/#spotdl.providers.audio.youtube.YouTube.get_results","title":"<code>get_results(search_term, *_args, **_kwargs)</code>","text":"<p>Get results from YouTube</p>"},{"location":"reference/providers/audio/youtube/#spotdl.providers.audio.youtube.YouTube.get_results--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to search for.</li> <li>args: Unused.</li> <li>kwargs: Unused.</li> </ul>"},{"location":"reference/providers/audio/youtube/#spotdl.providers.audio.youtube.YouTube.get_results--returns","title":"Returns","text":"<ul> <li>A list of YouTube results if found, None otherwise.</li> </ul> Source code in <code>spotdl/providers/audio/youtube.py</code> <pre><code>def get_results(\n    self, search_term: str, *_args, **_kwargs\n) -&gt; List[Result]:  # pylint: disable=W0221\n    \"\"\"\n    Get results from YouTube\n\n    ### Arguments\n    - search_term: The search term to search for.\n    - args: Unused.\n    - kwargs: Unused.\n\n    ### Returns\n    - A list of YouTube results if found, None otherwise.\n    \"\"\"\n\n    search_results: Optional[List[PyTube]] = Search(search_term).results\n\n    if not search_results:\n        return []\n\n    results = []\n    for result in search_results:\n        if result.watch_url:\n            try:\n                duration = result.length\n            except Exception:\n                duration = 0\n\n            try:\n                views = result.views\n            except Exception:\n                views = 0\n\n            results.append(\n                Result(\n                    source=self.name,\n                    url=result.watch_url,\n                    verified=False,\n                    name=result.title,\n                    duration=duration,\n                    author=result.author,\n                    search_query=search_term,\n                    views=views,\n                    result_id=result.video_id,\n                )\n            )\n\n    return results\n</code></pre>"},{"location":"reference/providers/audio/ytmusic/","title":"ytmusic","text":"<p>YTMusic module for downloading and searching songs.</p>"},{"location":"reference/providers/audio/ytmusic/#spotdl.providers.audio.ytmusic.YouTubeMusic","title":"<code>YouTubeMusic(*args, **kwargs)</code>","text":"<p>               Bases: <code>AudioProvider</code></p> <p>YouTube Music audio provider class</p>"},{"location":"reference/providers/audio/ytmusic/#spotdl.providers.audio.ytmusic.YouTubeMusic--arguments","title":"Arguments","text":"<ul> <li>args: Arguments passed to the <code>AudioProvider</code> class.</li> <li>kwargs: Keyword arguments passed to the <code>AudioProvider</code> class.</li> </ul> Source code in <code>spotdl/providers/audio/ytmusic.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Initialize the YouTube Music API\n\n    ### Arguments\n    - args: Arguments passed to the `AudioProvider` class.\n    - kwargs: Keyword arguments passed to the `AudioProvider` class.\n    \"\"\"\n\n    super().__init__(*args, **kwargs)\n\n    self.client = YTMusic(language=\"de\")\n</code></pre>"},{"location":"reference/providers/audio/ytmusic/#spotdl.providers.audio.ytmusic.YouTubeMusic.get_results","title":"<code>get_results(search_term, **kwargs)</code>","text":"<p>Get results from YouTube Music API and simplify them</p>"},{"location":"reference/providers/audio/ytmusic/#spotdl.providers.audio.ytmusic.YouTubeMusic.get_results--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to search for.</li> <li>kwargs: other keyword arguments passed to the <code>YTMusic.search</code> method.</li> </ul>"},{"location":"reference/providers/audio/ytmusic/#spotdl.providers.audio.ytmusic.YouTubeMusic.get_results--returns","title":"Returns","text":"<ul> <li>A list of simplified results (dicts)</li> </ul> Source code in <code>spotdl/providers/audio/ytmusic.py</code> <pre><code>def get_results(self, search_term: str, **kwargs) -&gt; List[Result]:\n    \"\"\"\n    Get results from YouTube Music API and simplify them\n\n    ### Arguments\n    - search_term: The search term to search for.\n    - kwargs: other keyword arguments passed to the `YTMusic.search` method.\n\n    ### Returns\n    - A list of simplified results (dicts)\n    \"\"\"\n\n    is_isrc_result = ISRC_REGEX.search(search_term) is not None\n    # if is_isrc_result:\n    #     print(\"FORCEFULLY SETTING FILTER TO SONGS\")\n    #     kwargs[\"filter\"] = \"songs\"\n\n    search_results = self.client.search(search_term, **kwargs)\n\n    # Simplify results\n    results = []\n    for result in search_results:\n        if (\n            result is None\n            or result.get(\"videoId\") is None\n            or result.get(\"artists\") in [[], None]\n        ):\n            continue\n\n        results.append(\n            Result(\n                source=self.name,\n                url=(\n                    f'https://{\"music\" if result[\"resultType\"] == \"song\" else \"www\"}'\n                    f\".youtube.com/watch?v={result['videoId']}\"\n                ),\n                verified=result.get(\"resultType\") == \"song\",\n                name=result[\"title\"],\n                result_id=result[\"videoId\"],\n                author=result[\"artists\"][0][\"name\"],\n                artists=tuple(map(lambda a: a[\"name\"], result[\"artists\"])),\n                duration=parse_duration(result.get(\"duration\")),\n                isrc_search=is_isrc_result,\n                search_query=search_term,\n                explicit=result.get(\"isExplicit\"),\n                album=(\n                    result.get(\"album\", {}).get(\"name\")\n                    if result.get(\"album\")\n                    else None\n                ),\n            )\n        )\n\n    return results\n</code></pre>"},{"location":"reference/providers/lyrics/","title":"lyrics","text":"<p>Lyrics providers for spotdl.</p>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.AzLyrics","title":"<code>AzLyrics()</code>","text":"<p>               Bases: <code>LyricsProvider</code></p> <p>AZLyrics lyrics provider class.</p> Source code in <code>spotdl/providers/lyrics/azlyrics.py</code> <pre><code>def __init__(self):\n    super().__init__()\n\n    self.session = requests.Session()\n    self.session.headers.update(self.headers)\n\n    self.x_code = self.get_x_code()\n</code></pre>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.AzLyrics.extract_lyrics","title":"<code>extract_lyrics(url, **_)</code>","text":"<p>Extracts the lyrics from the given url.</p>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.AzLyrics.extract_lyrics--arguments","title":"Arguments","text":"<ul> <li>url: The url to extract the lyrics from.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.AzLyrics.extract_lyrics--returns","title":"Returns","text":"<ul> <li>The lyrics of the song or None if no lyrics were found.</li> </ul> Source code in <code>spotdl/providers/lyrics/azlyrics.py</code> <pre><code>def extract_lyrics(self, url: str, **_) -&gt; Optional[str]:\n    \"\"\"\n    Extracts the lyrics from the given url.\n\n    ### Arguments\n    - url: The url to extract the lyrics from.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - The lyrics of the song or None if no lyrics were found.\n    \"\"\"\n\n    response = self.session.get(url)\n    soup = BeautifulSoup(response.content, \"html.parser\")\n\n    # Find all divs that don't have a class\n    div_tags = soup.find_all(\"div\", class_=False, id_=False)\n\n    # Find the div with the longest text\n    lyrics_div = sorted(div_tags, key=lambda x: len(x.text))[-1]\n\n    # extract lyrics from div and clean it up\n    lyrics = lyrics_div.get_text().strip()\n\n    return lyrics\n</code></pre>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.AzLyrics.get_results","title":"<code>get_results(name, artists, **_)</code>","text":"<p>Returns the results for the given song.</p>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.AzLyrics.get_results--arguments","title":"Arguments","text":"<ul> <li>name: The name of the song.</li> <li>artists: The artists of the song.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.AzLyrics.get_results--returns","title":"Returns","text":"<ul> <li>A dictionary with the results. (The key is the title and the value is the url.)</li> </ul> Source code in <code>spotdl/providers/lyrics/azlyrics.py</code> <pre><code>def get_results(self, name: str, artists: List[str], **_) -&gt; Dict[str, str]:\n    \"\"\"\n    Returns the results for the given song.\n\n    ### Arguments\n    - name: The name of the song.\n    - artists: The artists of the song.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - A dictionary with the results. (The key is the title and the value is the url.)\n    \"\"\"\n\n    if self.x_code is None:\n        self.x_code = self.get_x_code()\n\n    if self.x_code is None:\n        return {}\n\n    # Join every artist by comma in artists\n    artist_str = \", \".join(artist for artist in artists if artist)\n\n    params = {\n        \"q\": f\"{artist_str} - {name}\",\n        \"x\": self.x_code,\n    }\n\n    counter = 0\n    soup = None\n    while counter &lt; 4:\n        try:\n            response = self.session.get(\n                \"https://search.azlyrics.com/search.php\", params=params\n            )\n        except requests.ConnectionError:\n            continue\n\n        if not response.ok:\n            counter += 1\n            continue\n\n        soup = BeautifulSoup(response.content, \"html.parser\")\n        break\n\n    if soup is None:\n        return {}\n\n    td_tags = soup.find_all(\"td\")\n    if len(td_tags) == 0:\n        return {}\n\n    results = {}\n    for td_tag in td_tags:\n        a_tags = td_tag.find_all(\"a\", href=True)\n        if len(a_tags) == 0:\n            continue\n\n        a_tag = a_tags[0]\n        url = a_tag[\"href\"].strip()\n        if url == \"\":\n            continue\n\n        title = td_tag.find(\"span\").get_text().strip()\n        artist = td_tag.find(\"b\").get_text().strip()\n\n        results[f\"{artist} - {title}\"] = url\n\n    return results\n</code></pre>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.AzLyrics.get_x_code","title":"<code>get_x_code()</code>","text":"<p>Returns the x_code used by AZLyrics.</p>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.AzLyrics.get_x_code--returns","title":"Returns","text":"<ul> <li>The x_code used by AZLyrics or None if it couldn't be retrieved.</li> </ul> Source code in <code>spotdl/providers/lyrics/azlyrics.py</code> <pre><code>def get_x_code(self) -&gt; Optional[str]:\n    \"\"\"\n    Returns the x_code used by AZLyrics.\n\n    ### Returns\n    - The x_code used by AZLyrics or None if it couldn't be retrieved.\n    \"\"\"\n\n    x_code = None\n\n    try:\n        self.session.get(\"https://www.azlyrics.com/\")\n\n        resp = self.session.get(\"https://www.azlyrics.com/geo.js\")\n\n        # extract value from js code\n        js_code = resp.text\n        start_index = js_code.find('value\"') + 9\n        end_index = js_code[start_index:].find('\");')\n\n        x_code = js_code[start_index : start_index + end_index]\n    except requests.ConnectionError:\n        pass\n\n    return x_code\n</code></pre>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.Genius","title":"<code>Genius(access_token)</code>","text":"<p>               Bases: <code>LyricsProvider</code></p> <p>Genius lyrics provider class.</p> Source code in <code>spotdl/providers/lyrics/genius.py</code> <pre><code>def __init__(self, access_token: str):\n    \"\"\"\n    Init the lyrics provider search and set headers.\n    \"\"\"\n\n    super().__init__()\n\n    self.access_token = access_token\n\n    self.headers.update(\n        {\n            \"Authorization\": f\"Bearer {self.access_token}\",\n        }\n    )\n\n    self.session = requests.Session()\n    self.session.headers.update(self.headers)\n</code></pre>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.Genius.extract_lyrics","title":"<code>extract_lyrics(url, **_)</code>","text":"<p>Extracts the lyrics from the given url.</p>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.Genius.extract_lyrics--arguments","title":"Arguments","text":"<ul> <li>url: The url to extract the lyrics from.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.Genius.extract_lyrics--returns","title":"Returns","text":"<ul> <li>The lyrics of the song or None if no lyrics were found.</li> </ul> Source code in <code>spotdl/providers/lyrics/genius.py</code> <pre><code>def extract_lyrics(self, url: str, **_) -&gt; Optional[str]:\n    \"\"\"\n    Extracts the lyrics from the given url.\n\n    ### Arguments\n    - url: The url to extract the lyrics from.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - The lyrics of the song or None if no lyrics were found.\n    \"\"\"\n\n    url = f\"https://api.genius.com/songs/{url}\"\n    song_response = self.session.get(\n        url,\n        headers=self.headers,\n        timeout=10,\n        proxies=GlobalConfig.get_parameter(\"proxies\"),\n    )\n    url = song_response.json()[\"response\"][\"song\"][\"url\"]\n\n    soup = None\n    counter = 0\n    while counter &lt; 4:\n        genius_page_response = self.session.get(\n            url,\n            headers=self.headers,\n            timeout=10,\n            proxies=GlobalConfig.get_parameter(\"proxies\"),\n        )\n\n        if not genius_page_response.ok:\n            counter += 1\n            continue\n\n        soup = BeautifulSoup(\n            genius_page_response.text.replace(\"&lt;br/&gt;\", \"\\n\"), \"html.parser\"\n        )\n\n        break\n\n    if soup is None:\n        return None\n\n    lyrics_div = soup.select_one(\"div.lyrics\")\n    lyrics_containers = soup.select(\"div[class^=Lyrics__Container]\")\n\n    # Get lyrics\n    if lyrics_div:\n        lyrics = lyrics_div.get_text()\n    elif lyrics_containers:\n        lyrics = \"\\n\".join(con.get_text() for con in lyrics_containers)\n    else:\n        return None\n\n    if not lyrics:\n        return None\n\n    # Clean lyrics\n    lyrics = lyrics.strip()\n\n    # Remove desc at the beginning if it exists\n    for to_remove in [\"desc\", \"Desc\"]:\n        lyrics.replace(to_remove, \"\", 1)\n\n    return lyrics\n</code></pre>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.Genius.get_results","title":"<code>get_results(name, artists, **_)</code>","text":"<p>Returns the results for the given song.</p>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.Genius.get_results--arguments","title":"Arguments","text":"<ul> <li>name: The name of the song.</li> <li>artists: The artists of the song.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.Genius.get_results--returns","title":"Returns","text":"<ul> <li>A dictionary with the results. (The key is the title and the value is the url.)</li> </ul> Source code in <code>spotdl/providers/lyrics/genius.py</code> <pre><code>def get_results(self, name: str, artists: List[str], **_) -&gt; Dict[str, str]:\n    \"\"\"\n    Returns the results for the given song.\n\n    ### Arguments\n    - name: The name of the song.\n    - artists: The artists of the song.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - A dictionary with the results. (The key is the title and the value is the url.)\n    \"\"\"\n\n    artists_str = \", \".join(artists)\n    title = f\"{name} - {artists_str}\"\n\n    search_response = self.session.get(\n        \"https://api.genius.com/search\",\n        params={\"q\": title},\n        headers=self.headers,\n        timeout=10,\n        proxies=GlobalConfig.get_parameter(\"proxies\"),\n    )\n\n    results: Dict[str, str] = {}\n    for hit in search_response.json()[\"response\"][\"hits\"]:\n        results[hit[\"result\"][\"full_title\"]] = hit[\"result\"][\"id\"]\n\n    return results\n</code></pre>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.LyricsProvider","title":"<code>LyricsProvider()</code>","text":"<p>Base class for all other lyrics providers.</p> Source code in <code>spotdl/providers/lyrics/base.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Init the lyrics provider searchand set headers.\n    \"\"\"\n\n    self.headers = {\n        \"Connection\": \"keep-alive\",\n        \"Pragma\": \"no-cache\",\n        \"Cache-Control\": \"no-cache\",\n        \"sec-ch-ua\": '\"Chromium\";v=\"104\", \" Not A;Brand\";v=\"99\", \"Google Chrome\";v=\"104\"',\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 \"\n        \"(KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36\",\n        \"Accept\": \"*/*\",\n        \"Sec-Fetch-Site\": \"same-origin\",\n        \"Sec-Fetch-Mode\": \"cors\",\n        \"Sec-Fetch-Dest\": \"empty\",\n        \"Accept-Language\": \"en-US;q=0.8,en;q=0.7\",\n    }\n</code></pre>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.LyricsProvider.name","title":"<code>name</code>  <code>property</code>","text":"<p>Returns the name of the lyrics provider.</p>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.LyricsProvider.extract_lyrics","title":"<code>extract_lyrics(url, **kwargs)</code>","text":"<p>Extracts the lyrics from the given url.</p>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.LyricsProvider.extract_lyrics--arguments","title":"Arguments","text":"<ul> <li>url: The url to extract the lyrics from.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.LyricsProvider.extract_lyrics--returns","title":"Returns","text":"<ul> <li>The lyrics of the song or None if no lyrics were found.</li> </ul> Source code in <code>spotdl/providers/lyrics/base.py</code> <pre><code>def extract_lyrics(self, url: str, **kwargs) -&gt; Optional[str]:\n    \"\"\"\n    Extracts the lyrics from the given url.\n\n    ### Arguments\n    - url: The url to extract the lyrics from.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - The lyrics of the song or None if no lyrics were found.\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.LyricsProvider.get_lyrics","title":"<code>get_lyrics(name, artists, **kwargs)</code>","text":"<p>Returns the lyrics for the given song.</p>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.LyricsProvider.get_lyrics--arguments","title":"Arguments","text":"<ul> <li>name: The name of the song.</li> <li>artists: The artists of the song.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.LyricsProvider.get_lyrics--returns","title":"Returns","text":"<ul> <li>The lyrics of the song or None if no lyrics were found.</li> </ul> Source code in <code>spotdl/providers/lyrics/base.py</code> <pre><code>def get_lyrics(self, name: str, artists: List[str], **kwargs) -&gt; Optional[str]:\n    \"\"\"\n    Returns the lyrics for the given song.\n\n    ### Arguments\n    - name: The name of the song.\n    - artists: The artists of the song.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - The lyrics of the song or None if no lyrics were found.\n    \"\"\"\n    try:\n        results = self.get_results(name, artists, **kwargs)\n    except Exception as exc:\n        logger.debug(\n            \"%s: Failed to get results for %s - %s: %s\",\n            self.name,\n            name,\n            \", \".join(artists),\n            exc,\n        )\n        return None\n\n    if not results:\n        return None\n\n    results_with_score = {}\n    for title, url in results.items():\n        result_title = slugify(title)\n        match_title = slugify(f\"{name} - {', '.join(artists)}\")\n\n        res_list, song_list = based_sort(\n            result_title.split(\"-\"), match_title.split(\"-\")\n        )\n        result_title, match_title = \"-\".join(res_list), \"-\".join(song_list)\n\n        score = ratio(result_title, match_title)\n        results_with_score[score] = url\n\n    if not results_with_score:\n        return None\n\n    # Get song url with highest title match\n    score, url = max(results_with_score.items(), key=lambda x: x[0])\n\n    # Only return lyrics if the title match is at least 55%\n    if score &lt; 55:\n        return None\n\n    try:\n        return self.extract_lyrics(url, **kwargs)\n    except Exception as exc:\n        logger.debug(\n            \"%s: Failed to extract lyrics from %s: %s\", self.name, url, exc\n        )\n        return None\n</code></pre>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.LyricsProvider.get_results","title":"<code>get_results(name, artists, **kwargs)</code>","text":"<p>Returns the results for the given song.</p>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.LyricsProvider.get_results--arguments","title":"Arguments","text":"<ul> <li>name: The name of the song.</li> <li>artists: The artists of the song.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.LyricsProvider.get_results--returns","title":"Returns","text":"<ul> <li>A dictionary with the results. (The key is the title and the value is the url.)</li> </ul> Source code in <code>spotdl/providers/lyrics/base.py</code> <pre><code>def get_results(self, name: str, artists: List[str], **kwargs) -&gt; Dict[str, str]:\n    \"\"\"\n    Returns the results for the given song.\n\n    ### Arguments\n    - name: The name of the song.\n    - artists: The artists of the song.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - A dictionary with the results. (The key is the title and the value is the url.)\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.MusixMatch","title":"<code>MusixMatch()</code>","text":"<p>               Bases: <code>LyricsProvider</code></p> <p>MusixMatch lyrics provider class.</p> Source code in <code>spotdl/providers/lyrics/base.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Init the lyrics provider searchand set headers.\n    \"\"\"\n\n    self.headers = {\n        \"Connection\": \"keep-alive\",\n        \"Pragma\": \"no-cache\",\n        \"Cache-Control\": \"no-cache\",\n        \"sec-ch-ua\": '\"Chromium\";v=\"104\", \" Not A;Brand\";v=\"99\", \"Google Chrome\";v=\"104\"',\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 \"\n        \"(KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36\",\n        \"Accept\": \"*/*\",\n        \"Sec-Fetch-Site\": \"same-origin\",\n        \"Sec-Fetch-Mode\": \"cors\",\n        \"Sec-Fetch-Dest\": \"empty\",\n        \"Accept-Language\": \"en-US;q=0.8,en;q=0.7\",\n    }\n</code></pre>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.MusixMatch.extract_lyrics","title":"<code>extract_lyrics(url, **_)</code>","text":"<p>Extracts the lyrics from the given url.</p>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.MusixMatch.extract_lyrics--arguments","title":"Arguments","text":"<ul> <li>url: The url to extract the lyrics from.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.MusixMatch.extract_lyrics--returns","title":"Returns","text":"<ul> <li>The lyrics of the song or None if no lyrics were found.</li> </ul> Source code in <code>spotdl/providers/lyrics/musixmatch.py</code> <pre><code>def extract_lyrics(self, url: str, **_) -&gt; Optional[str]:\n    \"\"\"\n    Extracts the lyrics from the given url.\n\n    ### Arguments\n    - url: The url to extract the lyrics from.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - The lyrics of the song or None if no lyrics were found.\n    \"\"\"\n\n    lyrics_resp = requests.get(\n        url,\n        headers=self.headers,\n        timeout=10,\n        proxies=GlobalConfig.get_parameter(\"proxies\"),\n    )\n\n    lyrics_soup = BeautifulSoup(lyrics_resp.text, \"html.parser\")\n    lyrics_paragraphs = lyrics_soup.select(\"p.mxm-lyrics__content\")\n    lyrics = \"\\n\".join(i.get_text() for i in lyrics_paragraphs)\n\n    return lyrics\n</code></pre>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.MusixMatch.get_results","title":"<code>get_results(name, artists, **kwargs)</code>","text":"<p>Returns the results for the given song.</p>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.MusixMatch.get_results--arguments","title":"Arguments","text":"<ul> <li>name: The name of the song.</li> <li>artists: The artists of the song.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.MusixMatch.get_results--returns","title":"Returns","text":"<ul> <li>A dictionary with the results. (The key is the title and the value is the url.)</li> </ul> Source code in <code>spotdl/providers/lyrics/musixmatch.py</code> <pre><code>def get_results(self, name: str, artists: List[str], **kwargs) -&gt; Dict[str, str]:\n    \"\"\"\n    Returns the results for the given song.\n\n    ### Arguments\n    - name: The name of the song.\n    - artists: The artists of the song.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - A dictionary with the results. (The key is the title and the value is the url.)\n    \"\"\"\n\n    track_search = kwargs.get(\"track_search\", False)\n    artists_str = \", \".join(\n        artist for artist in artists if artist.lower() not in name.lower()\n    )\n\n    # quote the query so that it's safe to use in a url\n    # e.g \"Au/Ra\" -&gt; \"Au%2FRa\"\n    query = quote(f\"{name} - {artists_str}\", safe=\"\")\n\n    # search the `tracks page` if track_search is True\n    if track_search:\n        query += \"/tracks\"\n\n    search_url = f\"https://www.musixmatch.com/search/{query}\"\n    search_resp = requests.get(\n        search_url,\n        headers=self.headers,\n        timeout=10,\n        proxies=GlobalConfig.get_parameter(\"proxies\"),\n    )\n    search_soup = BeautifulSoup(search_resp.text, \"html.parser\")\n    song_url_tag = search_soup.select(\"a[href^='/lyrics/']\")\n\n    if not song_url_tag:\n        # song_url_tag being None means no results were found on the\n        # All Results page, therefore, we use `track_search` to\n        # search the tracks page.\n\n        # track_serach being True means we are already searching the tracks page.\n        if track_search:\n            return {}\n\n        return self.get_results(name, artists, track_search=True)\n\n    results: Dict[str, str] = {}\n    for tag in song_url_tag:\n        results[tag.get_text()] = \"https://www.musixmatch.com\" + str(\n            tag.get(\"href\", \"\")\n        )\n\n    return results\n</code></pre>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.Synced","title":"<code>Synced()</code>","text":"<p>               Bases: <code>LyricsProvider</code></p> <p>Lyrics provider for synced lyrics using the syncedlyrics library Currently supported websites: Deezer, NetEase</p> Source code in <code>spotdl/providers/lyrics/base.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Init the lyrics provider searchand set headers.\n    \"\"\"\n\n    self.headers = {\n        \"Connection\": \"keep-alive\",\n        \"Pragma\": \"no-cache\",\n        \"Cache-Control\": \"no-cache\",\n        \"sec-ch-ua\": '\"Chromium\";v=\"104\", \" Not A;Brand\";v=\"99\", \"Google Chrome\";v=\"104\"',\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 \"\n        \"(KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36\",\n        \"Accept\": \"*/*\",\n        \"Sec-Fetch-Site\": \"same-origin\",\n        \"Sec-Fetch-Mode\": \"cors\",\n        \"Sec-Fetch-Dest\": \"empty\",\n        \"Accept-Language\": \"en-US;q=0.8,en;q=0.7\",\n    }\n</code></pre>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.Synced.extract_lyrics","title":"<code>extract_lyrics(url, **kwargs)</code>","text":"<p>Extracts the lyrics from the given url.</p>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.Synced.extract_lyrics--arguments","title":"Arguments","text":"<ul> <li>url: The url to extract the lyrics from.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.Synced.extract_lyrics--returns","title":"Returns","text":"<ul> <li>The lyrics of the song or None if no lyrics were found.</li> </ul> Source code in <code>spotdl/providers/lyrics/synced.py</code> <pre><code>def extract_lyrics(self, url: str, **kwargs) -&gt; Optional[str]:\n    \"\"\"\n    Extracts the lyrics from the given url.\n\n    ### Arguments\n    - url: The url to extract the lyrics from.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - The lyrics of the song or None if no lyrics were found.\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.Synced.get_lyrics","title":"<code>get_lyrics(name, artists, **kwargs)</code>","text":"<p>Try to get lyrics using syncedlyrics</p>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.Synced.get_lyrics--arguments","title":"Arguments","text":"<ul> <li>name: The name of the song.</li> <li>artists: The artists of the song.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.Synced.get_lyrics--returns","title":"Returns","text":"<ul> <li>The lyrics of the song or None if no lyrics were found.</li> </ul> Source code in <code>spotdl/providers/lyrics/synced.py</code> <pre><code>def get_lyrics(self, name: str, artists: List[str], **kwargs) -&gt; Optional[str]:\n    \"\"\"\n    Try to get lyrics using syncedlyrics\n\n    ### Arguments\n    - name: The name of the song.\n    - artists: The artists of the song.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - The lyrics of the song or None if no lyrics were found.\n    \"\"\"\n\n    try:\n        lyrics = syncedlyrics.search(\n            f\"{name} - {artists[0]}\",\n            synced_only=not kwargs.get(\"allow_plain_format\", True),\n        )\n        return lyrics\n    except requests.exceptions.SSLError:\n        # Max retries reached\n        return None\n    except TypeError:\n        # Error at syncedlyrics.providers.musixmatch L89 -\n        #   Because `body` is occasionally an empty list instead of a dictionary.\n        # We get this error when allow_plain_format is set to True,\n        #   and there are no synced lyrics present\n        # Because its empty, we know there are no lyrics\n        return None\n</code></pre>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.Synced.get_results","title":"<code>get_results(name, artists, **kwargs)</code>","text":"<p>Returns the results for the given song.</p>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.Synced.get_results--arguments","title":"Arguments","text":"<ul> <li>name: The name of the song.</li> <li>artists: The artists of the song.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/lyrics/#spotdl.providers.lyrics.Synced.get_results--returns","title":"Returns","text":"<ul> <li>A dictionary with the results. (The key is the title and the value is the url.)</li> </ul> Source code in <code>spotdl/providers/lyrics/synced.py</code> <pre><code>def get_results(self, name: str, artists: List[str], **kwargs) -&gt; Dict[str, str]:\n    \"\"\"\n    Returns the results for the given song.\n\n    ### Arguments\n    - name: The name of the song.\n    - artists: The artists of the song.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - A dictionary with the results. (The key is the title and the value is the url.)\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/providers/lyrics/azlyrics/","title":"azlyrics","text":"<p>AZLyrics lyrics module.</p>"},{"location":"reference/providers/lyrics/azlyrics/#spotdl.providers.lyrics.azlyrics.AzLyrics","title":"<code>AzLyrics()</code>","text":"<p>               Bases: <code>LyricsProvider</code></p> <p>AZLyrics lyrics provider class.</p> Source code in <code>spotdl/providers/lyrics/azlyrics.py</code> <pre><code>def __init__(self):\n    super().__init__()\n\n    self.session = requests.Session()\n    self.session.headers.update(self.headers)\n\n    self.x_code = self.get_x_code()\n</code></pre>"},{"location":"reference/providers/lyrics/azlyrics/#spotdl.providers.lyrics.azlyrics.AzLyrics.extract_lyrics","title":"<code>extract_lyrics(url, **_)</code>","text":"<p>Extracts the lyrics from the given url.</p>"},{"location":"reference/providers/lyrics/azlyrics/#spotdl.providers.lyrics.azlyrics.AzLyrics.extract_lyrics--arguments","title":"Arguments","text":"<ul> <li>url: The url to extract the lyrics from.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/lyrics/azlyrics/#spotdl.providers.lyrics.azlyrics.AzLyrics.extract_lyrics--returns","title":"Returns","text":"<ul> <li>The lyrics of the song or None if no lyrics were found.</li> </ul> Source code in <code>spotdl/providers/lyrics/azlyrics.py</code> <pre><code>def extract_lyrics(self, url: str, **_) -&gt; Optional[str]:\n    \"\"\"\n    Extracts the lyrics from the given url.\n\n    ### Arguments\n    - url: The url to extract the lyrics from.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - The lyrics of the song or None if no lyrics were found.\n    \"\"\"\n\n    response = self.session.get(url)\n    soup = BeautifulSoup(response.content, \"html.parser\")\n\n    # Find all divs that don't have a class\n    div_tags = soup.find_all(\"div\", class_=False, id_=False)\n\n    # Find the div with the longest text\n    lyrics_div = sorted(div_tags, key=lambda x: len(x.text))[-1]\n\n    # extract lyrics from div and clean it up\n    lyrics = lyrics_div.get_text().strip()\n\n    return lyrics\n</code></pre>"},{"location":"reference/providers/lyrics/azlyrics/#spotdl.providers.lyrics.azlyrics.AzLyrics.get_results","title":"<code>get_results(name, artists, **_)</code>","text":"<p>Returns the results for the given song.</p>"},{"location":"reference/providers/lyrics/azlyrics/#spotdl.providers.lyrics.azlyrics.AzLyrics.get_results--arguments","title":"Arguments","text":"<ul> <li>name: The name of the song.</li> <li>artists: The artists of the song.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/lyrics/azlyrics/#spotdl.providers.lyrics.azlyrics.AzLyrics.get_results--returns","title":"Returns","text":"<ul> <li>A dictionary with the results. (The key is the title and the value is the url.)</li> </ul> Source code in <code>spotdl/providers/lyrics/azlyrics.py</code> <pre><code>def get_results(self, name: str, artists: List[str], **_) -&gt; Dict[str, str]:\n    \"\"\"\n    Returns the results for the given song.\n\n    ### Arguments\n    - name: The name of the song.\n    - artists: The artists of the song.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - A dictionary with the results. (The key is the title and the value is the url.)\n    \"\"\"\n\n    if self.x_code is None:\n        self.x_code = self.get_x_code()\n\n    if self.x_code is None:\n        return {}\n\n    # Join every artist by comma in artists\n    artist_str = \", \".join(artist for artist in artists if artist)\n\n    params = {\n        \"q\": f\"{artist_str} - {name}\",\n        \"x\": self.x_code,\n    }\n\n    counter = 0\n    soup = None\n    while counter &lt; 4:\n        try:\n            response = self.session.get(\n                \"https://search.azlyrics.com/search.php\", params=params\n            )\n        except requests.ConnectionError:\n            continue\n\n        if not response.ok:\n            counter += 1\n            continue\n\n        soup = BeautifulSoup(response.content, \"html.parser\")\n        break\n\n    if soup is None:\n        return {}\n\n    td_tags = soup.find_all(\"td\")\n    if len(td_tags) == 0:\n        return {}\n\n    results = {}\n    for td_tag in td_tags:\n        a_tags = td_tag.find_all(\"a\", href=True)\n        if len(a_tags) == 0:\n            continue\n\n        a_tag = a_tags[0]\n        url = a_tag[\"href\"].strip()\n        if url == \"\":\n            continue\n\n        title = td_tag.find(\"span\").get_text().strip()\n        artist = td_tag.find(\"b\").get_text().strip()\n\n        results[f\"{artist} - {title}\"] = url\n\n    return results\n</code></pre>"},{"location":"reference/providers/lyrics/azlyrics/#spotdl.providers.lyrics.azlyrics.AzLyrics.get_x_code","title":"<code>get_x_code()</code>","text":"<p>Returns the x_code used by AZLyrics.</p>"},{"location":"reference/providers/lyrics/azlyrics/#spotdl.providers.lyrics.azlyrics.AzLyrics.get_x_code--returns","title":"Returns","text":"<ul> <li>The x_code used by AZLyrics or None if it couldn't be retrieved.</li> </ul> Source code in <code>spotdl/providers/lyrics/azlyrics.py</code> <pre><code>def get_x_code(self) -&gt; Optional[str]:\n    \"\"\"\n    Returns the x_code used by AZLyrics.\n\n    ### Returns\n    - The x_code used by AZLyrics or None if it couldn't be retrieved.\n    \"\"\"\n\n    x_code = None\n\n    try:\n        self.session.get(\"https://www.azlyrics.com/\")\n\n        resp = self.session.get(\"https://www.azlyrics.com/geo.js\")\n\n        # extract value from js code\n        js_code = resp.text\n        start_index = js_code.find('value\"') + 9\n        end_index = js_code[start_index:].find('\");')\n\n        x_code = js_code[start_index : start_index + end_index]\n    except requests.ConnectionError:\n        pass\n\n    return x_code\n</code></pre>"},{"location":"reference/providers/lyrics/base/","title":"base","text":"<p>Base module for all other lyrics providers.</p>"},{"location":"reference/providers/lyrics/base/#spotdl.providers.lyrics.base.LyricsProvider","title":"<code>LyricsProvider()</code>","text":"<p>Base class for all other lyrics providers.</p> Source code in <code>spotdl/providers/lyrics/base.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Init the lyrics provider searchand set headers.\n    \"\"\"\n\n    self.headers = {\n        \"Connection\": \"keep-alive\",\n        \"Pragma\": \"no-cache\",\n        \"Cache-Control\": \"no-cache\",\n        \"sec-ch-ua\": '\"Chromium\";v=\"104\", \" Not A;Brand\";v=\"99\", \"Google Chrome\";v=\"104\"',\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 \"\n        \"(KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36\",\n        \"Accept\": \"*/*\",\n        \"Sec-Fetch-Site\": \"same-origin\",\n        \"Sec-Fetch-Mode\": \"cors\",\n        \"Sec-Fetch-Dest\": \"empty\",\n        \"Accept-Language\": \"en-US;q=0.8,en;q=0.7\",\n    }\n</code></pre>"},{"location":"reference/providers/lyrics/base/#spotdl.providers.lyrics.base.LyricsProvider.name","title":"<code>name</code>  <code>property</code>","text":"<p>Returns the name of the lyrics provider.</p>"},{"location":"reference/providers/lyrics/base/#spotdl.providers.lyrics.base.LyricsProvider.extract_lyrics","title":"<code>extract_lyrics(url, **kwargs)</code>","text":"<p>Extracts the lyrics from the given url.</p>"},{"location":"reference/providers/lyrics/base/#spotdl.providers.lyrics.base.LyricsProvider.extract_lyrics--arguments","title":"Arguments","text":"<ul> <li>url: The url to extract the lyrics from.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/lyrics/base/#spotdl.providers.lyrics.base.LyricsProvider.extract_lyrics--returns","title":"Returns","text":"<ul> <li>The lyrics of the song or None if no lyrics were found.</li> </ul> Source code in <code>spotdl/providers/lyrics/base.py</code> <pre><code>def extract_lyrics(self, url: str, **kwargs) -&gt; Optional[str]:\n    \"\"\"\n    Extracts the lyrics from the given url.\n\n    ### Arguments\n    - url: The url to extract the lyrics from.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - The lyrics of the song or None if no lyrics were found.\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/providers/lyrics/base/#spotdl.providers.lyrics.base.LyricsProvider.get_lyrics","title":"<code>get_lyrics(name, artists, **kwargs)</code>","text":"<p>Returns the lyrics for the given song.</p>"},{"location":"reference/providers/lyrics/base/#spotdl.providers.lyrics.base.LyricsProvider.get_lyrics--arguments","title":"Arguments","text":"<ul> <li>name: The name of the song.</li> <li>artists: The artists of the song.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/lyrics/base/#spotdl.providers.lyrics.base.LyricsProvider.get_lyrics--returns","title":"Returns","text":"<ul> <li>The lyrics of the song or None if no lyrics were found.</li> </ul> Source code in <code>spotdl/providers/lyrics/base.py</code> <pre><code>def get_lyrics(self, name: str, artists: List[str], **kwargs) -&gt; Optional[str]:\n    \"\"\"\n    Returns the lyrics for the given song.\n\n    ### Arguments\n    - name: The name of the song.\n    - artists: The artists of the song.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - The lyrics of the song or None if no lyrics were found.\n    \"\"\"\n    try:\n        results = self.get_results(name, artists, **kwargs)\n    except Exception as exc:\n        logger.debug(\n            \"%s: Failed to get results for %s - %s: %s\",\n            self.name,\n            name,\n            \", \".join(artists),\n            exc,\n        )\n        return None\n\n    if not results:\n        return None\n\n    results_with_score = {}\n    for title, url in results.items():\n        result_title = slugify(title)\n        match_title = slugify(f\"{name} - {', '.join(artists)}\")\n\n        res_list, song_list = based_sort(\n            result_title.split(\"-\"), match_title.split(\"-\")\n        )\n        result_title, match_title = \"-\".join(res_list), \"-\".join(song_list)\n\n        score = ratio(result_title, match_title)\n        results_with_score[score] = url\n\n    if not results_with_score:\n        return None\n\n    # Get song url with highest title match\n    score, url = max(results_with_score.items(), key=lambda x: x[0])\n\n    # Only return lyrics if the title match is at least 55%\n    if score &lt; 55:\n        return None\n\n    try:\n        return self.extract_lyrics(url, **kwargs)\n    except Exception as exc:\n        logger.debug(\n            \"%s: Failed to extract lyrics from %s: %s\", self.name, url, exc\n        )\n        return None\n</code></pre>"},{"location":"reference/providers/lyrics/base/#spotdl.providers.lyrics.base.LyricsProvider.get_results","title":"<code>get_results(name, artists, **kwargs)</code>","text":"<p>Returns the results for the given song.</p>"},{"location":"reference/providers/lyrics/base/#spotdl.providers.lyrics.base.LyricsProvider.get_results--arguments","title":"Arguments","text":"<ul> <li>name: The name of the song.</li> <li>artists: The artists of the song.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/lyrics/base/#spotdl.providers.lyrics.base.LyricsProvider.get_results--returns","title":"Returns","text":"<ul> <li>A dictionary with the results. (The key is the title and the value is the url.)</li> </ul> Source code in <code>spotdl/providers/lyrics/base.py</code> <pre><code>def get_results(self, name: str, artists: List[str], **kwargs) -&gt; Dict[str, str]:\n    \"\"\"\n    Returns the results for the given song.\n\n    ### Arguments\n    - name: The name of the song.\n    - artists: The artists of the song.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - A dictionary with the results. (The key is the title and the value is the url.)\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/providers/lyrics/genius/","title":"genius","text":"<p>Genius Lyrics module.</p>"},{"location":"reference/providers/lyrics/genius/#spotdl.providers.lyrics.genius.Genius","title":"<code>Genius(access_token)</code>","text":"<p>               Bases: <code>LyricsProvider</code></p> <p>Genius lyrics provider class.</p> Source code in <code>spotdl/providers/lyrics/genius.py</code> <pre><code>def __init__(self, access_token: str):\n    \"\"\"\n    Init the lyrics provider search and set headers.\n    \"\"\"\n\n    super().__init__()\n\n    self.access_token = access_token\n\n    self.headers.update(\n        {\n            \"Authorization\": f\"Bearer {self.access_token}\",\n        }\n    )\n\n    self.session = requests.Session()\n    self.session.headers.update(self.headers)\n</code></pre>"},{"location":"reference/providers/lyrics/genius/#spotdl.providers.lyrics.genius.Genius.extract_lyrics","title":"<code>extract_lyrics(url, **_)</code>","text":"<p>Extracts the lyrics from the given url.</p>"},{"location":"reference/providers/lyrics/genius/#spotdl.providers.lyrics.genius.Genius.extract_lyrics--arguments","title":"Arguments","text":"<ul> <li>url: The url to extract the lyrics from.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/lyrics/genius/#spotdl.providers.lyrics.genius.Genius.extract_lyrics--returns","title":"Returns","text":"<ul> <li>The lyrics of the song or None if no lyrics were found.</li> </ul> Source code in <code>spotdl/providers/lyrics/genius.py</code> <pre><code>def extract_lyrics(self, url: str, **_) -&gt; Optional[str]:\n    \"\"\"\n    Extracts the lyrics from the given url.\n\n    ### Arguments\n    - url: The url to extract the lyrics from.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - The lyrics of the song or None if no lyrics were found.\n    \"\"\"\n\n    url = f\"https://api.genius.com/songs/{url}\"\n    song_response = self.session.get(\n        url,\n        headers=self.headers,\n        timeout=10,\n        proxies=GlobalConfig.get_parameter(\"proxies\"),\n    )\n    url = song_response.json()[\"response\"][\"song\"][\"url\"]\n\n    soup = None\n    counter = 0\n    while counter &lt; 4:\n        genius_page_response = self.session.get(\n            url,\n            headers=self.headers,\n            timeout=10,\n            proxies=GlobalConfig.get_parameter(\"proxies\"),\n        )\n\n        if not genius_page_response.ok:\n            counter += 1\n            continue\n\n        soup = BeautifulSoup(\n            genius_page_response.text.replace(\"&lt;br/&gt;\", \"\\n\"), \"html.parser\"\n        )\n\n        break\n\n    if soup is None:\n        return None\n\n    lyrics_div = soup.select_one(\"div.lyrics\")\n    lyrics_containers = soup.select(\"div[class^=Lyrics__Container]\")\n\n    # Get lyrics\n    if lyrics_div:\n        lyrics = lyrics_div.get_text()\n    elif lyrics_containers:\n        lyrics = \"\\n\".join(con.get_text() for con in lyrics_containers)\n    else:\n        return None\n\n    if not lyrics:\n        return None\n\n    # Clean lyrics\n    lyrics = lyrics.strip()\n\n    # Remove desc at the beginning if it exists\n    for to_remove in [\"desc\", \"Desc\"]:\n        lyrics.replace(to_remove, \"\", 1)\n\n    return lyrics\n</code></pre>"},{"location":"reference/providers/lyrics/genius/#spotdl.providers.lyrics.genius.Genius.get_results","title":"<code>get_results(name, artists, **_)</code>","text":"<p>Returns the results for the given song.</p>"},{"location":"reference/providers/lyrics/genius/#spotdl.providers.lyrics.genius.Genius.get_results--arguments","title":"Arguments","text":"<ul> <li>name: The name of the song.</li> <li>artists: The artists of the song.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/lyrics/genius/#spotdl.providers.lyrics.genius.Genius.get_results--returns","title":"Returns","text":"<ul> <li>A dictionary with the results. (The key is the title and the value is the url.)</li> </ul> Source code in <code>spotdl/providers/lyrics/genius.py</code> <pre><code>def get_results(self, name: str, artists: List[str], **_) -&gt; Dict[str, str]:\n    \"\"\"\n    Returns the results for the given song.\n\n    ### Arguments\n    - name: The name of the song.\n    - artists: The artists of the song.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - A dictionary with the results. (The key is the title and the value is the url.)\n    \"\"\"\n\n    artists_str = \", \".join(artists)\n    title = f\"{name} - {artists_str}\"\n\n    search_response = self.session.get(\n        \"https://api.genius.com/search\",\n        params={\"q\": title},\n        headers=self.headers,\n        timeout=10,\n        proxies=GlobalConfig.get_parameter(\"proxies\"),\n    )\n\n    results: Dict[str, str] = {}\n    for hit in search_response.json()[\"response\"][\"hits\"]:\n        results[hit[\"result\"][\"full_title\"]] = hit[\"result\"][\"id\"]\n\n    return results\n</code></pre>"},{"location":"reference/providers/lyrics/musixmatch/","title":"musixmatch","text":"<p>MusixMatch lyrics provider.</p>"},{"location":"reference/providers/lyrics/musixmatch/#spotdl.providers.lyrics.musixmatch.MusixMatch","title":"<code>MusixMatch()</code>","text":"<p>               Bases: <code>LyricsProvider</code></p> <p>MusixMatch lyrics provider class.</p> Source code in <code>spotdl/providers/lyrics/base.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Init the lyrics provider searchand set headers.\n    \"\"\"\n\n    self.headers = {\n        \"Connection\": \"keep-alive\",\n        \"Pragma\": \"no-cache\",\n        \"Cache-Control\": \"no-cache\",\n        \"sec-ch-ua\": '\"Chromium\";v=\"104\", \" Not A;Brand\";v=\"99\", \"Google Chrome\";v=\"104\"',\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 \"\n        \"(KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36\",\n        \"Accept\": \"*/*\",\n        \"Sec-Fetch-Site\": \"same-origin\",\n        \"Sec-Fetch-Mode\": \"cors\",\n        \"Sec-Fetch-Dest\": \"empty\",\n        \"Accept-Language\": \"en-US;q=0.8,en;q=0.7\",\n    }\n</code></pre>"},{"location":"reference/providers/lyrics/musixmatch/#spotdl.providers.lyrics.musixmatch.MusixMatch.extract_lyrics","title":"<code>extract_lyrics(url, **_)</code>","text":"<p>Extracts the lyrics from the given url.</p>"},{"location":"reference/providers/lyrics/musixmatch/#spotdl.providers.lyrics.musixmatch.MusixMatch.extract_lyrics--arguments","title":"Arguments","text":"<ul> <li>url: The url to extract the lyrics from.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/lyrics/musixmatch/#spotdl.providers.lyrics.musixmatch.MusixMatch.extract_lyrics--returns","title":"Returns","text":"<ul> <li>The lyrics of the song or None if no lyrics were found.</li> </ul> Source code in <code>spotdl/providers/lyrics/musixmatch.py</code> <pre><code>def extract_lyrics(self, url: str, **_) -&gt; Optional[str]:\n    \"\"\"\n    Extracts the lyrics from the given url.\n\n    ### Arguments\n    - url: The url to extract the lyrics from.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - The lyrics of the song or None if no lyrics were found.\n    \"\"\"\n\n    lyrics_resp = requests.get(\n        url,\n        headers=self.headers,\n        timeout=10,\n        proxies=GlobalConfig.get_parameter(\"proxies\"),\n    )\n\n    lyrics_soup = BeautifulSoup(lyrics_resp.text, \"html.parser\")\n    lyrics_paragraphs = lyrics_soup.select(\"p.mxm-lyrics__content\")\n    lyrics = \"\\n\".join(i.get_text() for i in lyrics_paragraphs)\n\n    return lyrics\n</code></pre>"},{"location":"reference/providers/lyrics/musixmatch/#spotdl.providers.lyrics.musixmatch.MusixMatch.get_results","title":"<code>get_results(name, artists, **kwargs)</code>","text":"<p>Returns the results for the given song.</p>"},{"location":"reference/providers/lyrics/musixmatch/#spotdl.providers.lyrics.musixmatch.MusixMatch.get_results--arguments","title":"Arguments","text":"<ul> <li>name: The name of the song.</li> <li>artists: The artists of the song.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/lyrics/musixmatch/#spotdl.providers.lyrics.musixmatch.MusixMatch.get_results--returns","title":"Returns","text":"<ul> <li>A dictionary with the results. (The key is the title and the value is the url.)</li> </ul> Source code in <code>spotdl/providers/lyrics/musixmatch.py</code> <pre><code>def get_results(self, name: str, artists: List[str], **kwargs) -&gt; Dict[str, str]:\n    \"\"\"\n    Returns the results for the given song.\n\n    ### Arguments\n    - name: The name of the song.\n    - artists: The artists of the song.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - A dictionary with the results. (The key is the title and the value is the url.)\n    \"\"\"\n\n    track_search = kwargs.get(\"track_search\", False)\n    artists_str = \", \".join(\n        artist for artist in artists if artist.lower() not in name.lower()\n    )\n\n    # quote the query so that it's safe to use in a url\n    # e.g \"Au/Ra\" -&gt; \"Au%2FRa\"\n    query = quote(f\"{name} - {artists_str}\", safe=\"\")\n\n    # search the `tracks page` if track_search is True\n    if track_search:\n        query += \"/tracks\"\n\n    search_url = f\"https://www.musixmatch.com/search/{query}\"\n    search_resp = requests.get(\n        search_url,\n        headers=self.headers,\n        timeout=10,\n        proxies=GlobalConfig.get_parameter(\"proxies\"),\n    )\n    search_soup = BeautifulSoup(search_resp.text, \"html.parser\")\n    song_url_tag = search_soup.select(\"a[href^='/lyrics/']\")\n\n    if not song_url_tag:\n        # song_url_tag being None means no results were found on the\n        # All Results page, therefore, we use `track_search` to\n        # search the tracks page.\n\n        # track_serach being True means we are already searching the tracks page.\n        if track_search:\n            return {}\n\n        return self.get_results(name, artists, track_search=True)\n\n    results: Dict[str, str] = {}\n    for tag in song_url_tag:\n        results[tag.get_text()] = \"https://www.musixmatch.com\" + str(\n            tag.get(\"href\", \"\")\n        )\n\n    return results\n</code></pre>"},{"location":"reference/providers/lyrics/synced/","title":"synced","text":"<p>Synced lyrics provider using the syncedlyrics library</p>"},{"location":"reference/providers/lyrics/synced/#spotdl.providers.lyrics.synced.Synced","title":"<code>Synced()</code>","text":"<p>               Bases: <code>LyricsProvider</code></p> <p>Lyrics provider for synced lyrics using the syncedlyrics library Currently supported websites: Deezer, NetEase</p> Source code in <code>spotdl/providers/lyrics/base.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Init the lyrics provider searchand set headers.\n    \"\"\"\n\n    self.headers = {\n        \"Connection\": \"keep-alive\",\n        \"Pragma\": \"no-cache\",\n        \"Cache-Control\": \"no-cache\",\n        \"sec-ch-ua\": '\"Chromium\";v=\"104\", \" Not A;Brand\";v=\"99\", \"Google Chrome\";v=\"104\"',\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 \"\n        \"(KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36\",\n        \"Accept\": \"*/*\",\n        \"Sec-Fetch-Site\": \"same-origin\",\n        \"Sec-Fetch-Mode\": \"cors\",\n        \"Sec-Fetch-Dest\": \"empty\",\n        \"Accept-Language\": \"en-US;q=0.8,en;q=0.7\",\n    }\n</code></pre>"},{"location":"reference/providers/lyrics/synced/#spotdl.providers.lyrics.synced.Synced.extract_lyrics","title":"<code>extract_lyrics(url, **kwargs)</code>","text":"<p>Extracts the lyrics from the given url.</p>"},{"location":"reference/providers/lyrics/synced/#spotdl.providers.lyrics.synced.Synced.extract_lyrics--arguments","title":"Arguments","text":"<ul> <li>url: The url to extract the lyrics from.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/lyrics/synced/#spotdl.providers.lyrics.synced.Synced.extract_lyrics--returns","title":"Returns","text":"<ul> <li>The lyrics of the song or None if no lyrics were found.</li> </ul> Source code in <code>spotdl/providers/lyrics/synced.py</code> <pre><code>def extract_lyrics(self, url: str, **kwargs) -&gt; Optional[str]:\n    \"\"\"\n    Extracts the lyrics from the given url.\n\n    ### Arguments\n    - url: The url to extract the lyrics from.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - The lyrics of the song or None if no lyrics were found.\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/providers/lyrics/synced/#spotdl.providers.lyrics.synced.Synced.get_lyrics","title":"<code>get_lyrics(name, artists, **kwargs)</code>","text":"<p>Try to get lyrics using syncedlyrics</p>"},{"location":"reference/providers/lyrics/synced/#spotdl.providers.lyrics.synced.Synced.get_lyrics--arguments","title":"Arguments","text":"<ul> <li>name: The name of the song.</li> <li>artists: The artists of the song.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/lyrics/synced/#spotdl.providers.lyrics.synced.Synced.get_lyrics--returns","title":"Returns","text":"<ul> <li>The lyrics of the song or None if no lyrics were found.</li> </ul> Source code in <code>spotdl/providers/lyrics/synced.py</code> <pre><code>def get_lyrics(self, name: str, artists: List[str], **kwargs) -&gt; Optional[str]:\n    \"\"\"\n    Try to get lyrics using syncedlyrics\n\n    ### Arguments\n    - name: The name of the song.\n    - artists: The artists of the song.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - The lyrics of the song or None if no lyrics were found.\n    \"\"\"\n\n    try:\n        lyrics = syncedlyrics.search(\n            f\"{name} - {artists[0]}\",\n            synced_only=not kwargs.get(\"allow_plain_format\", True),\n        )\n        return lyrics\n    except requests.exceptions.SSLError:\n        # Max retries reached\n        return None\n    except TypeError:\n        # Error at syncedlyrics.providers.musixmatch L89 -\n        #   Because `body` is occasionally an empty list instead of a dictionary.\n        # We get this error when allow_plain_format is set to True,\n        #   and there are no synced lyrics present\n        # Because its empty, we know there are no lyrics\n        return None\n</code></pre>"},{"location":"reference/providers/lyrics/synced/#spotdl.providers.lyrics.synced.Synced.get_results","title":"<code>get_results(name, artists, **kwargs)</code>","text":"<p>Returns the results for the given song.</p>"},{"location":"reference/providers/lyrics/synced/#spotdl.providers.lyrics.synced.Synced.get_results--arguments","title":"Arguments","text":"<ul> <li>name: The name of the song.</li> <li>artists: The artists of the song.</li> <li>kwargs: Additional arguments.</li> </ul>"},{"location":"reference/providers/lyrics/synced/#spotdl.providers.lyrics.synced.Synced.get_results--returns","title":"Returns","text":"<ul> <li>A dictionary with the results. (The key is the title and the value is the url.)</li> </ul> Source code in <code>spotdl/providers/lyrics/synced.py</code> <pre><code>def get_results(self, name: str, artists: List[str], **kwargs) -&gt; Dict[str, str]:\n    \"\"\"\n    Returns the results for the given song.\n\n    ### Arguments\n    - name: The name of the song.\n    - artists: The artists of the song.\n    - kwargs: Additional arguments.\n\n    ### Returns\n    - A dictionary with the results. (The key is the title and the value is the url.)\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/types/","title":"types","text":"<p>Types for the spotdl package.</p>"},{"location":"reference/types/album/","title":"album","text":"<p>Artist module for retrieving artist data from Spotify.</p>"},{"location":"reference/types/album/#spotdl.types.album.Album","title":"<code>Album(name, url, urls, songs, artist)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SongList</code></p> <p>Album class for retrieving album data from Spotify.</p>"},{"location":"reference/types/album/#spotdl.types.album.Album.get_metadata","title":"<code>get_metadata(url)</code>  <code>staticmethod</code>","text":"<p>Get metadata for album.</p>"},{"location":"reference/types/album/#spotdl.types.album.Album.get_metadata--arguments","title":"Arguments","text":"<ul> <li>url: The URL of the album.</li> </ul>"},{"location":"reference/types/album/#spotdl.types.album.Album.get_metadata--returns","title":"Returns","text":"<ul> <li>A dictionary with metadata.</li> </ul> Source code in <code>spotdl/types/album.py</code> <pre><code>@staticmethod\ndef get_metadata(url: str) -&gt; Tuple[Dict[str, Any], List[Song]]:\n    \"\"\"\n    Get metadata for album.\n\n    ### Arguments\n    - url: The URL of the album.\n\n    ### Returns\n    - A dictionary with metadata.\n    \"\"\"\n\n    spotify_client = SpotifyClient()\n\n    album_metadata = spotify_client.album(url)\n    if album_metadata is None:\n        raise AlbumError(\n            \"Couldn't get metadata, check if you have passed correct album id\"\n        )\n\n    metadata = {\n        \"name\": album_metadata[\"name\"],\n        \"artist\": album_metadata[\"artists\"][0],\n        \"url\": url,\n    }\n\n    album_response = spotify_client.album_tracks(url)\n    if album_response is None:\n        raise AlbumError(\n            \"Couldn't get metadata, check if you have passed correct album id\"\n        )\n\n    tracks = album_response[\"items\"]\n\n    # Get all tracks from album\n    while album_response[\"next\"]:\n        album_response = spotify_client.next(album_response)\n\n        # Failed to get response, break the loop\n        if album_response is None:\n            break\n\n        tracks.extend(album_response[\"items\"])\n\n    if album_response is None:\n        raise AlbumError(f\"Failed to get album response: {url}\")\n\n    songs = []\n    for track in tracks:\n        if not isinstance(track, dict) or track.get(\"is_local\"):\n            continue\n\n        release_date = album_metadata[\"release_date\"]\n        artists = artists = [artist[\"name\"] for artist in track[\"artists\"]]\n\n        song = Song.from_missing_data(\n            name=track[\"name\"],\n            artists=artists,\n            artist=artists[0],\n            album_id=album_metadata[\"id\"],\n            album_name=album_metadata[\"name\"],\n            album_artist=album_metadata[\"artists\"][0][\"name\"],\n            album_type=album_metadata[\"album_type\"],\n            disc_number=track[\"disc_number\"],\n            disc_count=int(album_metadata[\"tracks\"][\"items\"][-1][\"disc_number\"]),\n            duration=int(track[\"duration_ms\"] / 1000),\n            year=release_date[:4],\n            date=release_date,\n            track_number=track[\"track_number\"],\n            tracks_count=album_metadata[\"total_tracks\"],\n            song_id=track[\"id\"],\n            explicit=track[\"explicit\"],\n            publisher=album_metadata[\"label\"],\n            url=track[\"external_urls\"][\"spotify\"],\n            cover_url=(\n                max(\n                    album_metadata[\"images\"], key=lambda i: i[\"width\"] * i[\"height\"]\n                )[\"url\"]\n                if album_metadata[\"images\"]\n                else None\n            ),\n            copyright_text=(\n                album_metadata[\"copyrights\"][0][\"text\"]\n                if album_metadata[\"copyrights\"]\n                else None\n            ),\n        )\n\n        songs.append(song)\n\n    return metadata, songs\n</code></pre>"},{"location":"reference/types/album/#spotdl.types.album.AlbumError","title":"<code>AlbumError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all exceptions related to albums.</p>"},{"location":"reference/types/artist/","title":"artist","text":"<p>Artist module for retrieving artist data from Spotify.</p>"},{"location":"reference/types/artist/#spotdl.types.artist.Artist","title":"<code>Artist(name, url, urls, songs, genres, albums)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SongList</code></p> <p>Artist class. Contains all the information about an artist. Frozen to prevent accidental modification.</p>"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.get_metadata","title":"<code>get_metadata(url)</code>  <code>staticmethod</code>","text":"<p>Get metadata for artist.</p>"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.get_metadata--arguments","title":"Arguments","text":"<ul> <li>url: The URL of the artist.</li> </ul>"},{"location":"reference/types/artist/#spotdl.types.artist.Artist.get_metadata--returns","title":"Returns","text":"<ul> <li>Dict with metadata for artist.</li> </ul> Source code in <code>spotdl/types/artist.py</code> <pre><code>@staticmethod\ndef get_metadata(url: str) -&gt; Tuple[Dict[str, Any], List[Song]]:\n    \"\"\"\n    Get metadata for artist.\n\n    ### Arguments\n    - url: The URL of the artist.\n\n    ### Returns\n    - Dict with metadata for artist.\n    \"\"\"\n\n    # query spotify for artist details\n    spotify_client = SpotifyClient()\n\n    # get artist info\n    raw_artist_meta = spotify_client.artist(url)\n\n    if raw_artist_meta is None:\n        raise ArtistError(\n            \"Couldn't get metadata, check if you have passed correct artist id\"\n        )\n\n    artist_albums = spotify_client.artist_albums(url, album_type=\"album,single\")\n    # check if there is response\n    if not artist_albums:\n        raise ArtistError(\n            \"Couldn't get albums, check if you have passed correct artist id\"\n        )\n\n    # get artist albums and remove duplicates\n    # duplicates can occur if the artist has the same album available in\n    # different countries\n    albums: List[str] = []\n    known_albums: Set[str] = set()\n    for album in artist_albums[\"items\"]:\n        albums.append(album[\"external_urls\"][\"spotify\"])\n        known_albums.add(slugify(album[\"name\"]))\n\n    # Fetch all artist albums\n    while artist_albums and artist_albums[\"next\"]:\n        artist_albums = spotify_client.next(artist_albums)\n        if artist_albums is None:\n            break\n\n        for album in artist_albums[\"items\"]:\n            album_name = slugify(album[\"name\"])\n\n            if album_name not in known_albums:\n                albums.append(album[\"external_urls\"][\"spotify\"])\n                known_albums.add(album_name)\n\n    songs = []\n    for album in albums:\n        album_obj = Album.from_url(album, fetch_songs=False)\n        songs.extend(album_obj.songs)\n\n    # Very aggressive deduplication\n    songs_list = []\n    songs_names = set()\n    for song in songs:\n        slug_name = slugify(song.name)\n        if song.name not in songs_names:\n            songs_list.append(song)\n            songs_names.add(slug_name)\n\n    metadata = {\n        \"name\": raw_artist_meta[\"name\"],\n        \"genres\": raw_artist_meta[\"genres\"],\n        \"url\": url,\n        \"albums\": albums,\n    }\n\n    return metadata, songs_list\n</code></pre>"},{"location":"reference/types/artist/#spotdl.types.artist.ArtistError","title":"<code>ArtistError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all exceptions related to artists.</p>"},{"location":"reference/types/options/","title":"options","text":"<p>This file contains types for spotdl/downloader/web modules. Options types have all the fields marked as required. Settings types have all the fields marked as optional.</p>"},{"location":"reference/types/options/#spotdl.types.options.DownloaderOptionalOptions","title":"<code>DownloaderOptionalOptions</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Options used for initializing the Downloader.</p>"},{"location":"reference/types/options/#spotdl.types.options.DownloaderOptions","title":"<code>DownloaderOptions</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Options used for initializing the Downloader.</p>"},{"location":"reference/types/options/#spotdl.types.options.SpotDLOptionalOptions","title":"<code>SpotDLOptionalOptions</code>","text":"<p>               Bases: <code>SpotifyOptionalOptions</code>, <code>DownloaderOptionalOptions</code>, <code>WebOptionalOptions</code></p> <p>Options used for initializing the SpotDL client. This type is modified to not require all the fields.</p>"},{"location":"reference/types/options/#spotdl.types.options.SpotDLOptions","title":"<code>SpotDLOptions</code>","text":"<p>               Bases: <code>SpotifyOptions</code>, <code>DownloaderOptions</code>, <code>WebOptions</code></p> <p>Options used for initializing the SpotDL client.</p>"},{"location":"reference/types/options/#spotdl.types.options.SpotifyOptionalOptions","title":"<code>SpotifyOptionalOptions</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Options used for initializing the Spotify client.</p>"},{"location":"reference/types/options/#spotdl.types.options.SpotifyOptions","title":"<code>SpotifyOptions</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Options used for initializing the Spotify client.</p>"},{"location":"reference/types/options/#spotdl.types.options.WebOptionalOptions","title":"<code>WebOptionalOptions</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Options used for initializing the Web server.</p>"},{"location":"reference/types/options/#spotdl.types.options.WebOptions","title":"<code>WebOptions</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Options used for initializing the Web server.</p>"},{"location":"reference/types/playlist/","title":"playlist","text":"<p>Playlist module for retrieving playlist data from Spotify.</p>"},{"location":"reference/types/playlist/#spotdl.types.playlist.Playlist","title":"<code>Playlist(name, url, urls, songs, description, author_url, author_name, cover_url)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SongList</code></p> <p>Playlist class for retrieving playlist data from Spotify.</p>"},{"location":"reference/types/playlist/#spotdl.types.playlist.Playlist.get_metadata","title":"<code>get_metadata(url)</code>  <code>staticmethod</code>","text":"<p>Get metadata for a playlist.</p>"},{"location":"reference/types/playlist/#spotdl.types.playlist.Playlist.get_metadata--arguments","title":"Arguments","text":"<ul> <li>url: The URL of the playlist.</li> </ul>"},{"location":"reference/types/playlist/#spotdl.types.playlist.Playlist.get_metadata--returns","title":"Returns","text":"<ul> <li>A dictionary with metadata.</li> </ul> Source code in <code>spotdl/types/playlist.py</code> <pre><code>@staticmethod\ndef get_metadata(url: str) -&gt; Tuple[Dict[str, Any], List[Song]]:\n    \"\"\"\n    Get metadata for a playlist.\n\n    ### Arguments\n    - url: The URL of the playlist.\n\n    ### Returns\n    - A dictionary with metadata.\n    \"\"\"\n\n    spotify_client = SpotifyClient()\n\n    playlist = spotify_client.playlist(url)\n    if playlist is None:\n        raise PlaylistError(\"Invalid playlist URL.\")\n\n    metadata = {\n        \"name\": playlist[\"name\"],\n        \"url\": url,\n        \"description\": playlist[\"description\"],\n        \"author_url\": playlist[\"external_urls\"][\"spotify\"],\n        \"author_name\": playlist[\"owner\"][\"display_name\"],\n        \"cover_url\": (\n            max(\n                playlist[\"images\"],\n                key=lambda i: (\n                    0\n                    if i[\"width\"] is None or i[\"height\"] is None\n                    else i[\"width\"] * i[\"height\"]\n                ),\n            )[\"url\"]\n            if (playlist.get(\"images\") is not None and len(playlist[\"images\"]) &gt; 0)\n            else \"\"\n        ),\n    }\n\n    playlist_response = spotify_client.playlist_items(url)\n    if playlist_response is None:\n        raise PlaylistError(f\"Wrong playlist id: {url}\")\n\n    # Get all tracks from playlist\n    tracks = playlist_response[\"items\"]\n    while playlist_response[\"next\"]:\n        playlist_response = spotify_client.next(playlist_response)\n\n        # Failed to get response, break the loop\n        if playlist_response is None:\n            break\n\n        # Add tracks to the list\n        tracks.extend(playlist_response[\"items\"])\n\n    songs = []\n    for track_no, track in enumerate(tracks):\n        if not isinstance(track, dict) or track.get(\"track\") is None:\n            continue\n\n        track_meta = track[\"track\"]\n\n        if track_meta.get(\"is_local\") or track_meta.get(\"type\") != \"track\":\n            logger.warning(\n                \"Skipping track: %s local tracks and %s are not supported\",\n                track_meta.get(\"id\"),\n                track_meta.get(\"type\"),\n            )\n\n            continue\n\n        track_id = track_meta.get(\"id\")\n        if track_id is None or track_meta.get(\"duration_ms\") == 0:\n            continue\n\n        album_meta = track_meta.get(\"album\", {})\n        release_date = album_meta.get(\"release_date\")\n        artists = [artist[\"name\"] for artist in track_meta.get(\"artists\", [])]\n        song = Song.from_missing_data(\n            name=track_meta[\"name\"],\n            artists=artists,\n            artist=artists[0],\n            album_id=album_meta.get(\"id\"),\n            album_name=album_meta.get(\"name\"),\n            album_artist=(\n                album_meta.get(\"artists\", [])[0][\"name\"]\n                if album_meta.get(\"artists\")\n                else None\n            ),\n            album_type=album_meta.get(\"album_type\"),\n            disc_number=track_meta[\"disc_number\"],\n            duration=int(track_meta[\"duration_ms\"] / 1000),\n            year=release_date[:4] if release_date else None,\n            date=release_date,\n            track_number=track_meta[\"track_number\"],\n            tracks_count=album_meta.get(\"total_tracks\"),\n            song_id=track_meta[\"id\"],\n            explicit=track_meta[\"explicit\"],\n            url=track_meta[\"external_urls\"][\"spotify\"],\n            isrc=track_meta.get(\"external_ids\", {}).get(\"isrc\"),\n            cover_url=(\n                max(album_meta[\"images\"], key=lambda i: i[\"width\"] * i[\"height\"])[\n                    \"url\"\n                ]\n                if (len(album_meta.get(\"images\", [])) &gt; 0)\n                else None\n            ),\n            list_position=track_no + 1,\n        )\n\n        songs.append(song)\n\n    return metadata, songs\n</code></pre>"},{"location":"reference/types/playlist/#spotdl.types.playlist.PlaylistError","title":"<code>PlaylistError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all exceptions related to playlists.</p>"},{"location":"reference/types/result/","title":"result","text":"<p>Result is a class that contains all the information about a result from search performed by audio provider.</p>"},{"location":"reference/types/result/#spotdl.types.result.Result","title":"<code>Result(source, url, verified, name, duration, author, result_id, isrc_search=None, search_query=None, artists=None, views=None, explicit=None, album=None, year=None, track_number=None, genre=None, lyrics=None)</code>  <code>dataclass</code>","text":"<p>Result is a class that contains all the information about a result from search perfoermed by audio provider.</p>"},{"location":"reference/types/result/#spotdl.types.result.Result.json","title":"<code>json</code>  <code>property</code>","text":"<p>Returns a dictionary of the song's data.</p>"},{"location":"reference/types/result/#spotdl.types.result.Result.json--returns","title":"Returns","text":"<ul> <li>The dictionary.</li> </ul>"},{"location":"reference/types/result/#spotdl.types.result.Result.from_data_dump","title":"<code>from_data_dump(data)</code>  <code>classmethod</code>","text":"<p>Create a Result object from a data dump.</p>"},{"location":"reference/types/result/#spotdl.types.result.Result.from_data_dump--arguments","title":"Arguments","text":"<ul> <li>data: The data dump.</li> </ul>"},{"location":"reference/types/result/#spotdl.types.result.Result.from_data_dump--returns","title":"Returns","text":"<ul> <li>The Song object.</li> </ul> Source code in <code>spotdl/types/result.py</code> <pre><code>@classmethod\ndef from_data_dump(cls, data: str) -&gt; \"Result\":\n    \"\"\"\n    Create a Result object from a data dump.\n\n    ### Arguments\n    - data: The data dump.\n\n    ### Returns\n    - The Song object.\n    \"\"\"\n\n    # Create dict from json string\n    data_dict = json.loads(data)\n\n    # Return product object\n    return cls(**data_dict)\n</code></pre>"},{"location":"reference/types/result/#spotdl.types.result.Result.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a Song object from a dictionary.</p>"},{"location":"reference/types/result/#spotdl.types.result.Result.from_dict--arguments","title":"Arguments","text":"<ul> <li>data: The dictionary.</li> </ul>"},{"location":"reference/types/result/#spotdl.types.result.Result.from_dict--returns","title":"Returns","text":"<ul> <li>The Song object.</li> </ul> Source code in <code>spotdl/types/result.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict[str, Any]) -&gt; \"Result\":\n    \"\"\"\n    Create a Song object from a dictionary.\n\n    ### Arguments\n    - data: The dictionary.\n\n    ### Returns\n    - The Song object.\n    \"\"\"\n\n    # Return product object\n    return cls(**data)\n</code></pre>"},{"location":"reference/types/saved/","title":"saved","text":"<p>Saved module for handing the saved tracks from user library</p>"},{"location":"reference/types/saved/#spotdl.types.saved.Saved","title":"<code>Saved(name, url, urls, songs)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SongList</code></p> <p>Saved class for handling the saved tracks from user library.</p>"},{"location":"reference/types/saved/#spotdl.types.saved.Saved.get_metadata","title":"<code>get_metadata(url='saved')</code>  <code>staticmethod</code>","text":"<p>Returns metadata for a saved list.</p>"},{"location":"reference/types/saved/#spotdl.types.saved.Saved.get_metadata--arguments","title":"Arguments","text":"<ul> <li>url: Not required, but used to match the signature of the other get_metadata methods.</li> </ul>"},{"location":"reference/types/saved/#spotdl.types.saved.Saved.get_metadata--returns","title":"Returns","text":"<ul> <li>metadata: A dictionary containing the metadata for the saved list.</li> <li>songs: A list of Song objects.</li> </ul> Source code in <code>spotdl/types/saved.py</code> <pre><code>@staticmethod\ndef get_metadata(url: str = \"saved\") -&gt; Tuple[Dict[str, Any], List[Song]]:\n    \"\"\"\n    Returns metadata for a saved list.\n\n    ### Arguments\n    - url: Not required, but used to match the signature of the other get_metadata methods.\n\n    ### Returns\n    - metadata: A dictionary containing the metadata for the saved list.\n    - songs: A list of Song objects.\n    \"\"\"\n\n    metadata = {\"name\": \"Saved tracks\", \"url\": url}\n\n    spotify_client = SpotifyClient()\n    if spotify_client.user_auth is False:  # type: ignore\n        raise SavedError(\"You must be logged in to use this function\")\n\n    saved_tracks_response = spotify_client.current_user_saved_tracks()\n    if saved_tracks_response is None:\n        raise SavedError(\"Couldn't get saved tracks\")\n\n    saved_tracks = saved_tracks_response[\"items\"]\n\n    # Fetch all saved tracks\n    while saved_tracks_response and saved_tracks_response[\"next\"]:\n        response = spotify_client.next(saved_tracks_response)\n        if response is None:\n            break\n\n        saved_tracks_response = response\n        saved_tracks.extend(saved_tracks_response[\"items\"])\n\n    songs = []\n    for track in saved_tracks:\n        if not isinstance(track, dict) or track.get(\"track\", {}).get(\"is_local\"):\n            continue\n\n        track_meta = track[\"track\"]\n        album_meta = track_meta[\"album\"]\n\n        release_date = album_meta[\"release_date\"]\n        artists = artists = [artist[\"name\"] for artist in track_meta[\"artists\"]]\n\n        song = Song.from_missing_data(\n            name=track_meta[\"name\"],\n            artists=artists,\n            artist=artists[0],\n            album_id=album_meta[\"id\"],\n            album_name=album_meta[\"name\"],\n            album_artist=album_meta[\"artists\"][0][\"name\"],\n            album_type=album_meta[\"album_type\"],\n            disc_number=track_meta[\"disc_number\"],\n            duration=int(track_meta[\"duration_ms\"] / 1000),\n            year=release_date[:4],\n            date=release_date,\n            track_number=track_meta[\"track_number\"],\n            tracks_count=album_meta[\"total_tracks\"],\n            song_id=track_meta[\"id\"],\n            explicit=track_meta[\"explicit\"],\n            url=track_meta[\"external_urls\"][\"spotify\"],\n            isrc=track_meta.get(\"external_ids\", {}).get(\"isrc\"),\n            cover_url=(\n                max(album_meta[\"images\"], key=lambda i: i[\"width\"] * i[\"height\"])[\n                    \"url\"\n                ]\n                if album_meta[\"images\"]\n                else None\n            ),\n        )\n\n        songs.append(song)\n\n    return metadata, songs\n</code></pre>"},{"location":"reference/types/saved/#spotdl.types.saved.SavedError","title":"<code>SavedError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all exceptions related to saved tracks.</p>"},{"location":"reference/types/song/","title":"song","text":"<p>Song module that hold the Song and SongList classes.</p>"},{"location":"reference/types/song/#spotdl.types.song.Song","title":"<code>Song(name, artists, artist, genres, disc_number, disc_count, album_name, album_artist, duration, year, date, track_number, tracks_count, song_id, explicit, publisher, url, isrc, cover_url, copyright_text, download_url=None, lyrics=None, popularity=None, album_id=None, list_name=None, list_url=None, list_position=None, list_length=None, artist_id=None, album_type=None)</code>  <code>dataclass</code>","text":"<p>Song class. Contains all the information about a song.</p>"},{"location":"reference/types/song/#spotdl.types.song.Song.display_name","title":"<code>display_name</code>  <code>property</code>","text":"<p>Returns a display name for the song.</p>"},{"location":"reference/types/song/#spotdl.types.song.Song.display_name--returns","title":"Returns","text":"<ul> <li>The display name.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.Song.json","title":"<code>json</code>  <code>property</code>","text":"<p>Returns a dictionary of the song's data.</p>"},{"location":"reference/types/song/#spotdl.types.song.Song.json--returns","title":"Returns","text":"<ul> <li>The dictionary.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.Song.from_data_dump","title":"<code>from_data_dump(data)</code>  <code>classmethod</code>","text":"<p>Create a Song object from a data dump.</p>"},{"location":"reference/types/song/#spotdl.types.song.Song.from_data_dump--arguments","title":"Arguments","text":"<ul> <li>data: The data dump.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.Song.from_data_dump--returns","title":"Returns","text":"<ul> <li>The Song object.</li> </ul> Source code in <code>spotdl/types/song.py</code> <pre><code>@classmethod\ndef from_data_dump(cls, data: str) -&gt; \"Song\":\n    \"\"\"\n    Create a Song object from a data dump.\n\n    ### Arguments\n    - data: The data dump.\n\n    ### Returns\n    - The Song object.\n    \"\"\"\n\n    # Create dict from json string\n    data_dict = json.loads(data)\n\n    # Return product object\n    return cls(**data_dict)\n</code></pre>"},{"location":"reference/types/song/#spotdl.types.song.Song.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a Song object from a dictionary.</p>"},{"location":"reference/types/song/#spotdl.types.song.Song.from_dict--arguments","title":"Arguments","text":"<ul> <li>data: The dictionary.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.Song.from_dict--returns","title":"Returns","text":"<ul> <li>The Song object.</li> </ul> Source code in <code>spotdl/types/song.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict[str, Any]) -&gt; \"Song\":\n    \"\"\"\n    Create a Song object from a dictionary.\n\n    ### Arguments\n    - data: The dictionary.\n\n    ### Returns\n    - The Song object.\n    \"\"\"\n\n    # Return product object\n    return cls(**data)\n</code></pre>"},{"location":"reference/types/song/#spotdl.types.song.Song.from_missing_data","title":"<code>from_missing_data(**kwargs)</code>  <code>classmethod</code>","text":"<p>Create a Song object from a dictionary with missing data. For example, data dict doesn't contain all the required attributes for the Song class.</p>"},{"location":"reference/types/song/#spotdl.types.song.Song.from_missing_data--arguments","title":"Arguments","text":"<ul> <li>data: The dictionary.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.Song.from_missing_data--returns","title":"Returns","text":"<ul> <li>The Song object.</li> </ul> Source code in <code>spotdl/types/song.py</code> <pre><code>@classmethod\ndef from_missing_data(cls, **kwargs) -&gt; \"Song\":\n    \"\"\"\n    Create a Song object from a dictionary with missing data.\n    For example, data dict doesn't contain all the required\n    attributes for the Song class.\n\n    ### Arguments\n    - data: The dictionary.\n\n    ### Returns\n    - The Song object.\n    \"\"\"\n\n    song_data: Dict[str, Any] = {}\n    for key in cls.__dataclass_fields__:  # pylint: disable=E1101\n        song_data.setdefault(key, kwargs.get(key))\n\n    return cls(**song_data)\n</code></pre>"},{"location":"reference/types/song/#spotdl.types.song.Song.from_search_term","title":"<code>from_search_term(search_term)</code>  <code>classmethod</code>","text":"<p>Creates a list of Song objects from a search term.</p>"},{"location":"reference/types/song/#spotdl.types.song.Song.from_search_term--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to use.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.Song.from_search_term--returns","title":"Returns","text":"<ul> <li>The Song object.</li> </ul> Source code in <code>spotdl/types/song.py</code> <pre><code>@classmethod\ndef from_search_term(cls, search_term: str) -&gt; \"Song\":\n    \"\"\"\n    Creates a list of Song objects from a search term.\n\n    ### Arguments\n    - search_term: The search term to use.\n\n    ### Returns\n    - The Song object.\n    \"\"\"\n\n    raw_search_results = Song.search(search_term)\n\n    if len(raw_search_results[\"tracks\"][\"items\"]) == 0:\n        raise SongError(f\"No results found for: {search_term}\")\n\n    return Song.from_url(\n        \"http://open.spotify.com/track/\"\n        + raw_search_results[\"tracks\"][\"items\"][0][\"id\"]\n    )\n</code></pre>"},{"location":"reference/types/song/#spotdl.types.song.Song.from_url","title":"<code>from_url(url)</code>  <code>classmethod</code>","text":"<p>Creates a Song object from a URL.</p>"},{"location":"reference/types/song/#spotdl.types.song.Song.from_url--arguments","title":"Arguments","text":"<ul> <li>url: The URL of the song.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.Song.from_url--returns","title":"Returns","text":"<ul> <li>The Song object.</li> </ul> Source code in <code>spotdl/types/song.py</code> <pre><code>@classmethod\ndef from_url(cls, url: str) -&gt; \"Song\":\n    \"\"\"\n    Creates a Song object from a URL.\n\n    ### Arguments\n    - url: The URL of the song.\n\n    ### Returns\n    - The Song object.\n    \"\"\"\n\n    if \"open.spotify.com\" not in url or \"track\" not in url:\n        raise SongError(f\"Invalid URL: {url}\")\n\n    # query spotify for song, artist, album details\n    spotify_client = SpotifyClient()\n\n    # get track info\n    raw_track_meta = spotify_client.track(url)\n\n    if raw_track_meta is None:\n        raise SongError(\n            \"Couldn't get metadata, check if you have passed correct track id\"\n        )\n\n    if raw_track_meta[\"duration_ms\"] == 0 or raw_track_meta[\"name\"].strip() == \"\":\n        raise SongError(f\"Track no longer exists: {url}\")\n\n    # get artist info\n    primary_artist_id = raw_track_meta[\"artists\"][0][\"id\"]\n    raw_artist_meta: Dict[str, Any] = spotify_client.artist(primary_artist_id)  # type: ignore\n\n    # get album info\n    album_id = raw_track_meta[\"album\"][\"id\"]\n    raw_album_meta: Dict[str, Any] = spotify_client.album(album_id)  # type: ignore\n\n    # create song object\n    return cls(\n        name=raw_track_meta[\"name\"],\n        artists=[artist[\"name\"] for artist in raw_track_meta[\"artists\"]],\n        artist=raw_track_meta[\"artists\"][0][\"name\"],\n        artist_id=primary_artist_id,\n        album_id=album_id,\n        album_name=raw_album_meta[\"name\"],\n        album_artist=raw_album_meta[\"artists\"][0][\"name\"],\n        album_type=raw_album_meta.get(\"album_type\"),\n        copyright_text=(\n            raw_album_meta[\"copyrights\"][0][\"text\"]\n            if raw_album_meta[\"copyrights\"]\n            else None\n        ),\n        genres=raw_album_meta[\"genres\"] + raw_artist_meta[\"genres\"],\n        disc_number=raw_track_meta[\"disc_number\"],\n        disc_count=int(raw_album_meta[\"tracks\"][\"items\"][-1][\"disc_number\"]),\n        duration=int(raw_track_meta[\"duration_ms\"] / 1000),\n        year=int(raw_album_meta[\"release_date\"][:4]),\n        date=raw_album_meta[\"release_date\"],\n        track_number=raw_track_meta[\"track_number\"],\n        tracks_count=raw_album_meta[\"total_tracks\"],\n        isrc=raw_track_meta.get(\"external_ids\", {}).get(\"isrc\"),\n        song_id=raw_track_meta[\"id\"],\n        explicit=raw_track_meta[\"explicit\"],\n        publisher=raw_album_meta[\"label\"],\n        url=raw_track_meta[\"external_urls\"][\"spotify\"],\n        popularity=raw_track_meta[\"popularity\"],\n        cover_url=(\n            max(raw_album_meta[\"images\"], key=lambda i: i[\"width\"] * i[\"height\"])[\n                \"url\"\n            ]\n            if raw_album_meta[\"images\"]\n            else None\n        ),\n    )\n</code></pre>"},{"location":"reference/types/song/#spotdl.types.song.Song.list_from_search_term","title":"<code>list_from_search_term(search_term)</code>  <code>classmethod</code>","text":"<p>Creates a list of Song objects from a search term.</p>"},{"location":"reference/types/song/#spotdl.types.song.Song.list_from_search_term--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to use.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.Song.list_from_search_term--returns","title":"Returns","text":"<ul> <li>The list of Song objects.</li> </ul> Source code in <code>spotdl/types/song.py</code> <pre><code>@classmethod\ndef list_from_search_term(cls, search_term: str) -&gt; \"List[Song]\":\n    \"\"\"\n    Creates a list of Song objects from a search term.\n\n    ### Arguments\n    - search_term: The search term to use.\n\n    ### Returns\n    - The list of Song objects.\n    \"\"\"\n\n    raw_search_results = Song.search(search_term)\n\n    songs = []\n    for idx, _ in enumerate(raw_search_results.get(\"tracks\", []).get(\"items\", [])):\n        songs.append(\n            Song.from_url(\n                \"http://open.spotify.com/track/\"\n                + raw_search_results[\"tracks\"][\"items\"][idx][\"id\"]\n            )\n        )\n\n    return songs\n</code></pre>"},{"location":"reference/types/song/#spotdl.types.song.Song.search","title":"<code>search(search_term)</code>  <code>staticmethod</code>","text":"<p>Searches for Songs from a search term.</p>"},{"location":"reference/types/song/#spotdl.types.song.Song.search--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to use.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.Song.search--returns","title":"Returns","text":"<ul> <li>The raw search results</li> </ul> Source code in <code>spotdl/types/song.py</code> <pre><code>@staticmethod\ndef search(search_term: str):\n    \"\"\"\n    Searches for Songs from a search term.\n\n    ### Arguments\n    - search_term: The search term to use.\n\n    ### Returns\n    - The raw search results\n    \"\"\"\n    spotify_client = SpotifyClient()\n    raw_search_results = spotify_client.search(search_term)\n\n    if raw_search_results is None:\n        raise SongError(f\"Spotipy error, no response: {search_term}\")\n\n    return raw_search_results\n</code></pre>"},{"location":"reference/types/song/#spotdl.types.song.SongError","title":"<code>SongError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all exceptions related to songs.</p>"},{"location":"reference/types/song/#spotdl.types.song.SongList","title":"<code>SongList(name, url, urls, songs)</code>  <code>dataclass</code>","text":"<p>SongList class. Base class for all other song lists subclasses.</p>"},{"location":"reference/types/song/#spotdl.types.song.SongList.json","title":"<code>json</code>  <code>property</code>","text":"<p>Returns a dictionary of the song list's data.</p>"},{"location":"reference/types/song/#spotdl.types.song.SongList.json--returns","title":"Returns","text":"<ul> <li>The dictionary.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.SongList.length","title":"<code>length</code>  <code>property</code>","text":"<p>Get list length (number of songs).</p>"},{"location":"reference/types/song/#spotdl.types.song.SongList.length--returns","title":"Returns","text":"<ul> <li>The list length.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.SongList.from_search_term","title":"<code>from_search_term(search_term, fetch_songs=True)</code>  <code>classmethod</code>","text":"<p>Creates a SongList object from a search term.</p>"},{"location":"reference/types/song/#spotdl.types.song.SongList.from_search_term--arguments","title":"Arguments","text":"<ul> <li>search_term: The search term to use.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.SongList.from_search_term--returns","title":"Returns","text":"<ul> <li>The SongList object.</li> </ul> Source code in <code>spotdl/types/song.py</code> <pre><code>@classmethod\ndef from_search_term(cls, search_term: str, fetch_songs: bool = True):\n    \"\"\"\n    Creates a SongList object from a search term.\n\n    ### Arguments\n    - search_term: The search term to use.\n\n    ### Returns\n    - The SongList object.\n    \"\"\"\n\n    list_type = cls.__name__.lower()\n    spotify_client = SpotifyClient()\n    raw_search_results = spotify_client.search(search_term, type=list_type)\n\n    if (\n        raw_search_results is None\n        or len(raw_search_results.get(f\"{list_type}s\", {}).get(\"items\", [])) == 0\n    ):\n        raise SongListError(\n            f\"No {list_type} matches found on spotify for '{search_term}'\"\n        )\n\n    matches = {}\n    for result in raw_search_results[f\"{list_type}s\"][\"items\"]:\n        score = fuzz.ratio(search_term.split(\":\", 1)[1].strip(), result[\"name\"])\n        matches[result[\"id\"]] = score\n\n    best_match = max(matches, key=matches.get)  # type: ignore\n\n    return cls.from_url(\n        f\"http://open.spotify.com/{list_type}/{best_match}\",\n        fetch_songs,\n    )\n</code></pre>"},{"location":"reference/types/song/#spotdl.types.song.SongList.from_url","title":"<code>from_url(url, fetch_songs=True)</code>  <code>classmethod</code>","text":"<p>Create a SongList object from a url.</p>"},{"location":"reference/types/song/#spotdl.types.song.SongList.from_url--arguments","title":"Arguments","text":"<ul> <li>url: The url of the list.</li> <li>fetch_songs: Whether to fetch missing metadata for songs.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.SongList.from_url--returns","title":"Returns","text":"<ul> <li>The SongList object.</li> </ul> Source code in <code>spotdl/types/song.py</code> <pre><code>@classmethod\ndef from_url(cls, url: str, fetch_songs: bool = True):\n    \"\"\"\n    Create a SongList object from a url.\n\n    ### Arguments\n    - url: The url of the list.\n    - fetch_songs: Whether to fetch missing metadata for songs.\n\n    ### Returns\n    - The SongList object.\n    \"\"\"\n\n    metadata, songs = cls.get_metadata(url)\n    urls = [song.url for song in songs]\n\n    if fetch_songs:\n        songs = [Song.from_url(song.url) for song in songs]\n\n    return cls(**metadata, urls=urls, songs=songs)\n</code></pre>"},{"location":"reference/types/song/#spotdl.types.song.SongList.get_metadata","title":"<code>get_metadata(url)</code>  <code>staticmethod</code>","text":"<p>Get metadata for a song list.</p>"},{"location":"reference/types/song/#spotdl.types.song.SongList.get_metadata--arguments","title":"Arguments","text":"<ul> <li>url: The url of the song list.</li> </ul>"},{"location":"reference/types/song/#spotdl.types.song.SongList.get_metadata--returns","title":"Returns","text":"<ul> <li>The metadata.</li> </ul> Source code in <code>spotdl/types/song.py</code> <pre><code>@staticmethod\ndef get_metadata(url: str) -&gt; Tuple[Dict[str, Any], List[Song]]:\n    \"\"\"\n    Get metadata for a song list.\n\n    ### Arguments\n    - url: The url of the song list.\n\n    ### Returns\n    - The metadata.\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/types/song/#spotdl.types.song.SongListError","title":"<code>SongListError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all exceptions related to song lists.</p>"},{"location":"reference/utils/","title":"utils","text":"<p>Utility functions for spotdl. These functions are used in every stage of the download process.</p>"},{"location":"reference/utils/archive/","title":"archive","text":"<p>Module for archiving sets of data</p>"},{"location":"reference/utils/archive/#spotdl.utils.archive.Archive","title":"<code>Archive</code>","text":"<p>               Bases: <code>Set</code></p> <p>Archive class. A file-persistable set.</p>"},{"location":"reference/utils/archive/#spotdl.utils.archive.Archive.load","title":"<code>load(file)</code>","text":"<p>Imports the archive from the file.</p>"},{"location":"reference/utils/archive/#spotdl.utils.archive.Archive.load--arguments","title":"Arguments","text":"<ul> <li>file: the file name of the archive</li> </ul>"},{"location":"reference/utils/archive/#spotdl.utils.archive.Archive.load--returns","title":"Returns","text":"<ul> <li>if the file exists</li> </ul> Source code in <code>spotdl/utils/archive.py</code> <pre><code>def load(self, file: str) -&gt; bool:\n    \"\"\"\n    Imports the archive from the file.\n\n    ### Arguments\n    - file: the file name of the archive\n\n    ### Returns\n    - if the file exists\n    \"\"\"\n\n    if not Path(file).exists():\n        return False\n\n    with open(file, \"r\", encoding=\"utf-8\") as archive:\n        self.clear()\n        self.update([line.strip() for line in archive])\n\n    return True\n</code></pre>"},{"location":"reference/utils/archive/#spotdl.utils.archive.Archive.save","title":"<code>save(file)</code>","text":"<p>Exports the current archive to the file.</p>"},{"location":"reference/utils/archive/#spotdl.utils.archive.Archive.save--arguments","title":"Arguments","text":"<ul> <li>file: the file name of the archive</li> </ul> Source code in <code>spotdl/utils/archive.py</code> <pre><code>def save(self, file: str) -&gt; bool:\n    \"\"\"\n    Exports the current archive to the file.\n\n    ### Arguments\n    - file: the file name of the archive\n    \"\"\"\n\n    with open(file, \"w\", encoding=\"utf-8\") as archive:\n        for element in sorted(self):\n            archive.write(f\"{element}\\n\")\n\n    return True\n</code></pre>"},{"location":"reference/utils/arguments/","title":"arguments","text":"<p>Module that handles the command line arguments.</p>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.SmartFormatter","title":"<code>SmartFormatter</code>","text":"<p>               Bases: <code>HelpFormatter</code></p> <p>Class that overrides the default help formatter.</p>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.create_parser","title":"<code>create_parser()</code>","text":"<p>Parse arguments from the command line.</p>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.create_parser--returns","title":"Returns","text":"<ul> <li>A Namespace object containing the parsed arguments.</li> </ul> Source code in <code>spotdl/utils/arguments.py</code> <pre><code>def create_parser() -&gt; ArgumentParser:\n    \"\"\"\n    Parse arguments from the command line.\n\n    ### Returns\n    - A Namespace object containing the parsed arguments.\n    \"\"\"\n\n    # Initialize argument parser\n    parser = ArgumentParser(\n        prog=\"spotdl\",\n        description=\"Download your Spotify playlists and songs along with album art and metadata\",\n        formatter_class=SmartFormatter,\n        epilog=(\n            \"For more information, visit http://spotdl.rtfd.io/ \"\n            \"or join our Discord server: https://discord.com/invite/xCa23pwJWY\"\n        ),\n    )\n\n    # Parse main options\n    main_options = parser.add_argument_group(\"Main options\")\n    parse_main_options(main_options)\n\n    # Parse spotify options\n    spotify_options = parser.add_argument_group(\"Spotify options\")\n    parse_spotify_options(spotify_options)\n\n    # Parse ffmpeg options\n    ffmpeg_options = parser.add_argument_group(\"FFmpeg options\")\n    parse_ffmpeg_options(ffmpeg_options)\n\n    # Parse output options\n    output_options = parser.add_argument_group(\"Output options\")\n    parse_output_options(output_options)\n\n    # Parse web options\n    web_options = parser.add_argument_group(\"Web options\")\n    parse_web_options(web_options)\n\n    # Parse misc options\n    misc_options = parser.add_argument_group(\"Misc options\")\n    parse_misc_options(misc_options)\n\n    # Parse other options\n    other_options = parser.add_argument_group(\"Other options\")\n    parse_other_options(other_options)\n\n    return parser\n</code></pre>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_arguments","title":"<code>parse_arguments()</code>","text":"<p>Parse arguments from the command line.</p>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_arguments--arguments","title":"Arguments","text":"<ul> <li>parser: The argument parser to parse the arguments from.</li> </ul>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_arguments--returns","title":"Returns","text":"<ul> <li>A Namespace object containing the parsed arguments.</li> </ul> Source code in <code>spotdl/utils/arguments.py</code> <pre><code>def parse_arguments() -&gt; Namespace:\n    \"\"\"\n    Parse arguments from the command line.\n\n    ### Arguments\n    - parser: The argument parser to parse the arguments from.\n\n    ### Returns\n    - A Namespace object containing the parsed arguments.\n    \"\"\"\n\n    # Create parser\n    parser = create_parser()\n\n    # Parse arguments\n    return parser.parse_args()\n</code></pre>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_ffmpeg_options","title":"<code>parse_ffmpeg_options(parser)</code>","text":"<p>Parse ffmpeg options from the command line.</p>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_ffmpeg_options--arguments","title":"Arguments","text":"<ul> <li>parser: The argument parser to add the options to.</li> </ul> Source code in <code>spotdl/utils/arguments.py</code> <pre><code>def parse_ffmpeg_options(parser: _ArgumentGroup):\n    \"\"\"\n    Parse ffmpeg options from the command line.\n\n    ### Arguments\n    - parser: The argument parser to add the options to.\n    \"\"\"\n\n    # Add ffmpeg executable argument\n    parser.add_argument(\n        \"--ffmpeg\",\n        help=\"The ffmpeg executable to use.\",\n        type=str,\n    )\n\n    # Add search threads argument\n    parser.add_argument(\n        \"--threads\",\n        type=int,\n        help=\"The number of threads to use when downloading songs.\",\n    )\n\n    # Add constant bit rate argument\n    parser.add_argument(\n        \"--bitrate\",\n        choices=[\n            \"auto\",\n            \"disable\",\n            \"8k\",\n            \"16k\",\n            \"24k\",\n            \"32k\",\n            \"40k\",\n            \"48k\",\n            \"64k\",\n            \"80k\",\n            \"96k\",\n            \"112k\",\n            \"128k\",\n            \"160k\",\n            \"192k\",\n            \"224k\",\n            \"256k\",\n            \"320k\",\n        ]\n        + list(map(str, range(0, 10))),\n        type=str.lower,\n        help=(\n            \"The constant/variable bitrate to use for the output file. \"\n            \"Values from 0 to 9 are variable bitrates. \"\n            \"Auto will use the bitrate of the original file. \"\n            \"Disable will disable the bitrate option. \"\n            \"(In case of m4a and opus files, auto and disable will skip the conversion)\"\n        ),\n    )\n\n    # Additional ffmpeg arguments\n    parser.add_argument(\n        \"--ffmpeg-args\",\n        type=str,\n        help=\"Additional ffmpeg arguments passed as a string.\",\n    )\n</code></pre>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_main_options","title":"<code>parse_main_options(parser)</code>","text":"<p>Parse main options from the command line.</p>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_main_options--arguments","title":"Arguments","text":"<ul> <li>parser: The argument parser to add the options to.</li> </ul> Source code in <code>spotdl/utils/arguments.py</code> <pre><code>def parse_main_options(parser: _ArgumentGroup):\n    \"\"\"\n    Parse main options from the command line.\n\n    ### Arguments\n    - parser: The argument parser to add the options to.\n    \"\"\"\n\n    # Add operation argument\n    operation = parser.add_argument(\n        \"operation\",\n        choices=OPERATIONS,\n        default=\"download\",\n        const=\"download\",\n        nargs=\"?\",\n        help=(\n            \"N|The operation to perform.\\n\"\n            \"download: Download the songs to the disk and embed metadata.\\n\"\n            \"save: Saves the songs metadata to a file for further use.\\n\"\n            \"web: Starts a web interface to simplify the download process.\\n\"\n            \"sync: Removes songs that are no longer present, downloads new ones\\n\"\n            \"meta: Update your audio files with metadata\\n\"\n            \"url: Get the download URL for songs\\n\\n\"\n        ),\n    )\n\n    # Add query argument\n    query = parser.add_argument(\n        \"query\",\n        nargs=\"+\",\n        type=str,\n        help=(\n            \"N|Spotify/YouTube URL for a song/playlist/album/artist/etc. to download.\\n\\n\"\n            \"For album/playlist/artist searching, include 'album:', 'playlist:', 'artist:' \\n\"\n            \"(ie. 'album:the album name' you can mix these options to get more accurate results)\"\n            \".\\n\\n\"\n            \"To download liked songs use 'saved' as the query, to download all user playlists\\n\"\n            \"use 'all-user-playlists, to download playlists that the user has created\\n\"\n            \"use 'all-saved-playlists', to download all user liked playlists\\n\"\n            \"use 'all-user-followed-artists', to download all user saved albums \"\n            \"use 'all-user-saved-albums' \\n\\n\"\n            \"For manual audio matching, you can use the format 'YouTubeURL|SpotifyURL'\\n\"\n            \"You can only use album/playlist/tracks urls when \"\n            \"downloading/matching youtube urls.\\n\"\n            \"When using youtube url without spotify url, \"\n            \"you won't be able to use `--fetch-albums` option.\\n\\n\"\n        ),\n    )\n\n    try:\n        is_web = sys.argv[1] == \"web\"\n    except IndexError:\n        is_web = False\n\n    is_frozen = getattr(sys, \"frozen\", False)\n\n    # If the program is frozen, we and user didn't pass any arguments,\n    # or if the user is using the web interface, we don't need to parse\n    # the query\n    if (is_frozen and len(sys.argv) &lt; 2) or (len(sys.argv) &gt; 1 and is_web):\n        # If we are running the web interface\n        # or we are in the frozen env and not running web interface\n        # don't remove the operation from the arg parser\n        if not is_web or (is_frozen and not is_web):\n            parser._remove_action(operation)  # pylint: disable=protected-access\n\n        parser._remove_action(query)  # pylint: disable=protected-access\n\n    # Audio provider argument\n    parser.add_argument(\n        \"--audio\",\n        dest=\"audio_providers\",\n        nargs=\"*\",\n        choices=AUDIO_PROVIDERS,\n        help=\"The audio provider to use. You can provide more than one for fallback.\",\n    )\n\n    # Lyrics provider argument\n    parser.add_argument(\n        \"--lyrics\",\n        dest=\"lyrics_providers\",\n        nargs=\"*\",\n        choices=LYRICS_PROVIDERS.keys(),\n        help=(\n            \"The lyrics provider to use. You can provide more than one for fallback. \"\n            \"Synced lyrics might not work correctly with some music players. \"\n            \"For such cases it's better to use `--generate-lrc` option.\"\n        ),\n    )\n\n    parser.add_argument(\n        \"--genius-access-token\",\n        dest=\"genius_token\",\n        help=\"Lets you choose your own Genius access token.\",\n    )\n\n    # Add config argument\n    parser.add_argument(\n        \"--config\",\n        action=\"store_true\",\n        help=(\n            \"Use the config file to download songs. \"\n            \"It's located under C:\\\\Users\\\\user\\\\.spotdl\\\\config.json \"\n            \"or ~/.spotdl/config.json under linux\"\n        ),\n    )\n\n    # Add search query argument\n    parser.add_argument(\n        \"--search-query\",\n        help=f\"The search query to use, available variables: {', '.join(VARS)}\",\n        type=str,\n    )\n\n    # Add don't filter results argument\n    parser.add_argument(\n        \"--dont-filter-results\",\n        dest=\"filter_results\",\n        action=\"store_const\",\n        const=False,\n        help=\"Disable filtering results.\",\n    )\n\n    # Add use only verified results argument\n    parser.add_argument(\n        \"--album-type\",\n        choices={\"album\", \"single\"},\n        help=\"Type of the album to search for. (album, single)\",\n        type=str,\n    )\n\n    # Add use only verified results argument\n    parser.add_argument(\n        \"--only-verified-results\",\n        action=\"store_const\",\n        const=True,\n        help=\"Use only verified results. (Not all providers support this)\",\n    )\n</code></pre>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_misc_options","title":"<code>parse_misc_options(parser)</code>","text":"<p>Parse misc options from the command line.</p>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_misc_options--arguments","title":"Arguments","text":"<ul> <li>parser: The argument parser to add the options to.</li> </ul> Source code in <code>spotdl/utils/arguments.py</code> <pre><code>def parse_misc_options(parser: _ArgumentGroup):\n    \"\"\"\n    Parse misc options from the command line.\n\n    ### Arguments\n    - parser: The argument parser to add the options to.\n    \"\"\"\n\n    # Add verbose argument\n    parser.add_argument(\n        \"--log-level\",\n        choices=NAME_TO_LEVEL.keys(),\n        help=\"Select log level.\",\n    )\n\n    # Add simple tui argument\n    parser.add_argument(\n        \"--simple-tui\",\n        action=\"store_const\",\n        const=True,\n        help=\"Use a simple tui.\",\n    )\n\n    # Add log format argument\n    parser.add_argument(\n        \"--log-format\",\n        help=(\n            \"Custom logging format to use. More info: \"\n            \"https://docs.python.org/3/library/logging.html#logrecord-attributes\"\n        ),\n    )\n</code></pre>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_other_options","title":"<code>parse_other_options(parser)</code>","text":"<p>Parse other options from the command line.</p>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_other_options--arguments","title":"Arguments","text":"<ul> <li>parser: The argument parser to add the options to.</li> </ul> Source code in <code>spotdl/utils/arguments.py</code> <pre><code>def parse_other_options(parser: _ArgumentGroup):\n    \"\"\"\n    Parse other options from the command line.\n\n    ### Arguments\n    - parser: The argument parser to add the options to.\n    \"\"\"\n\n    parser.add_argument(\n        \"--download-ffmpeg\",\n        action=\"store_true\",\n        help=\"Download ffmpeg to spotdl directory.\",\n    )\n\n    parser.add_argument(\n        \"--generate-config\",\n        action=\"store_true\",\n        help=\"Generate a config file. This will overwrite current config if present.\",\n    )\n\n    parser.add_argument(\n        \"--check-for-updates\", action=\"store_true\", help=\"Check for new version.\"\n    )\n\n    parser.add_argument(\n        \"--profile\",\n        action=\"store_true\",\n        help=\"Run in profile mode. Useful for debugging.\",\n    )\n\n    parser.add_argument(\n        \"--version\",\n        \"-v\",\n        action=\"version\",\n        help=\"Show the version number and exit.\",\n        version=_version.__version__,\n    )\n</code></pre>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_output_options","title":"<code>parse_output_options(parser)</code>","text":"<p>Parse output options from the command line.</p>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_output_options--arguments","title":"Arguments","text":"<ul> <li>parser: The argument parser to add the options to.</li> </ul> Source code in <code>spotdl/utils/arguments.py</code> <pre><code>def parse_output_options(parser: _ArgumentGroup):\n    \"\"\"\n    Parse output options from the command line.\n\n    ### Arguments\n    - parser: The argument parser to add the options to.\n    \"\"\"\n\n    # Add output format argument\n    parser.add_argument(\n        \"--format\",\n        choices=FFMPEG_FORMATS.keys(),\n        help=\"The format to download the song in.\",\n        type=str,\n    )\n\n    # Add save file argument\n    parser.add_argument(\n        \"--save-file\",\n        type=str,\n        help=(\n            \"The file to save/load the songs data from/to. \"\n            \"It has to end with .spotdl. \"\n            \"If combined with the download operation, it will save the songs data to the file. \"\n            \"Required for save/sync (use - to print to stdout when using save). \"\n        ),\n        required=len(sys.argv) &gt; 1 and sys.argv[1] in [\"save\"],\n    )\n\n    # Add preload argument\n    parser.add_argument(\n        \"--preload\",\n        action=\"store_const\",\n        const=True,\n        help=\"Preload the download url to speed up the download process.\",\n    )\n\n    # Add name format argument\n    parser.add_argument(\n        \"--output\",\n        type=str,\n        help=f\"Specify the downloaded file name format, available variables: {', '.join(VARS)}\",\n    )\n\n    # Add m3u argument\n    parser.add_argument(\n        \"--m3u\",\n        type=str,\n        nargs=\"?\",\n        help=(\n            \"Name of the m3u file to save the songs to. \"\n            \"Defaults to {list[0]}.m3u8 \"\n            \"If you want to generate a m3u for each list in the query use {list}, \"\n            \"If you want to generate a m3u file based on the first list in the query use {list[0]}\"\n            \", (0 is the first list in the query, 1 is the second, etc. \"\n            \"songs don't count towards the list number) \"\n        ),\n        const=\"{list[0]}.m3u8\",\n    )\n\n    # Add cookie file argument\n    parser.add_argument(\n        \"--cookie-file\",\n        help=\"Path to cookies file.\",\n        type=str,\n    )\n\n    # Add overwrite argument\n    parser.add_argument(\n        \"--overwrite\",\n        choices={\"force\", \"skip\", \"metadata\"},\n        help=(\n            \"How to handle existing/duplicate files. \"\n            \"(When combined with --scan-for-songs force will remove \"\n            \"all duplicates, and metadata will only apply metadata to the \"\n            \"latest song and will remove the rest. )\"\n        ),\n        type=str,\n    )\n\n    # Option to increase compatibility of filenames and easier handling in the shell\n    parser.add_argument(\n        \"--restrict\",\n        choices={\"strict\", \"ascii\", \"none\"},\n        const=\"strict\",\n        nargs=\"?\",\n        help=\"Restrict filenames to a sanitized set of characters for better compatibility\",\n        type=str,\n    )\n\n    # Option to print errors on exit, useful for long playlist\n    parser.add_argument(\n        \"--print-errors\",\n        action=\"store_const\",\n        const=True,\n        help=\"Print errors (wrong songs, failed downloads etc) on exit, useful for long playlist\",\n    )\n\n    # Option to save errors to a file\n    parser.add_argument(\n        \"--save-errors\",\n        type=str,\n        help=\"Save errors (wrong songs, failed downloads etc) to a file\",\n    )\n\n    # Option to use sponsor block\n    parser.add_argument(\n        \"--sponsor-block\",\n        action=\"store_const\",\n        const=True,\n        help=\"Use the sponsor block to download songs from yt/ytm.\",\n    )\n\n    # Add archive_file argument\n    parser.add_argument(\n        \"--archive\",\n        type=str,\n        help=\"Specify the file name for an archive of already downloaded songs\",\n    )\n\n    # Option to set the track number &amp; album of tracks in a playlist to their index in the playlist\n    # &amp; the name of playlist respectively.\n    parser.add_argument(\n        \"--playlist-numbering\",\n        action=\"store_const\",\n        dest=\"playlist_numbering\",\n        const=True,\n        help=\"Sets each track in a playlist to have the playlist's name as its album,\\\n            and album art as the playlist's icon\",\n    )\n\n    # Option to set the track number &amp; album of tracks, while retaining album art of each track, in\n    # a playlist to their index in the playlist &amp; the name of playlist respectively.\n    parser.add_argument(\n        \"--playlist-retain-track-cover\",\n        action=\"store_const\",\n        dest=\"playlist_retain_track_cover\",\n        const=True,\n        help=\"Sets each track in a playlist to have the playlist's name as its album,\\\n            while retaining album art of each track\",\n    )\n\n    # Option to scan the output directory for existing files\n    parser.add_argument(\n        \"--scan-for-songs\",\n        action=\"store_const\",\n        const=True,\n        help=(\n            \"Scan the output directory for existing files. \"\n            \"This option should be combined with the --overwrite option \"\n            \"to control how existing files are handled. (Output directory is the last directory \"\n            \"that is not a template variable in the output template)\"\n        ),\n    )\n\n    # Option to fetch all albums from songs in query\n    parser.add_argument(\n        \"--fetch-albums\",\n        action=\"store_const\",\n        const=True,\n        help=\"Fetch all albums from songs in query\",\n    )\n\n    # Option to change the id3 separator\n    parser.add_argument(\n        \"--id3-separator\",\n        type=str,\n        help=\"Change the separator used in the id3 tags. Only supported for mp3 files.\",\n    )\n\n    # Option to use ytm data instead of spotify data\n    # when downloading using ytm link\n    parser.add_argument(\n        \"--ytm-data\",\n        action=\"store_const\",\n        const=True,\n        help=\"Use ytm data instead of spotify data when downloading using ytm link.\",\n    )\n\n    # Option whether to add unavailable songs to the m3u file\n    parser.add_argument(\n        \"--add-unavailable\",\n        action=\"store_const\",\n        const=True,\n        help=\"Add unavailable songs to the m3u/archive files when downloading\",\n    )\n\n    # Generate lrc files\n    parser.add_argument(\n        \"--generate-lrc\",\n        action=\"store_const\",\n        const=True,\n        help=(\n            \"Generate lrc files for downloaded songs. \"\n            \"Requires `synced` provider to be present in the lyrics providers list.\"\n        ),\n    )\n\n    # Force update metadata\n    parser.add_argument(\n        \"--force-update-metadata\",\n        action=\"store_const\",\n        const=True,\n        help=\"Force update metadata for songs that already have metadata.\",\n    )\n\n    # Sync without deleting\n    parser.add_argument(\n        \"--sync-without-deleting\",\n        action=\"store_const\",\n        const=True,\n        help=\"Sync without deleting songs that are not in the query.\",\n    )\n\n    # Max file name length\n    parser.add_argument(\n        \"--max-filename-length\",\n        type=int,\n        help=(\n            \"Max file name length. \"\n            \"(This won't override the max file name length enforced by the OS)\"\n        ),\n    )\n\n    # YT-DlP options\n    parser.add_argument(\n        \"--yt-dlp-args\",\n        type=str,\n        help=\"Arguments to pass to yt-dlp\",\n    )\n\n    # Detect formats option\n    parser.add_argument(\n        \"--detect-formats\",\n        type=str,\n        nargs=\"*\",\n        help=(\n            \"Detect already downloaded songs with file format different from the --format option \"\n            \"(When combined with --m3u option, \"\n            \"only first detected format will be added to m3u file)\"\n        ),\n        choices=FFMPEG_FORMATS.keys(),\n    )\n\n    # download song in meta operation\n    parser.add_argument(\n        \"--redownload\",\n        action=\"store_const\",\n        const=True,\n        help=\"to redownload the local song in diffrent format using --format for meta operation\",\n    )\n\n    # skip album art for meta operation\n    parser.add_argument(\n        \"--skip-album-art\",\n        action=\"store_const\",\n        const=True,\n        help=\"skip downloading album art for meta operation\",\n    )\n\n    # Ignore songs from a paticular album\n    parser.add_argument(\n        \"--ignore-albums\",\n        type=str,\n        nargs=\"*\",\n        help=\"ignores the song of the given albums\",\n    )\n\n    # Skip explicit songs options\n    parser.add_argument(\n        \"--skip-explicit\", action=\"store_const\", const=True, help=\"Skip explicit songs\"\n    )\n\n    parser.add_argument(\n        \"--proxy\",\n        help=\"Http(s) proxy server for download song. Example: http://host:port\",\n    )\n\n    # Skip songs having a skip flag file\n    parser.add_argument(\n        \"--create-skip-file\",\n        action=\"store_const\",\n        const=True,\n        help=\"Create skip file for successfully downloaded file\",\n    )\n\n    # Skip songs having a skip flag file\n    parser.add_argument(\n        \"--respect-skip-file\",\n        action=\"store_const\",\n        const=True,\n        help=\"If a file with the extension .skip exists, skip download\",\n    )\n\n    # Sync remove lrc files\n    parser.add_argument(\n        \"--sync-remove-lrc\",\n        action=\"store_const\",\n        const=True,\n        help=\"Remove lrc files when using sync operation when downloading songs\",\n    )\n</code></pre>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_spotify_options","title":"<code>parse_spotify_options(parser)</code>","text":"<p>Parse spotify options from the command line.</p>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_spotify_options--arguments","title":"Arguments","text":"<ul> <li>parser: The argument parser to add the options to.</li> </ul> Source code in <code>spotdl/utils/arguments.py</code> <pre><code>def parse_spotify_options(parser: _ArgumentGroup):\n    \"\"\"\n    Parse spotify options from the command line.\n\n    ### Arguments\n    - parser: The argument parser to add the options to.\n    \"\"\"\n\n    # Add login argument\n    parser.add_argument(\n        \"--user-auth\",\n        action=\"store_const\",\n        const=True,\n        help=\"Login to Spotify using OAuth.\",\n    )\n\n    # Add client id argument\n    parser.add_argument(\n        \"--client-id\",\n        help=\"The client id to use when logging in to Spotify.\",\n        type=str,\n    )\n\n    # Add client secret argument\n    parser.add_argument(\n        \"--client-secret\",\n        help=\"The client secret to use when logging in to Spotify.\",\n        type=str,\n    )\n\n    # Add auth token argument\n    parser.add_argument(\n        \"--auth-token\",\n        help=\"The authorization token to use directly to log in to Spotify.\",\n        type=str,\n    )\n\n    # Add cache path argument\n    parser.add_argument(\n        \"--cache-path\",\n        type=str,\n        help=\"The path where spotipy cache file will be stored.\",\n    )\n\n    # Add no cache argument\n    parser.add_argument(\n        \"--no-cache\",\n        action=\"store_const\",\n        const=True,\n        help=\"Disable caching (both requests and token).\",\n    )\n\n    # Add max retries argument\n    parser.add_argument(\n        \"--max-retries\",\n        type=int,\n        help=\"The maximum number of retries to perform when getting metadata.\",\n    )\n\n    # Add headless argument\n    parser.add_argument(\n        \"--headless\",\n        action=\"store_const\",\n        const=True,\n        help=\"Run in headless mode.\",\n    )\n\n    # Add use cache file argument\n    parser.add_argument(\n        \"--use-cache-file\",\n        action=\"store_const\",\n        const=True,\n        help=(\n            \"Use the cache file to get metadata. \"\n            \"It's located under C:\\\\Users\\\\user\\\\.spotdl\\\\.spotify_cache \"\n            \"or ~/.spotdl/.spotify_cache under linux. \"\n            \"It only caches tracks and \"\n            \"gets updated whenever spotDL gets metadata from Spotify. \"\n            \"(It may provide outdated metadata use with caution)\"\n        ),\n    )\n</code></pre>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_web_options","title":"<code>parse_web_options(parser)</code>","text":"<p>Parse web options from the command line.</p>"},{"location":"reference/utils/arguments/#spotdl.utils.arguments.parse_web_options--arguments","title":"Arguments","text":"<ul> <li>parser: The argument parser to add the options to.</li> </ul> Source code in <code>spotdl/utils/arguments.py</code> <pre><code>def parse_web_options(parser: _ArgumentGroup):\n    \"\"\"\n    Parse web options from the command line.\n\n    ### Arguments\n    - parser: The argument parser to add the options to.\n    \"\"\"\n\n    # Add host argument\n    parser.add_argument(\n        \"--host\",\n        type=str,\n        help=\"The host to use for the web server.\",\n    )\n\n    # Add port argument\n    parser.add_argument(\n        \"--port\",\n        type=int,\n        help=\"The port to run the web server on.\",\n    )\n\n    # Add keep alive argument\n    parser.add_argument(\n        \"--keep-alive\",\n        action=\"store_const\",\n        const=True,\n        help=\"Keep the web server alive even when no clients are connected.\",\n    )\n\n    # Add allowed origins argument\n    parser.add_argument(\n        \"--allowed-origins\",\n        nargs=\"*\",\n        help=\"The allowed origins for the web server.\",\n    )\n\n    # Add use output directory argument\n    parser.add_argument(\n        \"--web-use-output-dir\",\n        action=\"store_const\",\n        const=True,\n        help=(\n            \"Use the output directory instead of the session directory for downloads. (\"\n            \"This might cause issues if you have multiple users using the web-ui at the same time)\"\n        ),\n    )\n\n    # Add keep sessions argument\n    parser.add_argument(\n        \"--keep-sessions\",\n        action=\"store_const\",\n        const=True,\n        help=\"Keep the session directory after the web server is closed.\",\n    )\n\n    # Add keep sessions argument\n    parser.add_argument(\n        \"--force-update-gui\",\n        action=\"store_const\",\n        const=True,\n        default=False,\n        help=\"Refresh the web server directory with a fresh git checkout\",\n    )\n\n    # Add custom web gui repo\n    parser.add_argument(\n        \"--web-gui-repo\",\n        type=str,\n        help=(\n            \"Custom web gui repo to use for the web server. \"\n            \"Example: https://github.com/spotdl/web-ui/tree/master/dist\"\n        ),\n    )\n\n    # Add custom web gui repo\n    parser.add_argument(\n        \"--web-gui-location\",\n        type=str,\n        help=\"Path to the web gui directory to use for the web server.\",\n    )\n\n    # Enable TLS for the web server\n    parser.add_argument(\n        \"--enable-tls\",\n        action=\"store_const\",\n        const=True,\n        help=\"Enable TLS on the web server.\",\n    )\n\n    # Add File Location of the TLS Certificate file (Pem Format)\n    parser.add_argument(\n        \"--cert-file\", type=str, help=\"File Path to the TLS Certificate (PEM format).\"\n    )\n\n    # Add File Location of the TLS Private Key file (Pem Format)\n    parser.add_argument(\n        \"--key-file\", type=str, help=\"File Path to the TLS Private Key (PEM format).\"\n    )\n\n    # Add File Location of the TLS Certificate Authority file (Pem Format)\n    parser.add_argument(\n        \"--ca-file\",\n        type=str,\n        help=\"File Path to the TLS Certificate Authority File (PEM format).\",\n    )\n</code></pre>"},{"location":"reference/utils/config/","title":"config","text":"<p>Module related to managing reading and writing to the config file.</p> <p>Default config - spotdl.utils.config.DEFAULT_CONFIG</p>"},{"location":"reference/utils/config/#spotdl.utils.config.ConfigError","title":"<code>ConfigError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all exceptions related to config.</p>"},{"location":"reference/utils/config/#spotdl.utils.config.GlobalConfig","title":"<code>GlobalConfig</code>","text":"<p>Class to store global configuration</p>"},{"location":"reference/utils/config/#spotdl.utils.config.GlobalConfig.get_parameter","title":"<code>get_parameter(key)</code>  <code>classmethod</code>","text":"<p>Get a parameter from the download config</p> Source code in <code>spotdl/utils/config.py</code> <pre><code>@classmethod\ndef get_parameter(cls, key):\n    \"\"\"\n    Get a parameter from the download config\n    \"\"\"\n\n    return cls.parameters.get(key, None)\n</code></pre>"},{"location":"reference/utils/config/#spotdl.utils.config.GlobalConfig.set_parameter","title":"<code>set_parameter(key, value)</code>  <code>classmethod</code>","text":"<p>Set a parameter for the download config</p> Source code in <code>spotdl/utils/config.py</code> <pre><code>@classmethod\ndef set_parameter(cls, key, value):\n    \"\"\"\n    Set a parameter for the download config\n    \"\"\"\n\n    cls.parameters[key] = value\n</code></pre>"},{"location":"reference/utils/config/#spotdl.utils.config.create_settings","title":"<code>create_settings(arguments)</code>","text":"<p>Create settings dicts for Spotify, Downloader and Web based on the arguments and config file (if enabled)</p>"},{"location":"reference/utils/config/#spotdl.utils.config.create_settings--arguments","title":"Arguments","text":"<ul> <li>arguments: Namespace from argparse</li> </ul>"},{"location":"reference/utils/config/#spotdl.utils.config.create_settings--returns","title":"Returns","text":"<ul> <li>spotify_options: SpotifyOptions</li> <li>downloader_options: DownloaderOptions</li> <li>web_options: WebOptions</li> </ul> Source code in <code>spotdl/utils/config.py</code> <pre><code>def create_settings(\n    arguments: Namespace,\n) -&gt; Tuple[SpotifyOptions, DownloaderOptions, WebOptions]:\n    \"\"\"\n    Create settings dicts for Spotify, Downloader and Web\n    based on the arguments and config file (if enabled)\n\n    ### Arguments\n    - arguments: Namespace from argparse\n\n    ### Returns\n    - spotify_options: SpotifyOptions\n    - downloader_options: DownloaderOptions\n    - web_options: WebOptions\n    \"\"\"\n\n    # Get the config file\n    # It will automatically load if the `load_config` is set to True\n    # in the config file\n    config = {}\n    if arguments.config or (\n        get_config_file().exists() and get_config().get(\"load_config\")\n    ):\n        config = get_config()\n\n    # Type: ignore because of the issues below\n    # https://github.com/python/mypy/issues/8890\n    # https://github.com/python/mypy/issues/5382\n    spotify_options = SpotifyOptions(\n        **create_settings_type(arguments, config, SPOTIFY_OPTIONS)  # type: ignore\n    )\n    downloader_options = DownloaderOptions(\n        **create_settings_type(arguments, config, DOWNLOADER_OPTIONS)  # type: ignore\n    )\n    web_options = WebOptions(**create_settings_type(arguments, config, WEB_OPTIONS))  # type: ignore\n\n    return spotify_options, downloader_options, web_options\n</code></pre>"},{"location":"reference/utils/config/#spotdl.utils.config.create_settings_type","title":"<code>create_settings_type(arguments, config, default)</code>","text":"<p>Create settings dict Argument value has always the priority, then the config file value, and if neither are set, use default value</p>"},{"location":"reference/utils/config/#spotdl.utils.config.create_settings_type--arguments","title":"Arguments","text":"<ul> <li>arguments: Namespace from argparse</li> <li>default: dict</li> </ul>"},{"location":"reference/utils/config/#spotdl.utils.config.create_settings_type--returns","title":"Returns","text":"<ul> <li>settings: dict</li> </ul> Source code in <code>spotdl/utils/config.py</code> <pre><code>def create_settings_type(\n    arguments: Namespace,\n    config: Dict[str, Any],\n    default: Union[SpotifyOptions, DownloaderOptions, WebOptions],\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Create settings dict\n    Argument value has always the priority, then the config file\n    value, and if neither are set, use default value\n\n    ### Arguments\n    - arguments: Namespace from argparse\n    - default: dict\n\n    ### Returns\n    - settings: dict\n    \"\"\"\n\n    settings = {}\n    for key, default_value in default.items():\n        argument_val = arguments.__dict__.get(key)\n        config_val = config.get(key)\n\n        if argument_val is not None:\n            settings[key] = argument_val\n        elif config_val is not None:\n            settings[key] = config_val\n        else:\n            settings[key] = default_value\n\n    return settings\n</code></pre>"},{"location":"reference/utils/config/#spotdl.utils.config.get_cache_path","title":"<code>get_cache_path()</code>","text":"<p>Get the path to the cache folder.</p>"},{"location":"reference/utils/config/#spotdl.utils.config.get_cache_path--returns","title":"Returns","text":"<ul> <li>The path to the spotipy cache file.</li> </ul> Source code in <code>spotdl/utils/config.py</code> <pre><code>def get_cache_path() -&gt; Path:\n    \"\"\"\n    Get the path to the cache folder.\n\n    ### Returns\n    - The path to the spotipy cache file.\n    \"\"\"\n\n    return get_spotdl_path() / \".spotipy\"\n</code></pre>"},{"location":"reference/utils/config/#spotdl.utils.config.get_config","title":"<code>get_config()</code>","text":"<p>Get the config.</p>"},{"location":"reference/utils/config/#spotdl.utils.config.get_config--returns","title":"Returns","text":"<ul> <li>The dictionary with the config.</li> </ul>"},{"location":"reference/utils/config/#spotdl.utils.config.get_config--errors","title":"Errors","text":"<ul> <li>ConfigError: If the config file does not exist.</li> </ul> Source code in <code>spotdl/utils/config.py</code> <pre><code>def get_config() -&gt; Dict[str, Any]:\n    \"\"\"\n    Get the config.\n\n    ### Returns\n    - The dictionary with the config.\n\n    ### Errors\n    - ConfigError: If the config file does not exist.\n    \"\"\"\n\n    config_path = get_config_file()\n\n    if not config_path.exists():\n        raise ConfigError(\n            \"Config file not found.\"\n            \"Please run `spotdl --generate-config` to create a config file.\"\n        )\n\n    with open(config_path, \"r\", encoding=\"utf-8\") as config_file:\n        return json.load(config_file)\n</code></pre>"},{"location":"reference/utils/config/#spotdl.utils.config.get_config_file","title":"<code>get_config_file()</code>","text":"<p>Get config file path</p>"},{"location":"reference/utils/config/#spotdl.utils.config.get_config_file--returns","title":"Returns","text":"<ul> <li>The path to the config file.</li> </ul> Source code in <code>spotdl/utils/config.py</code> <pre><code>def get_config_file() -&gt; Path:\n    \"\"\"\n    Get config file path\n\n    ### Returns\n    - The path to the config file.\n    \"\"\"\n\n    return get_spotdl_path() / \"config.json\"\n</code></pre>"},{"location":"reference/utils/config/#spotdl.utils.config.get_errors_path","title":"<code>get_errors_path()</code>","text":"<p>Get the path to the errors folder.</p>"},{"location":"reference/utils/config/#spotdl.utils.config.get_errors_path--returns","title":"Returns","text":"<ul> <li>The path to the errors folder.</li> </ul>"},{"location":"reference/utils/config/#spotdl.utils.config.get_errors_path--notes","title":"Notes","text":"<ul> <li>If the errors directory does not exist, it will be created.</li> </ul> Source code in <code>spotdl/utils/config.py</code> <pre><code>def get_errors_path() -&gt; Path:\n    \"\"\"\n    Get the path to the errors folder.\n\n    ### Returns\n    - The path to the errors folder.\n\n    ### Notes\n    - If the errors directory does not exist, it will be created.\n    \"\"\"\n\n    errors_path = get_spotdl_path() / \"errors\"\n\n    if not errors_path.exists():\n        os.mkdir(errors_path)\n\n    return errors_path\n</code></pre>"},{"location":"reference/utils/config/#spotdl.utils.config.get_spotdl_path","title":"<code>get_spotdl_path()</code>","text":"<p>Get the path to the spotdl folder.</p>"},{"location":"reference/utils/config/#spotdl.utils.config.get_spotdl_path--returns","title":"Returns","text":"<ul> <li>The path to the spotdl folder.</li> </ul>"},{"location":"reference/utils/config/#spotdl.utils.config.get_spotdl_path--notes","title":"Notes","text":"<ul> <li>If the spotdl directory does not exist, it will be created.</li> </ul> Source code in <code>spotdl/utils/config.py</code> <pre><code>def get_spotdl_path() -&gt; Path:\n    \"\"\"\n    Get the path to the spotdl folder.\n\n    ### Returns\n    - The path to the spotdl folder.\n\n    ### Notes\n    - If the spotdl directory does not exist, it will be created.\n    \"\"\"\n\n    # Check if os is linux\n    if platform.system() == \"Linux\":\n        # if platform is linux, and XDG DATA HOME spotdl folder exists, use it\n        user_data_dir = Path(platformdirs.user_data_dir(\"spotdl\", \"spotDL\"))\n        if user_data_dir.exists():\n            return user_data_dir\n\n    spotdl_path = Path(os.path.expanduser(\"~\"), \".spotdl\")\n    if not spotdl_path.exists():\n        os.mkdir(spotdl_path)\n\n    return spotdl_path\n</code></pre>"},{"location":"reference/utils/config/#spotdl.utils.config.get_spotify_cache_path","title":"<code>get_spotify_cache_path()</code>","text":"<p>Get the path to the spotify cache folder.</p>"},{"location":"reference/utils/config/#spotdl.utils.config.get_spotify_cache_path--returns","title":"Returns","text":"<ul> <li>The path to the spotipy cache file.</li> </ul> Source code in <code>spotdl/utils/config.py</code> <pre><code>def get_spotify_cache_path() -&gt; Path:\n    \"\"\"\n    Get the path to the spotify cache folder.\n\n    ### Returns\n    - The path to the spotipy cache file.\n    \"\"\"\n\n    return get_spotdl_path() / \".spotify_cache\"\n</code></pre>"},{"location":"reference/utils/config/#spotdl.utils.config.get_temp_path","title":"<code>get_temp_path()</code>","text":"<p>Get the path to the temp folder.</p>"},{"location":"reference/utils/config/#spotdl.utils.config.get_temp_path--returns","title":"Returns","text":"<ul> <li>The path to the temp folder.</li> </ul> Source code in <code>spotdl/utils/config.py</code> <pre><code>def get_temp_path() -&gt; Path:\n    \"\"\"\n    Get the path to the temp folder.\n\n    ### Returns\n    - The path to the temp folder.\n    \"\"\"\n\n    temp_path = get_spotdl_path() / \"temp\"\n    if not temp_path.exists():\n        os.mkdir(temp_path)\n\n    return temp_path\n</code></pre>"},{"location":"reference/utils/config/#spotdl.utils.config.get_web_ui_path","title":"<code>get_web_ui_path()</code>","text":"<p>Get the path to the web-ui folder.</p>"},{"location":"reference/utils/config/#spotdl.utils.config.get_web_ui_path--returns","title":"Returns","text":"<ul> <li>The path to the web-ui folder.</li> </ul>"},{"location":"reference/utils/config/#spotdl.utils.config.get_web_ui_path--notes","title":"Notes","text":"<ul> <li>If the web-ui directory does not exist, it will be created.</li> </ul> Source code in <code>spotdl/utils/config.py</code> <pre><code>def get_web_ui_path() -&gt; Path:\n    \"\"\"\n    Get the path to the web-ui folder.\n\n    ### Returns\n    - The path to the web-ui folder.\n\n    ### Notes\n    - If the web-ui directory does not exist, it will be created.\n    \"\"\"\n\n    web_ui_path = get_spotdl_path() / \"web-ui\"\n\n    if not web_ui_path.exists():\n        os.mkdir(web_ui_path)\n\n    return web_ui_path\n</code></pre>"},{"location":"reference/utils/config/#spotdl.utils.config.modernize_settings","title":"<code>modernize_settings(options)</code>","text":"<p>Handle deprecated values in config file.</p>"},{"location":"reference/utils/config/#spotdl.utils.config.modernize_settings--arguments","title":"Arguments","text":"<ul> <li>options: DownloaderOptions to modernize</li> </ul> Source code in <code>spotdl/utils/config.py</code> <pre><code>def modernize_settings(options: DownloaderOptions):\n    \"\"\"Handle deprecated values in config file.\n\n    ### Arguments\n    - options: DownloaderOptions to modernize\n    \"\"\"\n\n    warning_msg = \"Deprecated '%s' value found for '%s' setting in config file. Using '%s' instead.\"\n\n    # Respect backward compatibility with old boolean --restrict flag\n    if options[\"restrict\"] is True:\n        logger.warning(warning_msg, True, \"restrict\", \"strict\")\n        options[\"restrict\"] = \"strict\"\n</code></pre>"},{"location":"reference/utils/console/","title":"console","text":"<p>Module for holding console related actions.</p>"},{"location":"reference/utils/console/#spotdl.utils.console.check_for_updates","title":"<code>check_for_updates()</code>","text":"<p>Check for updates to the current version.</p> Source code in <code>spotdl/utils/console.py</code> <pre><code>def check_for_updates():\n    \"\"\"\n    Check for updates to the current version.\n    \"\"\"\n\n    version_message = get_update_status()\n\n    print(version_message)\n</code></pre>"},{"location":"reference/utils/console/#spotdl.utils.console.download_ffmpeg","title":"<code>download_ffmpeg()</code>","text":"<p>Handle ffmpeg download process and print the result.</p> Source code in <code>spotdl/utils/console.py</code> <pre><code>def download_ffmpeg():\n    \"\"\"\n    Handle ffmpeg download process and print the result.\n    \"\"\"\n\n    if get_local_ffmpeg() is not None or is_ffmpeg_installed():\n        overwrite_ffmpeg = input(\n            \"FFmpeg is already installed. Do you want to overwrite it? (y/N): \"\n        )\n\n        if overwrite_ffmpeg.lower() == \"y\":\n            local_ffmpeg = ffmpeg_download()\n\n            if local_ffmpeg.is_file():\n                print(f\"FFmpeg successfully downloaded to {local_ffmpeg.absolute()}\")\n            else:\n                print(\"FFmpeg download failed\")\n    else:\n        print(\"Downloading FFmpeg...\")\n        download_path = ffmpeg_download()\n\n        if download_path.is_file():\n            print(f\"FFmpeg successfully downloaded to {download_path.absolute()}\")\n        else:\n            print(\"FFmpeg download failed\")\n</code></pre>"},{"location":"reference/utils/console/#spotdl.utils.console.generate_config","title":"<code>generate_config()</code>","text":"<p>Generate the config file if it doesn't exist This is done before the argument parser so it doesn't requires <code>operation</code> and <code>query</code> to be passed.</p> Source code in <code>spotdl/utils/console.py</code> <pre><code>def generate_config():\n    \"\"\"\n    Generate the config file if it doesn't exist\n    This is done before the argument parser so it doesn't requires `operation`\n    and `query` to be passed.\n    \"\"\"\n\n    config_path = get_config_file()\n    if config_path.exists():\n        overwrite_config = input(\"Config file already exists. Overwrite? (y/N): \")\n\n        if overwrite_config.lower() != \"y\":\n            print(\"Exiting...\")\n            return None\n\n    with open(config_path, \"w\", encoding=\"utf-8\") as config_file:\n        json.dump(DEFAULT_CONFIG, config_file, indent=4)\n\n    print(f\"Config file generated at {config_path}\")\n\n    return None\n</code></pre>"},{"location":"reference/utils/console/#spotdl.utils.console.generate_initial_config","title":"<code>generate_initial_config()</code>","text":"<p>Generate the initial config file if it doesn't exist.</p> Source code in <code>spotdl/utils/console.py</code> <pre><code>def generate_initial_config():\n    \"\"\"\n    Generate the initial config file if it doesn't exist.\n    \"\"\"\n\n    if get_config_file().is_file() is False:\n        config_path = get_config_file()\n        with open(config_path, \"w\", encoding=\"utf-8\") as config_file:\n            json.dump(DEFAULT_CONFIG, config_file, indent=4)\n</code></pre>"},{"location":"reference/utils/console/#spotdl.utils.console.is_executable","title":"<code>is_executable()</code>","text":"<p>Check if the application is an prebuilt executable. And has been launched with double click.</p>"},{"location":"reference/utils/console/#spotdl.utils.console.is_executable--returns","title":"Returns","text":"<ul> <li><code>True</code> if the application is an prebuilt executable, <code>False</code> otherwise.</li> </ul> Source code in <code>spotdl/utils/console.py</code> <pre><code>def is_executable():\n    \"\"\"\n    Check if the application is an prebuilt executable.\n    And has been launched with double click.\n\n    ### Returns\n    - `True` if the application is an prebuilt executable, `False` otherwise.\n    \"\"\"\n\n    return is_frozen() and len(sys.argv) == 1\n</code></pre>"},{"location":"reference/utils/console/#spotdl.utils.console.is_frozen","title":"<code>is_frozen()</code>","text":"<p>Check if the application is frozen.</p>"},{"location":"reference/utils/console/#spotdl.utils.console.is_frozen--returns","title":"Returns","text":"<ul> <li><code>True</code> if the application is frozen, <code>False</code> otherwise.</li> </ul> Source code in <code>spotdl/utils/console.py</code> <pre><code>def is_frozen():\n    \"\"\"\n    Check if the application is frozen.\n\n    ### Returns\n    - `True` if the application is frozen, `False` otherwise.\n    \"\"\"\n\n    return getattr(sys, \"frozen\", False)\n</code></pre>"},{"location":"reference/utils/downloader/","title":"downloader","text":"<p>Module for functions related to downloading songs.</p>"},{"location":"reference/utils/downloader/#spotdl.utils.downloader.check_ytmusic_connection","title":"<code>check_ytmusic_connection()</code>","text":"<p>Check if we can connect to YouTube Music API</p>"},{"location":"reference/utils/downloader/#spotdl.utils.downloader.check_ytmusic_connection--returns","title":"Returns","text":"<ul> <li><code>True</code> if we can connect to YouTube Music API</li> <li><code>False</code> if we can't connect to YouTube Music API</li> </ul> Source code in <code>spotdl/utils/downloader.py</code> <pre><code>def check_ytmusic_connection() -&gt; bool:\n    \"\"\"\n    Check if we can connect to YouTube Music API\n\n    ### Returns\n    - `True` if we can connect to YouTube Music API\n    - `False` if we can't connect to YouTube Music API\n    \"\"\"\n\n    # Check if we are getting results from YouTube Music\n    ytm = YouTubeMusic()\n    test_results = ytm.get_results(\"a\")\n    if len(test_results) == 0:\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/utils/ffmpeg/","title":"ffmpeg","text":"<p>Module for converting audio files to different formats and checking for ffmpeg binary, and downloading it if not found.</p>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.FFmpegError","title":"<code>FFmpegError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all exceptions related to FFmpeg.</p>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.convert","title":"<code>convert(input_file, output_file, ffmpeg='ffmpeg', output_format='mp3', bitrate=None, ffmpeg_args=None, progress_handler=None)</code>","text":"<p>Convert the input file to the output file synchronously with progress handler.</p>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.convert--arguments","title":"Arguments","text":"<ul> <li>input_file: Path to input file or tuple of (url, file_format).</li> <li>output_file: Path to output file.</li> <li>ffmpeg: ffmpeg executable to use.</li> <li>output_format: output format.</li> <li>bitrate: constant/variable bitrate.</li> <li>ffmpeg_args: ffmpeg arguments.</li> <li>progress_handler: progress handler, has to accept an integer as argument.</li> </ul>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.convert--returns","title":"Returns","text":"<ul> <li>Tuple of conversion status and error dictionary.</li> </ul>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.convert--notes","title":"Notes","text":"<ul> <li>Make sure to check if ffmpeg is installed before calling this function.</li> </ul> Source code in <code>spotdl/utils/ffmpeg.py</code> <pre><code>def convert(\n    input_file: Union[Path, Tuple[str, str]],\n    output_file: Path,\n    ffmpeg: str = \"ffmpeg\",\n    output_format: str = \"mp3\",\n    bitrate: Optional[str] = None,\n    ffmpeg_args: Optional[str] = None,\n    progress_handler: Optional[Callable[[int], None]] = None,\n) -&gt; Tuple[bool, Optional[Dict[str, Any]]]:\n    \"\"\"\n    Convert the input file to the output file synchronously with progress handler.\n\n    ### Arguments\n    - input_file: Path to input file or tuple of (url, file_format).\n    - output_file: Path to output file.\n    - ffmpeg: ffmpeg executable to use.\n    - output_format: output format.\n    - bitrate: constant/variable bitrate.\n    - ffmpeg_args: ffmpeg arguments.\n    - progress_handler: progress handler, has to accept an integer as argument.\n\n    ### Returns\n    - Tuple of conversion status and error dictionary.\n\n    ### Notes\n    - Make sure to check if ffmpeg is installed before calling this function.\n    \"\"\"\n\n    # Initialize ffmpeg command\n    # -i is the input file\n    arguments: List[str] = [\n        \"-nostdin\",\n        \"-y\",\n        \"-i\",\n        str(input_file.resolve()) if isinstance(input_file, Path) else input_file[0],\n        \"-movflags\",\n        \"+faststart\",\n        \"-v\",\n        \"debug\",\n        \"-progress\",\n        \"-\",\n        \"-nostats\",\n    ]\n\n    file_format = (\n        str(input_file.suffix).split(\".\")[1]\n        if isinstance(input_file, Path)\n        else input_file[1]\n    )\n\n    # Add output format to command\n    # -c:a is used if the file is not an matroska container\n    # and we want to convert to opus\n    # otherwise we use arguments from FFMPEG_FORMATS\n    if output_format == \"opus\" and file_format != \"webm\":\n        arguments.extend([\"-c:a\", \"libopus\"])\n    else:\n        if (\n            (output_format == \"opus\" and file_format == \"webm\")\n            or (output_format == \"m4a\" and file_format == \"m4a\")\n            and not (bitrate or ffmpeg_args)\n        ):\n            # Copy the audio stream to the output file\n            arguments.extend([\"-vn\", \"-c:a\", \"copy\"])\n        else:\n            arguments.extend(FFMPEG_FORMATS[output_format])\n\n    # Add bitrate if specified\n    if bitrate:\n        # Check if bitrate is an integer\n        # if it is then use it as variable bitrate\n        if bitrate.isdigit():\n            arguments.extend([\"-q:a\", bitrate])\n        else:\n            arguments.extend([\"-b:a\", bitrate])\n\n    # Add other ffmpeg arguments if specified\n    if ffmpeg_args:\n        arguments.extend(shlex.split(ffmpeg_args))\n\n    # Add output file at the end\n    arguments.append(str(output_file.resolve()))\n\n    # Run ffmpeg\n    with subprocess.Popen(\n        [ffmpeg, *arguments],\n        stdin=subprocess.PIPE,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.STDOUT,\n        universal_newlines=False,\n    ) as process:\n        if not progress_handler:\n            # Wait for process to finish\n            proc_out = process.communicate()\n\n            if process.returncode != 0:\n                # get version and build year\n                version = get_ffmpeg_version(ffmpeg)\n\n                # join stdout and stderr and decode to utf-8\n                message = b\"\".join([out for out in proc_out if out]).decode(\"utf-8\")\n\n                # return error dictionary\n                return False, {\n                    \"return_code\": process.returncode,\n                    \"arguments\": arguments,\n                    \"ffmpeg\": ffmpeg,\n                    \"version\": version[0],\n                    \"build_year\": version[1],\n                    \"error\": message,\n                }\n\n            return True, None\n\n        progress_handler(0)\n\n        out_buffer = []\n        total_dur = None\n        while True:\n            if process.stdout is None:\n                continue\n\n            out_line = (\n                process.stdout.readline().decode(\"utf-8\", errors=\"replace\").strip()\n            )\n\n            if out_line == \"\" and process.poll() is not None:\n                break\n\n            out_buffer.append(out_line.strip())\n\n            total_dur_match = DUR_REGEX.search(out_line)\n            if total_dur is None and total_dur_match:\n                total_dur = to_ms(**total_dur_match.groupdict())  # type: ignore\n                continue\n            if total_dur:\n                progress_time = TIME_REGEX.search(out_line)\n                if progress_time:\n                    elapsed_time = to_ms(**progress_time.groupdict())  # type: ignore\n                    progress_handler(int(elapsed_time / total_dur * 100))  # type: ignore\n\n        if process.returncode != 0:\n            # get version and build year\n            version = get_ffmpeg_version(ffmpeg)\n\n            return False, {\n                \"return_code\": process.returncode,\n                \"arguments\": arguments,\n                \"ffmpeg\": ffmpeg,\n                \"version\": version[0],\n                \"build_year\": version[1],\n                \"error\": \"\\n\".join(out_buffer),\n            }\n\n        progress_handler(100)\n\n        return True, None\n</code></pre>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.download_ffmpeg","title":"<code>download_ffmpeg()</code>","text":"<p>Download ffmpeg binary to spotdl directory.</p>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.download_ffmpeg--returns","title":"Returns","text":"<ul> <li>Path to ffmpeg binary.</li> </ul>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.download_ffmpeg--notes","title":"Notes","text":"<ul> <li>ffmpeg is downloaded from github releases     for current platform and architecture.</li> <li>executable permission is set for ffmpeg binary.</li> </ul> Source code in <code>spotdl/utils/ffmpeg.py</code> <pre><code>def download_ffmpeg() -&gt; Path:\n    \"\"\"\n    Download ffmpeg binary to spotdl directory.\n\n    ### Returns\n    - Path to ffmpeg binary.\n\n    ### Notes\n    - ffmpeg is downloaded from github releases\n        for current platform and architecture.\n    - executable permission is set for ffmpeg binary.\n    \"\"\"\n\n    os_name = platform.system().lower()\n    os_arch = platform.machine().lower()\n    ffmpeg_url: Optional[str] = None\n\n    # if platform.system() == \"Darwin\" and (\n    #     platform.processor() == \"arm\"\n    #     or subprocess.run([\"sysctl\", \"-n\", \"sysctl.proc_translated\"], check=False)\n    # ):\n    #     ffmpeg_url = FFMPEG_URLS[\"darwin\"][\"arm\"]\n    # else:\n    #     ffmpeg_url = FFMPEG_URLS.get(os_name, {}).get(os_arch)\n\n    ffmpeg_url = FFMPEG_URLS.get(os_name, {}).get(os_arch)\n\n    if ffmpeg_url is None:\n        raise FFmpegError(\"FFmpeg binary is not available for your system.\")\n\n    ffmpeg_path = Path(\n        os.path.join(\n            get_spotdl_path(), \"ffmpeg\" + (\".exe\" if os_name == \"windows\" else \"\")\n        )\n    )\n\n    # Download binary and save it to a file in spotdl directory\n    ffmpeg_binary = requests.get(ffmpeg_url, allow_redirects=True, timeout=10).content\n    with open(ffmpeg_path, \"wb\") as ffmpeg_file:\n        ffmpeg_file.write(ffmpeg_binary)\n\n    # Set executable permission on linux and mac\n    if os_name in [\"linux\", \"darwin\"]:\n        ffmpeg_path.chmod(ffmpeg_path.stat().st_mode | stat.S_IEXEC)\n\n    return ffmpeg_path\n</code></pre>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.get_ffmpeg_path","title":"<code>get_ffmpeg_path()</code>","text":"<p>Get path to global ffmpeg binary or a local ffmpeg binary.</p>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.get_ffmpeg_path--returns","title":"Returns","text":"<ul> <li>Path to ffmpeg binary or None if not found.</li> </ul> Source code in <code>spotdl/utils/ffmpeg.py</code> <pre><code>def get_ffmpeg_path() -&gt; Optional[Path]:\n    \"\"\"\n    Get path to global ffmpeg binary or a local ffmpeg binary.\n\n    ### Returns\n    - Path to ffmpeg binary or None if not found.\n    \"\"\"\n\n    # Check if ffmpeg is installed\n    global_ffmpeg = shutil.which(\"ffmpeg\")\n    if global_ffmpeg:\n        return Path(global_ffmpeg)\n\n    # Get local ffmpeg path\n    return get_local_ffmpeg()\n</code></pre>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.get_ffmpeg_version","title":"<code>get_ffmpeg_version(ffmpeg='ffmpeg')</code>","text":"<p>Get ffmpeg version.</p>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.get_ffmpeg_version--arguments","title":"Arguments","text":"<ul> <li>ffmpeg: ffmpeg executable to check</li> </ul>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.get_ffmpeg_version--returns","title":"Returns","text":"<ul> <li>Tuple of optional version and optional year.</li> </ul>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.get_ffmpeg_version--errors","title":"Errors","text":"<ul> <li>FFmpegError if ffmpeg is not installed.</li> <li>FFmpegError if ffmpeg version is not found.</li> </ul> Source code in <code>spotdl/utils/ffmpeg.py</code> <pre><code>def get_ffmpeg_version(ffmpeg: str = \"ffmpeg\") -&gt; Tuple[Optional[float], Optional[int]]:\n    \"\"\"\n    Get ffmpeg version.\n\n    ### Arguments\n    - ffmpeg: ffmpeg executable to check\n\n    ### Returns\n    - Tuple of optional version and optional year.\n\n    ### Errors\n    - FFmpegError if ffmpeg is not installed.\n    - FFmpegError if ffmpeg version is not found.\n    \"\"\"\n\n    # Check if ffmpeg is installed\n    if not is_ffmpeg_installed(ffmpeg):\n        if ffmpeg == \"ffmpeg\":\n            raise FFmpegError(\"ffmpeg is not installed.\")\n\n        raise FFmpegError(f\"{ffmpeg} is not a valid ffmpeg executable.\")\n\n    with subprocess.Popen(\n        [ffmpeg, \"-version\"],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        encoding=\"utf-8\",\n    ) as process:\n        output = \"\".join(process.communicate())\n\n    # Search for version and build year in output\n    version_result = VERSION_REGEX.search(output)\n    year_result = YEAR_REGEX.search(output)\n\n    build_year = None\n    version = None\n\n    if version_result is not None:\n        # remove all non numeric characters from string example: n4.3\n        version_str = re.sub(r\"[a-zA-Z]\", \"\", version_result.group(0))\n\n        # parse version string to float\n        version = float(version_str) if version_str else None\n\n    if year_result is not None:\n        # get build years from string example: Copyright (c) 2019-2020\n        build_years = [\n            int(\n                re.sub(r\"[^0-9]\", \"\", year)\n            )  # remove all non numeric characters from string\n            for year in year_result.group(0).split(\n                \"-\"\n            )  # split string into list of years\n        ]\n\n        # get the highest build year\n        build_year = max(build_years)\n\n    return (version, build_year)\n</code></pre>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.get_local_ffmpeg","title":"<code>get_local_ffmpeg()</code>","text":"<p>Get local ffmpeg binary path.</p>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.get_local_ffmpeg--returns","title":"Returns","text":"<ul> <li>Path to ffmpeg binary or None if not found.</li> </ul> Source code in <code>spotdl/utils/ffmpeg.py</code> <pre><code>def get_local_ffmpeg() -&gt; Optional[Path]:\n    \"\"\"\n    Get local ffmpeg binary path.\n\n    ### Returns\n    - Path to ffmpeg binary or None if not found.\n    \"\"\"\n\n    ffmpeg_path = Path(get_spotdl_path()) / (\n        \"ffmpeg\" + (\".exe\" if platform.system() == \"Windows\" else \"\")\n    )\n\n    if ffmpeg_path.is_file():\n        return ffmpeg_path\n\n    return None\n</code></pre>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.is_ffmpeg_installed","title":"<code>is_ffmpeg_installed(ffmpeg='ffmpeg')</code>","text":"<p>Check if ffmpeg is installed.</p>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.is_ffmpeg_installed--arguments","title":"Arguments","text":"<ul> <li>ffmpeg: ffmpeg executable to check</li> </ul>"},{"location":"reference/utils/ffmpeg/#spotdl.utils.ffmpeg.is_ffmpeg_installed--returns","title":"Returns","text":"<ul> <li>True if ffmpeg is installed, False otherwise.</li> </ul> Source code in <code>spotdl/utils/ffmpeg.py</code> <pre><code>def is_ffmpeg_installed(ffmpeg: str = \"ffmpeg\") -&gt; bool:\n    \"\"\"\n    Check if ffmpeg is installed.\n\n    ### Arguments\n    - ffmpeg: ffmpeg executable to check\n\n    ### Returns\n    - True if ffmpeg is installed, False otherwise.\n    \"\"\"\n\n    if ffmpeg == \"ffmpeg\":\n        global_ffmpeg = shutil.which(\"ffmpeg\")\n        if global_ffmpeg is None:\n            ffmpeg_path = get_ffmpeg_path()\n        else:\n            ffmpeg_path = Path(global_ffmpeg)\n    else:\n        ffmpeg_path = Path(ffmpeg)\n\n    if ffmpeg_path is None:\n        return False\n\n    # else check if path to ffmpeg is valid\n    # and if ffmpeg has the correct access rights\n    return ffmpeg_path.exists() and os.access(ffmpeg_path, os.X_OK)\n</code></pre>"},{"location":"reference/utils/formatter/","title":"formatter","text":"<p>Module for formatting songs into strings. Contains functions to create search queries and song titles and file names.</p>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.args_to_ytdlp_options","title":"<code>args_to_ytdlp_options(argument_list, defaults=None)</code>","text":"<p>Convert a list of arguments to a dictionary of options.</p>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.args_to_ytdlp_options--arguments","title":"Arguments","text":"<ul> <li>argument_list: the list of arguments</li> <li>defaults: the default options</li> </ul>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.args_to_ytdlp_options--returns","title":"Returns","text":"<ul> <li>the dictionary of options</li> </ul> Source code in <code>spotdl/utils/formatter.py</code> <pre><code>def args_to_ytdlp_options(\n    argument_list: List[str], defaults: Optional[Dict[str, Any]] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Convert a list of arguments to a dictionary of options.\n\n    ### Arguments\n    - argument_list: the list of arguments\n    - defaults: the default options\n\n    ### Returns\n    - the dictionary of options\n    \"\"\"\n\n    parsed_options = parse_options(argument_list).ydl_opts\n\n    if defaults is None:\n        return parsed_options\n\n    default_options = parse_options([]).ydl_opts\n\n    for key, value in defaults.items():\n        if key not in parsed_options:\n            parsed_options[key] = value\n        elif parsed_options[key] == default_options[key]:\n            parsed_options[key] = value\n\n    return parsed_options\n</code></pre>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_file_name","title":"<code>create_file_name(song, template, file_extension, restrict=None, short=False, file_name_length=None)</code>","text":"<p>Create the file name for the song, by replacing template variables with the actual values.</p>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_file_name--arguments","title":"Arguments","text":"<ul> <li>song: the song object</li> <li>template: the template string</li> <li>file_extension: the file extension to use</li> <li>restrict: sanitization to apply to the filename</li> <li>short: whether to use the short version of the template</li> <li>file_name_length: the maximum length of the file name</li> </ul>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_file_name--returns","title":"Returns","text":"<ul> <li>the formatted string as a Path object</li> </ul> Source code in <code>spotdl/utils/formatter.py</code> <pre><code>def create_file_name(\n    song: Song,\n    template: str,\n    file_extension: str,\n    restrict: Optional[str] = None,\n    short: bool = False,\n    file_name_length: Optional[int] = None,\n) -&gt; Path:\n    \"\"\"\n    Create the file name for the song, by replacing template variables with the actual values.\n\n    ### Arguments\n    - song: the song object\n    - template: the template string\n    - file_extension: the file extension to use\n    - restrict: sanitization to apply to the filename\n    - short: whether to use the short version of the template\n    - file_name_length: the maximum length of the file name\n\n    ### Returns\n    - the formatted string as a Path object\n    \"\"\"\n\n    temp_song = copy.deepcopy(song)\n\n    # If template does not contain any of the keys,\n    # append {artists} - {title}.{output-ext} to it\n    if not any(key in template for key in VARS) and template != \"\":\n        template += \"/{artists} - {title}.{output-ext}\"\n\n    if template == \"\":\n        template = \"{artists} - {title}.{output-ext}\"\n\n    # If template ends with a slash. Does not have a file name with extension\n    # at the end of the template, append {artists} - {title}.{output-ext} to it\n    if template.endswith(\"/\") or template.endswith(r\"\\\\\") or template.endswith(\"\\\\\\\\\"):\n        template += \"/{artists} - {title}.{output-ext}\"\n\n    # If template does not end with {output-ext}, append it to the end of the template\n    if not template.endswith(\".{output-ext}\"):\n        template += \".{output-ext}\"\n\n    formatted_string = format_query(\n        song=song,\n        template=template,\n        santitize=True,\n        file_extension=file_extension,\n        short=short,\n    )\n\n    file = create_path_object(formatted_string)\n\n    length_limit = file_name_length or 255\n\n    # Check if the file name length is greater than the limit\n    if len(file.name) &lt; length_limit:\n        # Restrict the filename if needed\n        if restrict and restrict != \"none\":\n            return restrict_filename(file, restrict == \"strict\")\n\n        return file\n\n    if short is False:\n        return create_file_name(\n            song,\n            template,\n            file_extension,\n            restrict=restrict,\n            short=True,\n            file_name_length=length_limit,\n        )\n\n    non_template_chars = re.findall(r\"(?&lt;!{)[^{}]+(?![^{}]*})\", template)\n    half_length = int((length_limit * 0.50) - (len(\"\".join(non_template_chars)) / 2))\n\n    # Path template is already short, but we still can't create a file\n    # so we reduce it even further\n    is_long_artist = len(temp_song.artist) &gt; half_length\n    is_long_title = len(temp_song.name) &gt; half_length\n\n    path_separator = \"/\" if \"/\" in template else \"\\\\\"\n    name_template_parts = template.rsplit(path_separator, 1)\n    name_template = (\n        name_template_parts[1]\n        if len(name_template_parts) &gt; 1\n        else name_template_parts[0]\n    )\n\n    if is_long_artist:\n        logger.warning(\n            \"%s: Song artist is too long. Using only part of song artist.\",\n            temp_song.display_name,\n        )\n\n        temp_song.artist = smart_split(temp_song.artist, half_length, None)\n        temp_song.artists = [temp_song.artist]\n\n    if is_long_title:\n        logger.warning(\n            \"%s: File name is too long. Using only part of the song title.\",\n            temp_song.display_name,\n        )\n\n        temp_song.name = smart_split(temp_song.name, half_length, None)\n\n    new_file = create_path_object(\n        format_query(\n            song=temp_song,\n            template=name_template,\n            santitize=True,\n            file_extension=file_extension,\n            short=short,\n        )\n    )\n\n    if len(new_file.name) &gt; length_limit:\n        logger.warning(\n            \"File name is still too long. \"\n            \"Using default file name with shortened artist and title.\"\n        )\n\n        if template == \"{artist} - {title}.{output-ext}\":\n            raise ValueError(\n                \"File name is still too long, \"\n                \"but the template is already short. \"\n                \"Please try other template, \"\n                \"increase the file name length limit.\"\n            )\n\n        return create_file_name(\n            temp_song,\n            \"{artist} - {title}.{output-ext}\",\n            file_extension,\n            restrict=restrict,\n            short=True,\n            file_name_length=length_limit,\n        )\n\n    return new_file\n</code></pre>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_path_object","title":"<code>create_path_object(string)</code>","text":"<p>Create a Path object from a string. Sanitizes the filename part of the Path object.</p>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_path_object--arguments","title":"Arguments","text":"<ul> <li>string: the string to convert</li> </ul>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_path_object--returns","title":"Returns","text":"<ul> <li>the Path object</li> </ul> Source code in <code>spotdl/utils/formatter.py</code> <pre><code>def create_path_object(string: str) -&gt; Path:\n    \"\"\"\n    Create a Path object from a string.\n    Sanitizes the filename part of the Path object.\n\n    ### Arguments\n    - string: the string to convert\n\n    ### Returns\n    - the Path object\n    \"\"\"\n\n    # Parse template as Path object\n    file = Path(string)\n\n    santitized_parts = []\n    for part in file.parts:\n        match = re.search(r\"[^\\.*](.*)[^\\.*$]\", part)\n        if match and part != \".spotdl\":\n            santitized_parts.append(match.group(0))\n        else:\n            santitized_parts.append(part)\n\n    # Join the parts of the path\n    return Path(*santitized_parts)\n</code></pre>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_search_query","title":"<code>create_search_query(song, template, santitize, file_extension=None, short=False)</code>","text":"<p>Create the search query for the song.</p>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_search_query--arguments","title":"Arguments","text":"<ul> <li>song: the song object</li> <li>template: the template string</li> <li>santitize: whether to sanitize the string</li> <li>file_extension: the file extension to use</li> <li>short: whether to use the short version of the template</li> </ul>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_search_query--returns","title":"Returns","text":"<ul> <li>the formatted string</li> </ul> Source code in <code>spotdl/utils/formatter.py</code> <pre><code>def create_search_query(\n    song: Song,\n    template: str,\n    santitize: bool,\n    file_extension: Optional[str] = None,\n    short: bool = False,\n) -&gt; str:\n    \"\"\"\n    Create the search query for the song.\n\n    ### Arguments\n    - song: the song object\n    - template: the template string\n    - santitize: whether to sanitize the string\n    - file_extension: the file extension to use\n    - short: whether to use the short version of the template\n\n    ### Returns\n    - the formatted string\n    \"\"\"\n\n    # If template does not contain any of the keys,\n    # append {artist} - {title} at the beginning of the template\n    if not any(key in template for key in VARS):\n        template = \"{artist} - {title}\" + template\n\n    return format_query(song, template, santitize, file_extension, short=short)\n</code></pre>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_song_title","title":"<code>create_song_title(song_name, song_artists)</code>","text":"<p>Create the song title.</p>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_song_title--arguments","title":"Arguments","text":"<ul> <li>song_name: the name of the song</li> <li>song_artists: the list of artists of the song</li> </ul>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_song_title--returns","title":"Returns","text":"<ul> <li>the song title</li> </ul>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.create_song_title--notes","title":"Notes","text":"<ul> <li>Example: \"Artist1, Artist2 - Song Name\"</li> </ul> Source code in <code>spotdl/utils/formatter.py</code> <pre><code>def create_song_title(song_name: str, song_artists: List[str]) -&gt; str:\n    \"\"\"\n    Create the song title.\n\n    ### Arguments\n    - song_name: the name of the song\n    - song_artists: the list of artists of the song\n\n    ### Returns\n    - the song title\n\n    ### Notes\n    - Example: \"Artist1, Artist2 - Song Name\"\n\n    \"\"\"\n\n    joined_artists = \", \".join(song_artists)\n    if len(song_artists) &gt;= 1:\n        return f\"{joined_artists} - {song_name}\"\n\n    return song_name\n</code></pre>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.format_query","title":"<code>format_query(song, template, santitize, file_extension=None, short=False)</code>","text":"<p>Replace template variables with the actual values.</p>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.format_query--arguments","title":"Arguments","text":"<ul> <li>song: the song object</li> <li>template: the template string</li> <li>santitize: whether to sanitize the string</li> <li>file_extension: the file extension to use</li> <li>short: whether to use the short version of the template</li> </ul>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.format_query--returns","title":"Returns","text":"<ul> <li>the formatted string</li> </ul> Source code in <code>spotdl/utils/formatter.py</code> <pre><code>def format_query(\n    song: Song,\n    template: str,\n    santitize: bool,\n    file_extension: Optional[str] = None,\n    short: bool = False,\n) -&gt; str:\n    \"\"\"\n    Replace template variables with the actual values.\n\n    ### Arguments\n    - song: the song object\n    - template: the template string\n    - santitize: whether to sanitize the string\n    - file_extension: the file extension to use\n    - short: whether to use the short version of the template\n\n    ### Returns\n    - the formatted string\n    \"\"\"\n\n    if \"{output-ext}\" in template and file_extension is None:\n        raise ValueError(\"file_extension is None, but template contains {output-ext}\")\n\n    for key, val in [\n        (\"{list-length}\", song.list_length),\n        (\"{list-position}\", song.list_position),\n        (\"{list-name}\", song.list_name),\n    ]:\n        if not (key in template and val is None):\n            continue\n\n        logger.warning(\n            \"Template contains %s, but it's value is None. Replacing with empty string.\",\n            key,\n        )\n\n        template = template.replace(key, \"\")\n        template = template.replace(r\"//\", r\"/\")\n\n    # If template has only {output-ext}, fix it\n    if template in [\"/.{output-ext}\", \".{output-ext}\"]:\n        template = \"{artists} - {title}.{output-ext}\"\n\n    # Remove artists from the list that are already in the title\n    if short:\n        artists = [\n            artist\n            for artist in song.artists\n            if slugify(artist) not in slugify(song.name)\n        ]\n\n        # Add the main artist again to the list\n        if len(artists) == 0 or artists[0] != song.artists[0]:\n            artists.insert(0, song.artists[0])\n    else:\n        artists = song.artists\n\n    artists_str = \", \".join(artists)\n\n    # the code below is valid, song_list is actually checked for None\n    formats = {\n        \"{title}\": song.name,\n        \"{artists}\": song.artists[0] if short is True else artists_str,\n        \"{artist}\": song.artists[0],\n        \"{album}\": song.album_name,\n        \"{album-artist}\": song.album_artist,\n        \"{genre}\": song.genres[0] if song.genres else \"\",\n        \"{disc-number}\": song.disc_number,\n        \"{disc-count}\": song.disc_count,\n        \"{duration}\": song.duration,\n        \"{year}\": song.year,\n        \"{original-date}\": song.date,\n        \"{track-number}\": f\"{int(song.track_number):02d}\" if song.track_number else \"\",\n        \"{tracks-count}\": song.tracks_count,\n        \"{isrc}\": song.isrc,\n        \"{track-id}\": song.song_id,\n        \"{publisher}\": song.publisher,\n        \"{output-ext}\": file_extension,\n        \"{list-name}\": song.list_name,\n        \"{list-position}\": str(song.list_position).zfill(len(str(song.list_length))),\n        \"{list-length}\": song.list_length,\n    }\n\n    if santitize:\n        # sanitize the values in formats dict\n        for key, value in formats.items():\n            if value is None:\n                continue\n\n            formats[key] = sanitize_string(str(value))\n\n    # Replace all the keys with the values\n    for key, value in formats.items():\n        template = template.replace(key, str(value))\n\n    return template\n</code></pre>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.parse_duration","title":"<code>parse_duration(duration)</code>","text":"<p>Convert string value of time (duration: \"25:36:59\") to a float value of seconds (92219.0)</p>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.parse_duration--arguments","title":"Arguments","text":"<ul> <li>duration: the string value of time</li> </ul>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.parse_duration--returns","title":"Returns","text":"<ul> <li>the float value of seconds</li> </ul> Source code in <code>spotdl/utils/formatter.py</code> <pre><code>def parse_duration(duration: Optional[str]) -&gt; float:\n    \"\"\"\n    Convert string value of time (duration: \"25:36:59\") to a float value of seconds (92219.0)\n\n    ### Arguments\n    - duration: the string value of time\n\n    ### Returns\n    - the float value of seconds\n    \"\"\"\n\n    if duration is None:\n        return 0.0\n\n    try:\n        # {(1, \"s\"), (60, \"m\"), (3600, \"h\")}\n        mapped_increments = zip([1, 60, 3600], reversed(duration.split(\":\")))\n        seconds = sum(multiplier * int(time) for multiplier, time in mapped_increments)\n        return float(seconds)\n\n    # This usually occurs when the wrong string is mistaken for the duration\n    except (ValueError, TypeError, AttributeError):\n        return 0.0\n</code></pre>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.ratio","title":"<code>ratio(string1, string2)</code>  <code>cached</code>","text":"<p>Wrapper for fuzz.ratio with lru_cache</p>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.ratio--arguments","title":"Arguments","text":"<ul> <li>string1: the first string</li> <li>string2: the second string</li> </ul>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.ratio--returns","title":"Returns","text":"<ul> <li>the ratio</li> </ul> Source code in <code>spotdl/utils/formatter.py</code> <pre><code>@lru_cache()\ndef ratio(string1: str, string2: str) -&gt; float:\n    \"\"\"\n    Wrapper for fuzz.ratio\n    with lru_cache\n\n    ### Arguments\n    - string1: the first string\n    - string2: the second string\n\n    ### Returns\n    - the ratio\n    \"\"\"\n\n    return fuzz.ratio(string1, string2)\n</code></pre>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.restrict_filename","title":"<code>restrict_filename(pathobj, strict=True)</code>","text":"<p>Sanitizes the filename part of a Path object. Returns modified object.</p>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.restrict_filename--arguments","title":"Arguments","text":"<ul> <li>pathobj: the Path object to sanitize</li> <li>strict: whether sanitization should be strict</li> </ul>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.restrict_filename--returns","title":"Returns","text":"<ul> <li>the modified Path object</li> </ul>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.restrict_filename--notes","title":"Notes","text":"<ul> <li>Based on the <code>sanitize_filename</code> function from yt-dlp</li> </ul> Source code in <code>spotdl/utils/formatter.py</code> <pre><code>def restrict_filename(pathobj: Path, strict: bool = True) -&gt; Path:\n    \"\"\"\n    Sanitizes the filename part of a Path object. Returns modified object.\n\n    ### Arguments\n    - pathobj: the Path object to sanitize\n    - strict: whether sanitization should be strict\n\n    ### Returns\n    - the modified Path object\n\n    ### Notes\n    - Based on the `sanitize_filename` function from yt-dlp\n    \"\"\"\n    if strict:\n        result = sanitize_filename(pathobj.name, True, False)  # type: ignore\n        result = result.replace(\"_-_\", \"-\")\n    else:\n        result = (\n            normalize(\"NFKD\", pathobj.name).encode(\"ascii\", \"ignore\").decode(\"utf-8\")\n        )\n\n    if not result:\n        result = \"_\"\n\n    return pathobj.with_name(result)\n</code></pre>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.sanitize_string","title":"<code>sanitize_string(string)</code>","text":"<p>Sanitize the filename to be used in the file system.</p>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.sanitize_string--arguments","title":"Arguments","text":"<ul> <li>string: the string to sanitize</li> </ul>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.sanitize_string--returns","title":"Returns","text":"<ul> <li>the sanitized string</li> </ul> Source code in <code>spotdl/utils/formatter.py</code> <pre><code>def sanitize_string(string: str) -&gt; str:\n    \"\"\"\n    Sanitize the filename to be used in the file system.\n\n    ### Arguments\n    - string: the string to sanitize\n\n    ### Returns\n    - the sanitized string\n    \"\"\"\n\n    output = string\n\n    # this is windows specific (disallowed chars)\n    output = \"\".join(char for char in output if char not in \"/?\\\\*|&lt;&gt;\")\n\n    # double quotes (\") and semi-colons (:) are also disallowed characters but we would\n    # like to retain their equivalents, so they aren't removed in the prior loop\n    output = output.replace('\"', \"'\").replace(\":\", \"-\")\n\n    return output\n</code></pre>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.slugify","title":"<code>slugify(string)</code>  <code>cached</code>","text":"<p>Slugify the string.</p>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.slugify--arguments","title":"Arguments","text":"<ul> <li>string: the string to slugify</li> </ul>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.slugify--returns","title":"Returns","text":"<ul> <li>the slugified string</li> </ul> Source code in <code>spotdl/utils/formatter.py</code> <pre><code>@lru_cache()\ndef slugify(string: str) -&gt; str:\n    \"\"\"\n    Slugify the string.\n\n    ### Arguments\n    - string: the string to slugify\n\n    ### Returns\n    - the slugified string\n    \"\"\"\n\n    # Replace ambiguous characters\n    if not JAP_REGEX.search(string):\n        # If string doesn't have japanese characters\n        # return early\n        return py_slugify(string, regex_pattern=DISALLOWED_REGEX.pattern)\n\n    # Workaround for japanese characters\n    # because slugify incorrectly converts them\n    # to latin characters\n    normal_slug = py_slugify(\n        string,\n        regex_pattern=JAP_REGEX.pattern,\n    )\n\n    results = KKS.convert(normal_slug)\n\n    result = \"\"\n    for index, item in enumerate(results):\n        result += item[\"hepburn\"]\n        if not (\n            item[\"kana\"] == item[\"hepburn\"]\n            or item[\"kana\"] == item[\"hepburn\"]\n            or (\n                item == results[-1]\n                or results[index + 1][\"kana\"] == results[index + 1][\"hepburn\"]\n            )\n        ):\n            result += \"-\"\n\n    return py_slugify(result, regex_pattern=DISALLOWED_REGEX.pattern)\n</code></pre>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.smart_split","title":"<code>smart_split(string, max_length, separators=None)</code>","text":"<p>Split a string into a list of strings with a maximum length of max_length. Stops at the first separator that produces a string with a length less than max_length.</p>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.smart_split--arguments","title":"Arguments","text":"<ul> <li>string: the string to split</li> <li>max_length: the maximum length of string</li> <li>separators: the separators to split the string with</li> </ul>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.smart_split--returns","title":"Returns","text":"<ul> <li>the new string</li> </ul> Source code in <code>spotdl/utils/formatter.py</code> <pre><code>def smart_split(\n    string: str, max_length: int, separators: Optional[List[str]] = None\n) -&gt; str:\n    \"\"\"\n    Split a string into a list of strings\n    with a maximum length of max_length.\n    Stops at the first separator that produces a string\n    with a length less than max_length.\n\n    ### Arguments\n    - string: the string to split\n    - max_length: the maximum length of string\n    - separators: the separators to split the string with\n\n    ### Returns\n    - the new string\n    \"\"\"\n\n    if separators is None:\n        separators = [\"-\", \",\", \" \", \"\"]\n\n    for separator in separators:\n        parts = string.split(separator if separator != \"\" else None)\n        new_string = separator.join(parts[:1])\n        for part in parts[1:]:\n            if len(new_string) + len(separator) + len(part) &gt; max_length:\n                break\n            new_string += separator + part\n\n        if len(new_string) &lt;= max_length:\n            return new_string\n\n    return string[:max_length]\n</code></pre>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.to_ms","title":"<code>to_ms(string=None, precision=None, **kwargs)</code>","text":"<p>Convert a string to milliseconds.</p>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.to_ms--arguments","title":"Arguments","text":"<ul> <li>string: the string to convert</li> <li>precision: the number of decimals to round to</li> <li>kwargs: the keyword args to convert</li> </ul>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.to_ms--returns","title":"Returns","text":"<ul> <li>the milliseconds</li> </ul>"},{"location":"reference/utils/formatter/#spotdl.utils.formatter.to_ms--notes","title":"Notes","text":"<ul> <li>You can either pass a string,</li> <li>or a set of keyword args (\"hour\", \"min\", \"sec\", \"ms\") to convert.</li> <li>If \"precision\" is set, the result is rounded to the number of decimals given.</li> <li>From: https://gist.github.com/Hellowlol/5f8545e999259b4371c91ac223409209</li> </ul> Source code in <code>spotdl/utils/formatter.py</code> <pre><code>def to_ms(\n    string: Optional[str] = None, precision: Optional[int] = None, **kwargs\n) -&gt; float:\n    \"\"\"\n    Convert a string to milliseconds.\n\n    ### Arguments\n    - string: the string to convert\n    - precision: the number of decimals to round to\n    - kwargs: the keyword args to convert\n\n    ### Returns\n    - the milliseconds\n\n    ### Notes\n    - You can either pass a string,\n    - or a set of keyword args (\"hour\", \"min\", \"sec\", \"ms\") to convert.\n    - If \"precision\" is set, the result is rounded to the number of decimals given.\n    - From: https://gist.github.com/Hellowlol/5f8545e999259b4371c91ac223409209\n    \"\"\"\n\n    if string:\n        hour = int(string[0:2])\n        minute = int(string[3:5])\n        sec = int(string[6:8])\n        milliseconds = int(string[10:11])\n    else:\n        hour = int(kwargs.get(\"hour\", 0))\n        minute = int(kwargs.get(\"min\", 0))\n        sec = int(kwargs.get(\"sec\", 0))\n        milliseconds = int(kwargs.get(\"ms\", 0))\n\n    result = (\n        (hour * 60 * 60 * 1000) + (minute * 60 * 1000) + (sec * 1000) + milliseconds\n    )\n\n    if precision and isinstance(precision, int):\n        return round(result, precision)\n\n    return result\n</code></pre>"},{"location":"reference/utils/github/","title":"github","text":"<p>Module for getting information about the current version of spotdl from GitHub, downloading the latest version, and checking for updates.</p>"},{"location":"reference/utils/github/#spotdl.utils.github.RateLimitError","title":"<code>RateLimitError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when the GitHub API rate limit is exceeded.</p>"},{"location":"reference/utils/github/#spotdl.utils.github.check_for_updates","title":"<code>check_for_updates(repo=REPO)</code>","text":"<p>Check for updates to the current version.</p>"},{"location":"reference/utils/github/#spotdl.utils.github.check_for_updates--arguments","title":"Arguments","text":"<ul> <li>repo: the repo to check (defaults to spotdl/spotify-downloader)</li> </ul>"},{"location":"reference/utils/github/#spotdl.utils.github.check_for_updates--returns","title":"Returns","text":"<ul> <li>the latest version</li> </ul> Source code in <code>spotdl/utils/github.py</code> <pre><code>def check_for_updates(repo: str = REPO) -&gt; str:\n    \"\"\"\n    Check for updates to the current version.\n\n    ### Arguments\n    - repo: the repo to check (defaults to spotdl/spotify-downloader)\n\n    ### Returns\n    - the latest version\n    \"\"\"\n\n    message = \"\"\n\n    latest_version = get_latest_version(repo)\n    current_version = f\"v{_version.__version__}\"  # returns \"vx.x.x\"\n\n    if latest_version != current_version:\n        message = f\"New version available: {latest_version}.\\n\\n\"\n    else:\n        message = \"No updates available.\\n\\n\"\n    try:\n        master = get_status(current_version, \"master\")\n        dev = get_status(current_version, \"dev\")\n    except RuntimeError:\n        message = \"Couldn't check for updates. You might be running a dev version.\\n\"\n        message += \"Current version: \" + current_version + \"\\n\"\n        message += \"Latest version: \" + latest_version\n        return message\n    except RateLimitError:\n        message = \"GitHub API rate limit exceeded. Couldn't check for updates.\\n\"\n        message += \"Current version: \" + current_version + \"\\n\"\n        message += \"Latest version: \" + latest_version + \"\\n\"\n        message += \"Please try again later.\"\n        return message\n\n    for branch in [\"master\", \"dev\"]:\n        name = branch.capitalize()\n        if branch == \"master\":\n            status, ahead_by, behind_by = master\n        else:\n            status, ahead_by, behind_by = dev\n\n        if status == \"behind\":\n            message += f\"{name} is {status} by {behind_by} commits.\\n\"\n        elif status == \"ahead\":\n            message += f\"{name} is {status} by {ahead_by} commits.\\n\"\n        else:\n            message += f\"{name} is up to date.\\n\"\n\n    return message\n</code></pre>"},{"location":"reference/utils/github/#spotdl.utils.github.create_github_url","title":"<code>create_github_url(url=WEB_APP_URL)</code>","text":"<p>From the given url, produce a URL that is compatible with Github's REST API.</p>"},{"location":"reference/utils/github/#spotdl.utils.github.create_github_url--arguments","title":"Arguments","text":"<ul> <li>url: the url to convert</li> </ul>"},{"location":"reference/utils/github/#spotdl.utils.github.create_github_url--notes","title":"Notes","text":"<ul> <li>Can handle blob or tree paths.</li> </ul> Source code in <code>spotdl/utils/github.py</code> <pre><code>def create_github_url(url: str = WEB_APP_URL):\n    \"\"\"\n    From the given url, produce a URL that is compatible with Github's REST API.\n\n    ### Arguments\n    - url: the url to convert\n\n    ### Notes\n    - Can handle blob or tree paths.\n    \"\"\"\n\n    repo_only_url = re.compile(\n        r\"https:\\/\\/github\\.com\\/[a-z\\d](?:[a-z\\d]|-(?=[a-z\\d])){0,38}\\/[a-zA-Z0-9]+$\"\n    )\n    re_branch = re.compile(\"/(tree|blob)/(.+?)/\")\n\n    # Check if the given url is a url to a GitHub repo. If it is, tell the\n    # user to use 'git clone' to download it\n    if re.match(repo_only_url, url):\n        raise ValueError(\n            \"The given URL is a GitHub repo. Please use 'git clone' to download it.\"\n        )\n\n    # extract the branch name from the given url (e.g master)\n    branch = re_branch.search(url)\n    if branch:\n        download_dirs = url[branch.end() :]\n        api_url = (\n            url[: branch.start()].replace(\"github.com\", \"api.github.com/repos\", 1)\n            + \"/contents/\"\n            + download_dirs\n            + \"?ref=\"\n            + branch.group(2)\n        )\n        return api_url\n\n    raise ValueError(\"The given url is not a valid GitHub url\")\n</code></pre>"},{"location":"reference/utils/github/#spotdl.utils.github.download_github_dir","title":"<code>download_github_dir(repo_url=WEB_APP_URL, flatten=False, output_dir='./')</code>","text":"<p>Downloads the files and directories in repo_url.</p>"},{"location":"reference/utils/github/#spotdl.utils.github.download_github_dir--arguments","title":"Arguments","text":"<ul> <li>repo_url: the url to the repo to download</li> <li>flatten: whether to flatten the directory structure</li> <li>output_dir: the directory to download the files to</li> </ul>"},{"location":"reference/utils/github/#spotdl.utils.github.download_github_dir--notes","title":"Notes","text":"<ul> <li>Modification of https://github.com/sdushantha/gitdir/blob/master/gitdir/gitdir.py</li> </ul> Source code in <code>spotdl/utils/github.py</code> <pre><code>def download_github_dir(\n    repo_url: str = WEB_APP_URL, flatten: bool = False, output_dir: str = \"./\"\n):\n    \"\"\"\n    Downloads the files and directories in repo_url.\n\n    ### Arguments\n    - repo_url: the url to the repo to download\n    - flatten: whether to flatten the directory structure\n    - output_dir: the directory to download the files to\n\n    ### Notes\n    - Modification of https://github.com/sdushantha/gitdir/blob/master/gitdir/gitdir.py\n    \"\"\"\n\n    # generate the url which returns the JSON data\n    api_url = create_github_url(repo_url)\n\n    dir_out = output_dir\n\n    response = requests.get(api_url, timeout=10).json()\n\n    if (\n        isinstance(response, dict)\n        and \"message\" in response.keys()\n        and \"rate limit\" in response[\"message\"]\n    ):\n        logging.error(\n            \"You have been rate limited by Github API attempting to update web client.\"\n            \"Proceeding with cached web client. Please try again later.\"\n            \"See https://docs.github.com/en/rest/overview/resources-in-the-rest-api#rate-limiting\"\n        )\n        return None\n\n    if not flatten:\n        # make a directory with the name which is taken from\n        # the actual repo\n        os.makedirs(dir_out, exist_ok=True)\n\n    if isinstance(response, dict) and response[\"type\"] == \"file\":\n        response = [response]\n\n    for file in response:\n        file_url = file[\"download_url\"]\n\n        if flatten:\n            path = os.path.join(dir_out, os.path.basename(file[\"path\"]))\n        else:\n            path = os.path.join(dir_out, file[\"path\"])\n\n        dirname = os.path.dirname(path)\n\n        if dirname != \"\":\n            os.makedirs(dirname, exist_ok=True)\n\n        if file_url is not None:\n            with open(path, \"wb\") as new_file:\n                new_file.write(requests.get(file_url, timeout=10).content)\n        else:\n            download_github_dir(file[\"html_url\"], flatten, output_dir)\n\n    return None\n</code></pre>"},{"location":"reference/utils/github/#spotdl.utils.github.get_latest_version","title":"<code>get_latest_version(repo=REPO)</code>","text":"<p>Get the latest version of spotdl.</p>"},{"location":"reference/utils/github/#spotdl.utils.github.get_latest_version--arguments","title":"Arguments","text":"<ul> <li>repo: the repo to check (defaults to spotdl/spotify-downloader)</li> </ul>"},{"location":"reference/utils/github/#spotdl.utils.github.get_latest_version--returns","title":"Returns","text":"<ul> <li>the latest version</li> </ul> Source code in <code>spotdl/utils/github.py</code> <pre><code>def get_latest_version(repo: str = REPO) -&gt; str:\n    \"\"\"\n    Get the latest version of spotdl.\n\n    ### Arguments\n    - repo: the repo to check (defaults to spotdl/spotify-downloader)\n\n    ### Returns\n    - the latest version\n    \"\"\"\n\n    url = f\"https://api.github.com/repos/{repo}/releases/latest\"\n\n    response = requests.get(url, timeout=10)\n\n    if response.status_code != 200:\n        if response.status_code == 403:\n            raise RateLimitError(\"GitHub API rate limit exceeded.\")\n\n        raise RuntimeError(\n            f\"Failed to get commit count. Status code: {response.status_code}\"\n        )\n\n    data = response.json()\n\n    return data[\"name\"]  # returns \"vx.x.x\"\n</code></pre>"},{"location":"reference/utils/github/#spotdl.utils.github.get_status","title":"<code>get_status(start, end, repo=REPO)</code>","text":"<p>Get the status of a commit range.</p>"},{"location":"reference/utils/github/#spotdl.utils.github.get_status--arguments","title":"Arguments","text":"<ul> <li>start: the starting commit/branch/tag</li> <li>end: the ending commit/branch/tag</li> <li>repo: the repo to check (defaults to spotdl/spotify-downloader)</li> </ul>"},{"location":"reference/utils/github/#spotdl.utils.github.get_status--returns","title":"Returns","text":"<ul> <li>tuple of (status, ahead_by, behind_by)</li> </ul> Source code in <code>spotdl/utils/github.py</code> <pre><code>def get_status(start: str, end: str, repo: str = REPO) -&gt; Tuple[str, int, int]:\n    \"\"\"\n    Get the status of a commit range.\n\n    ### Arguments\n    - start: the starting commit/branch/tag\n    - end: the ending commit/branch/tag\n    - repo: the repo to check (defaults to spotdl/spotify-downloader)\n\n    ### Returns\n    - tuple of (status, ahead_by, behind_by)\n    \"\"\"\n\n    url = f\"https://api.github.com/repos/{repo}/compare/{start}...{end}\"\n\n    response = requests.get(url, timeout=10)\n\n    if response.status_code != 200:\n        if response.status_code == 403:\n            raise RateLimitError(\"GitHub API rate limit exceeded.\")\n\n        raise RuntimeError(\n            f\"Failed to get commit count. Status code: {response.status_code}\"\n        )\n\n    data = response.json()\n\n    return (\n        data[\"status\"],\n        data[\"ahead_by\"],\n        data[\"behind_by\"],\n    )\n</code></pre>"},{"location":"reference/utils/logging/","title":"logging","text":"<p>Module for logging</p>"},{"location":"reference/utils/logging/#spotdl.utils.logging.SpotdlFormatter","title":"<code>SpotdlFormatter</code>","text":"<p>               Bases: <code>Formatter</code></p> <p>A custom logger for spotdl.</p>"},{"location":"reference/utils/logging/#spotdl.utils.logging.SpotdlFormatter.format","title":"<code>format(record)</code>","text":"<p>Format a log record.</p> Source code in <code>spotdl/utils/logging.py</code> <pre><code>def format(self, record: logging.LogRecord) -&gt; str:\n    \"\"\"\n    Format a log record.\n    \"\"\"\n\n    result = escape(super().format(record))\n\n    msg = result\n    if record.levelno == DEBUG:\n        msg = f\"[blue]{result}\"\n\n    if record.levelno == MATCH:\n        msg = f\"[magenta]{result}\"\n\n    if record.levelno == INFO:\n        msg = f\"[green]{result}\"\n\n    if record.levelno == WARNING:\n        msg = f\"[yellow]{result}\"\n\n    if record.levelno == ERROR:\n        msg = f\"[red]{result}\"\n\n    if record.levelno == CRITICAL:\n        msg = f\"[bold red]{result}\"\n\n    return msg\n</code></pre>"},{"location":"reference/utils/logging/#spotdl.utils.logging.SpotdlHandler","title":"<code>SpotdlHandler</code>","text":"<p>               Bases: <code>RichHandler</code></p> <p>A custom logging handler for spotdl. In this case, it's just a wrapper around the rich handler. To not highlight keywords in info messages</p>"},{"location":"reference/utils/logging/#spotdl.utils.logging.SpotdlHandler.render_message","title":"<code>render_message(record, message)</code>","text":"<p>Render message text in to Text.</p>"},{"location":"reference/utils/logging/#spotdl.utils.logging.SpotdlHandler.render_message--arguments","title":"Arguments","text":"<ul> <li>record: logging Record.</li> <li>message: String containing log message.</li> </ul>"},{"location":"reference/utils/logging/#spotdl.utils.logging.SpotdlHandler.render_message--returns","title":"Returns","text":"<ul> <li>ConsoleRenderable: Renderable to display log message.</li> </ul> Source code in <code>spotdl/utils/logging.py</code> <pre><code>def render_message(\n    self, record: logging.LogRecord, message: str\n) -&gt; \"ConsoleRenderable\":\n    \"\"\"Render message text in to Text.\n\n    ### Arguments\n    - record: logging Record.\n    - message: String containing log message.\n\n    ### Returns\n    - ConsoleRenderable: Renderable to display log message.\n    \"\"\"\n\n    use_markup = getattr(record, \"markup\", self.markup)\n    message_text = Text.from_markup(message) if use_markup else Text(message)\n\n    highlighter = getattr(record, \"highlighter\", self.highlighter)\n\n    # Don't highlight info messages\n    if highlighter and record.levelno != INFO:\n        message_text = highlighter(message_text)\n\n    if not hasattr(self, \"keywords\"):\n        self.keywords = self.KEYWORDS\n\n    # Don't highlight keywords in info messages\n    if self.keywords and record.levelno != INFO:\n        message_text.highlight_words(self.keywords, \"logging.keyword\")\n\n    return message_text\n</code></pre>"},{"location":"reference/utils/logging/#spotdl.utils.logging.init_logging","title":"<code>init_logging(log_level, log_format=None)</code>","text":"<p>Initialize logging for spotdl.</p>"},{"location":"reference/utils/logging/#spotdl.utils.logging.init_logging--arguments","title":"Arguments","text":"<ul> <li><code>console</code>: The console to use.</li> <li><code>log_level</code>: The log level to use.</li> </ul> Source code in <code>spotdl/utils/logging.py</code> <pre><code>def init_logging(log_level: str, log_format: Optional[str] = None):\n    \"\"\"\n    Initialize logging for spotdl.\n\n    ### Arguments\n    - `console`: The console to use.\n    - `log_level`: The log level to use.\n    \"\"\"\n\n    # Don't log too much\n    logging.getLogger(\"requests\").setLevel(logging.WARNING)\n    logging.getLogger(\"urllib3\").setLevel(logging.WARNING)\n    logging.getLogger(\"spotipy\").setLevel(logging.WARNING)\n    logging.getLogger(\"asyncio\").setLevel(logging.WARNING)\n    logging.getLogger(\"syncedlyrics\").setLevel(logging.WARNING)\n    logging.getLogger(\"bandcamp_api\").setLevel(logging.WARNING)\n    logging.getLogger(\"beautifulsoup4\").setLevel(logging.WARNING)\n    logging.getLogger(\"pytube\").setLevel(logging.ERROR)\n\n    # Create console\n    console = get_console()\n    console.push_theme(THEME)\n\n    # Add matching level loggers\n    logging.addLevelName(MATCH, \"MATCH\")\n\n    # Create a rich handler\n    rich_handler = SpotdlHandler(\n        show_time=log_level == \"DEBUG\",\n        log_time_format=\"[%X]\",\n        omit_repeated_times=False,\n        console=console,\n        level=log_level,\n        markup=True,\n        show_path=log_level == \"DEBUG\",\n        show_level=log_level == \"DEBUG\",\n        rich_tracebacks=True,\n    )\n\n    msg_format = \"%(message)s\"\n    if log_format is None:\n        if log_level == \"DEBUG\":\n            msg_format = \"%(threadName)s - %(message)s\"\n    else:\n        msg_format = log_format\n\n    # Add rich handler to spotdl logger\n    rich_handler.setFormatter(SpotdlFormatter(msg_format))\n\n    # Create spotdl logger\n    spotdl_logger = logging.getLogger(\"spotdl\")\n\n    # Setup spotdl logger\n    spotdl_logger.setLevel(log_level)\n    spotdl_logger.addHandler(rich_handler)\n\n    # Install rich traceback handler\n    install(show_locals=False, extra_lines=1, console=console)\n</code></pre>"},{"location":"reference/utils/lrc/","title":"lrc","text":"<p>LRC related functions</p>"},{"location":"reference/utils/lrc/#spotdl.utils.lrc.generate_lrc","title":"<code>generate_lrc(song, output_file)</code>","text":"<p>Generates an LRC file for the current song</p>"},{"location":"reference/utils/lrc/#spotdl.utils.lrc.generate_lrc--arguments","title":"Arguments","text":"<ul> <li>song: Song object</li> <li>output_file: Path to the output file</li> </ul> Source code in <code>spotdl/utils/lrc.py</code> <pre><code>def generate_lrc(song: Song, output_file: Path):\n    \"\"\"\n    Generates an LRC file for the current song\n\n    ### Arguments\n    - song: Song object\n    - output_file: Path to the output file\n    \"\"\"\n\n    if song.lyrics and has_translation(song.lyrics):\n        lrc_data = song.lyrics\n    else:\n        try:\n            lrc_data = syncedlyrics_search(song.display_name)\n        except Exception:\n            lrc_data = None\n\n    if lrc_data:\n        Lyrics(lrc_data).save_lrc_file(\n            str(output_file.with_suffix(\".lrc\")), TargetType.PREFER_SYNCED\n        )\n        logger.debug(\"Saved lrc file for %s\", song.display_name)\n    else:\n        logger.debug(\"No lrc file found for %s\", song.display_name)\n</code></pre>"},{"location":"reference/utils/lrc/#spotdl.utils.lrc.remomve_lrc","title":"<code>remomve_lrc(lyrics)</code>","text":"<p>Removes lrc tags from lyrics</p>"},{"location":"reference/utils/lrc/#spotdl.utils.lrc.remomve_lrc--arguments","title":"Arguments","text":"<ul> <li>lyrics: Lyrics string</li> </ul>"},{"location":"reference/utils/lrc/#spotdl.utils.lrc.remomve_lrc--returns","title":"Returns","text":"<ul> <li>Lyrics string without lrc tags</li> </ul> Source code in <code>spotdl/utils/lrc.py</code> <pre><code>def remomve_lrc(lyrics: str) -&gt; str:\n    \"\"\"\n    Removes lrc tags from lyrics\n\n    ### Arguments\n    - lyrics: Lyrics string\n\n    ### Returns\n    - Lyrics string without lrc tags\n    \"\"\"\n\n    return re.sub(r\"\\[.*?\\]\", \"\", lyrics)\n</code></pre>"},{"location":"reference/utils/m3u/","title":"m3u","text":"<p>Module for creating m3u content and writing it to a file.</p>"},{"location":"reference/utils/m3u/#spotdl.utils.m3u.create_m3u_content","title":"<code>create_m3u_content(song_list, template, file_extension, restrict=None, short=False, detect_formats=None)</code>","text":"<p>Create m3u content and return it as a string.</p>"},{"location":"reference/utils/m3u/#spotdl.utils.m3u.create_m3u_content--arguments","title":"Arguments","text":"<ul> <li>song_list: the list of songs</li> <li>template: the template to use</li> <li>file_extension: the file extension to use</li> <li>restrict: sanitization to apply to the filename</li> <li>short: whether to use the short version of the template</li> <li>detect_formats: the formats to detect for existing files</li> </ul>"},{"location":"reference/utils/m3u/#spotdl.utils.m3u.create_m3u_content--returns","title":"Returns","text":"<ul> <li>the m3u content as a string</li> </ul> Source code in <code>spotdl/utils/m3u.py</code> <pre><code>def create_m3u_content(\n    song_list: List[Song],\n    template: str,\n    file_extension: str,\n    restrict: Optional[str] = None,\n    short: bool = False,\n    detect_formats: Optional[List[str]] = None,\n) -&gt; str:\n    \"\"\"\n    Create m3u content and return it as a string.\n\n    ### Arguments\n    - song_list: the list of songs\n    - template: the template to use\n    - file_extension: the file extension to use\n    - restrict: sanitization to apply to the filename\n    - short: whether to use the short version of the template\n    - detect_formats: the formats to detect for existing files\n\n    ### Returns\n    - the m3u content as a string\n    \"\"\"\n\n    text = \"#EXTM3U\\n\"\n\n    for song in song_list:\n        metadata = create_file_name(\n            song, \"#EXTINF:{duration},{album-artist} - {title}\", \"\"\n        )\n        text += str(metadata) + \"\\n\"\n\n        if not detect_formats:\n            file_name = create_file_name(\n                song, template, file_extension, restrict, short\n            )\n\n            text += str(file_name) + \"\\n\"\n        else:\n            for file_ext in detect_formats:\n                file_name = create_file_name(song, template, file_ext, restrict, short)\n\n                if file_name.exists():\n                    text += str(file_name) + \"\\n\"\n                    break\n\n                file_name = create_file_name(\n                    song, template, file_extension, restrict, short\n                )\n                text += str(file_name) + \"\\n\"\n\n    return text\n</code></pre>"},{"location":"reference/utils/m3u/#spotdl.utils.m3u.create_m3u_file","title":"<code>create_m3u_file(file_name, song_list, template, file_extension, restrict=None, short=False, detect_formats=None)</code>","text":"<p>Create the m3u file.</p>"},{"location":"reference/utils/m3u/#spotdl.utils.m3u.create_m3u_file--arguments","title":"Arguments","text":"<ul> <li>file_name: the file name to use</li> <li>song_list: the list of songs</li> <li>template: the template to use</li> <li>file_extension: the file extension to use</li> <li>restrict: sanitization to apply to the filename</li> <li>short: whether to use the short version of the template</li> <li>detect_formats: the formats to detect</li> </ul>"},{"location":"reference/utils/m3u/#spotdl.utils.m3u.create_m3u_file--returns","title":"Returns","text":"<ul> <li>the m3u content as a string</li> </ul> Source code in <code>spotdl/utils/m3u.py</code> <pre><code>def create_m3u_file(\n    file_name: str,\n    song_list: List[Song],\n    template: str,\n    file_extension: str,\n    restrict: Optional[str] = None,\n    short: bool = False,\n    detect_formats: Optional[List[str]] = None,\n) -&gt; str:\n    \"\"\"\n    Create the m3u file.\n\n    ### Arguments\n    - file_name: the file name to use\n    - song_list: the list of songs\n    - template: the template to use\n    - file_extension: the file extension to use\n    - restrict: sanitization to apply to the filename\n    - short: whether to use the short version of the template\n    - detect_formats: the formats to detect\n\n    ### Returns\n    - the m3u content as a string\n    \"\"\"\n\n    m3u_content = create_m3u_content(\n        song_list,\n        template,\n        file_extension,\n        restrict,\n        short,\n        detect_formats,\n    )\n\n    file_path = Path(\n        *(sanitize_string(part) for part in Path(file_name).parts)\n    ).absolute()\n\n    with open(file_path, \"w\", encoding=\"utf-8\") as m3u_file:\n        m3u_file.write(m3u_content)\n\n    return m3u_content\n</code></pre>"},{"location":"reference/utils/m3u/#spotdl.utils.m3u.gen_m3u_files","title":"<code>gen_m3u_files(songs, file_name, template, file_extension, restrict=None, short=False, detect_formats=None)</code>","text":"<p>Create an m3u8 filename from the query.</p>"},{"location":"reference/utils/m3u/#spotdl.utils.m3u.gen_m3u_files--arguments","title":"Arguments","text":"<ul> <li>songs: the list of songs</li> <li>file_name: the file name to use</li> <li>template: the output file template to use</li> <li>file_extension: the file extension to use</li> <li>restrict: sanitization to apply to the filename</li> <li>short: whether to use the short version of the template</li> <li>detect_formats: the formats to detect</li> </ul> Source code in <code>spotdl/utils/m3u.py</code> <pre><code>def gen_m3u_files(\n    songs: List[Song],\n    file_name: Optional[str],\n    template: str,\n    file_extension: str,\n    restrict: Optional[str] = None,\n    short: bool = False,\n    detect_formats: Optional[List[str]] = None,\n):\n    \"\"\"\n    Create an m3u8 filename from the query.\n\n    ### Arguments\n    - songs: the list of songs\n    - file_name: the file name to use\n    - template: the output file template to use\n    - file_extension: the file extension to use\n    - restrict: sanitization to apply to the filename\n    - short: whether to use the short version of the template\n    - detect_formats: the formats to detect\n    \"\"\"\n\n    # If no file name is provided, use the first list's name\n    if not file_name:\n        file_name = \"{list[0]}.m3u8\"\n\n    # If file_name ends with a slash. Does not have a m3u8 name with extension\n    # at the end of the template, append `{list[0]}`` to it\n    if (\n        file_name.endswith(\"/\")\n        or file_name.endswith(r\"\\\\\")\n        or file_name.endswith(\"\\\\\\\\\")\n    ):\n        file_name += \"/{list[0]}.m3u8\"\n\n    # Check if the file name ends with .m3u or .m3u8\n    if not file_name.endswith(\".m3u\") and not file_name.endswith(\".m3u8\"):\n        file_name += \".m3u8\"\n\n    lists_object: Dict[str, List[Song]] = {}\n    for song in songs:\n        if song.list_name is None:\n            continue\n\n        if song.list_name not in lists_object:\n            lists_object[song.list_name] = []\n\n        lists_object[song.list_name].append(song)\n\n    if \"{list}\" in file_name:\n        # Create multiple m3u files if there are multiple lists\n        for list_name, song_list in lists_object.items():\n            create_m3u_file(\n                file_name.format(\n                    list=list_name,\n                ),\n                song_list,\n                template,\n                file_extension,\n                restrict,\n                short,\n                detect_formats,\n            )\n    elif \"{list[\" in file_name and \"]}\" in file_name:\n        # Create a single m3u file for specified song list name\n        create_m3u_file(\n            file_name.format(list=list(lists_object.keys())),\n            songs,\n            template,\n            file_extension,\n            restrict,\n            short,\n            detect_formats,\n        )\n    else:\n        # Use the provided file name\n        create_m3u_file(\n            file_name,\n            songs,\n            template,\n            file_extension,\n            restrict,\n            short,\n            detect_formats,\n        )\n</code></pre>"},{"location":"reference/utils/matching/","title":"matching","text":"<p>Module for all things matching related</p>"},{"location":"reference/utils/matching/#spotdl.utils.matching.artists_match_fixup1","title":"<code>artists_match_fixup1(song, result, score)</code>","text":"<p>Multiple fixes to the artists score for not verified results to improve the accuracy</p>"},{"location":"reference/utils/matching/#spotdl.utils.matching.artists_match_fixup1--arguments","title":"Arguments","text":"<ul> <li>song: song to match</li> <li>result: result to match</li> <li>score: current score</li> </ul>"},{"location":"reference/utils/matching/#spotdl.utils.matching.artists_match_fixup1--returns","title":"Returns","text":"<ul> <li>new score</li> </ul> Source code in <code>spotdl/utils/matching.py</code> <pre><code>def artists_match_fixup1(song: Song, result: Result, score: float) -&gt; float:\n    \"\"\"\n    Multiple fixes to the artists score for\n    not verified results to improve the accuracy\n\n    ### Arguments\n    - song: song to match\n    - result: result to match\n    - score: current score\n\n    ### Returns\n    - new score\n    \"\"\"\n\n    # If we have a verified result, we don't have to fix anything\n    if result.verified or score &gt; 50:\n        return score\n\n    # If we didn't find any artist match,\n    # we fallback to channel name match\n    channel_name_match = ratio(\n        slugify(song.artist),\n        slugify(\", \".join(result.artists)) if result.artists else \"\",\n    )\n\n    score = max(score, channel_name_match)\n\n    # If artist match is still too low,\n    # we fallback to matching all song artist names\n    # with the result's title\n    if score &lt;= 70:\n        artist_title_match = 0.0\n        result_name = slugify(result.name).replace(\"-\", \"\")\n        for artist in song.artists:\n            slug_artist = slugify(artist).replace(\"-\", \"\")\n\n            if slug_artist in result_name:\n                artist_title_match += 1.0\n\n        artist_title_match = (artist_title_match / len(song.artists)) * 100\n\n        score = max(score, artist_title_match)\n\n    # If artist match is still too low,\n    # we fallback to matching all song artist names\n    # with the result's artists\n    if score &lt;= 70:\n        # Song artists: ['charlie-moncler', 'fukaj', 'mata', 'pedro']\n        # Result artists: ['fukaj-mata-charlie-moncler-und-pedro']\n\n        # For artist_list1\n        artist_list1 = []\n        for artist in song.artists:\n            artist_list1.extend(slugify(artist).split(\"-\"))\n\n        # For artist_list2\n        artist_list2 = []\n        if result.artists:\n            for artist in result.artists:\n                artist_list2.extend(slugify(artist).split(\"-\"))\n\n        artist_tuple1 = tuple(artist_list1)\n        artist_tuple2 = tuple(artist_list2)\n\n        artist_title_match = ratio(artist_tuple1, artist_tuple2)\n\n        score = max(score, artist_title_match)\n\n    return score\n</code></pre>"},{"location":"reference/utils/matching/#spotdl.utils.matching.artists_match_fixup2","title":"<code>artists_match_fixup2(song, result, score, search_query=None)</code>","text":"<p>Multiple fixes to the artists score for verified results to improve the accuracy</p>"},{"location":"reference/utils/matching/#spotdl.utils.matching.artists_match_fixup2--arguments","title":"Arguments","text":"<ul> <li>song: song to match</li> <li>result: result to match</li> <li>score: current score</li> </ul>"},{"location":"reference/utils/matching/#spotdl.utils.matching.artists_match_fixup2--returns","title":"Returns","text":"<ul> <li>new score</li> </ul> Source code in <code>spotdl/utils/matching.py</code> <pre><code>def artists_match_fixup2(\n    song: Song, result: Result, score: float, search_query: Optional[str] = None\n) -&gt; float:\n    \"\"\"\n    Multiple fixes to the artists score for\n    verified results to improve the accuracy\n\n    ### Arguments\n    - song: song to match\n    - result: result to match\n    - score: current score\n\n    ### Returns\n    - new score\n    \"\"\"\n\n    if score &gt; 70 or not result.verified:\n        # Don't fixup the score\n        # if the artist match is already high\n        # or if the result is not verified\n        return score\n\n    # Slugify some variables\n    slug_song_name = slugify(song.name)\n    slug_result_name = slugify(result.name)\n\n    # # Check if the main artist is simlar\n    has_main_artist = (score / (2 if len(song.artists) &gt; 1 else 1)) &gt; 50\n\n    _, match_str2 = create_match_strings(song, result, search_query)\n\n    # Check if other song artists are in the result name\n    # if they are, we increase the artist match\n    # (main artist is already checked, so we skip it)\n    artists_to_check = song.artists[int(has_main_artist) :]\n    for artist in artists_to_check:\n        artist = slugify(artist).replace(\"-\", \"\")\n        if artist in match_str2.replace(\"-\", \"\"):\n            score += 5\n\n    # if the artist match is still too low,\n    # we fallback to matching all song artist names\n    # with the result's artists\n    if score &lt;= 70:\n        # Artists from song/result name without the song/result name words\n        artist_list1 = create_clean_string(song.artists, slug_song_name, True)\n        artist_list2 = create_clean_string(\n            list(result.artists) if result.artists else [result.author],\n            slug_result_name,\n            True,\n        )\n\n        artist_title_match = ratio(artist_list1, artist_list2)\n\n        score = max(score, artist_title_match)\n\n    return score\n</code></pre>"},{"location":"reference/utils/matching/#spotdl.utils.matching.artists_match_fixup3","title":"<code>artists_match_fixup3(song, result, score)</code>","text":"<p>Calculate match percentage based result's name and song's title if the result has exactly one artist and the song has more than one artist</p>"},{"location":"reference/utils/matching/#spotdl.utils.matching.artists_match_fixup3--arguments","title":"Arguments","text":"<ul> <li>song: song to match</li> <li>result: result to match</li> <li>score: current score</li> </ul>"},{"location":"reference/utils/matching/#spotdl.utils.matching.artists_match_fixup3--returns","title":"Returns","text":"<ul> <li>new score</li> </ul> Source code in <code>spotdl/utils/matching.py</code> <pre><code>def artists_match_fixup3(song: Song, result: Result, score: float) -&gt; float:\n    \"\"\"\n    Calculate match percentage based result's name\n    and song's title if the result has exactly one artist\n    and the song has more than one artist\n\n    ### Arguments\n    - song: song to match\n    - result: result to match\n    - score: current score\n\n    ### Returns\n    - new score\n    \"\"\"\n\n    if (\n        score &gt; 70\n        or not result.artists\n        or len(result.artists) &gt; 1\n        or len(song.artists) == 1\n    ):\n        # Don't fixup the score\n        # if the score is already high\n        # or if the result has more than one artist\n        # or if the song has only one artist\n        return score\n\n    artists_score_fixup = ratio(\n        slugify(result.name),\n        slugify(create_song_title(song.name, [song.artist])),\n    )\n\n    if artists_score_fixup &gt;= 80:\n        score = (score + artists_score_fixup) / 2\n\n    # Make sure that the score is not higher than 100\n    score = min(score, 100)\n\n    return score\n</code></pre>"},{"location":"reference/utils/matching/#spotdl.utils.matching.based_sort","title":"<code>based_sort(strings, based_on)</code>","text":"<p>Sort strings in list based on the order of strings in <code>based_on</code> list</p>"},{"location":"reference/utils/matching/#spotdl.utils.matching.based_sort--arguments","title":"Arguments","text":"<ul> <li>strings: strings to sort</li> <li>based_on: strings to sort <code>strings</code> list based on</li> </ul>"},{"location":"reference/utils/matching/#spotdl.utils.matching.based_sort--returns","title":"Returns","text":"<ul> <li>sorted list of strings</li> </ul> Source code in <code>spotdl/utils/matching.py</code> <pre><code>def based_sort(strings: List[str], based_on: List[str]) -&gt; Tuple[List[str], List[str]]:\n    \"\"\"\n    Sort strings in list based on the order of strings in `based_on` list\n\n    ### Arguments\n    - strings: strings to sort\n    - based_on: strings to sort `strings` list based on\n\n    ### Returns\n    - sorted list of strings\n    \"\"\"\n\n    strings.sort()\n    based_on.sort()\n\n    list_map = {value: index for index, value in enumerate(based_on)}\n\n    strings = sorted(\n        strings,\n        key=lambda x: list_map.get(x, -1),\n        reverse=True,\n    )\n\n    based_on.reverse()\n\n    return strings, based_on\n</code></pre>"},{"location":"reference/utils/matching/#spotdl.utils.matching.calc_album_match","title":"<code>calc_album_match(song, result)</code>","text":"<p>Calculate album match percentage</p>"},{"location":"reference/utils/matching/#spotdl.utils.matching.calc_album_match--arguments","title":"Arguments","text":"<ul> <li>song: song to match</li> <li>result: result to match</li> </ul>"},{"location":"reference/utils/matching/#spotdl.utils.matching.calc_album_match--returns","title":"Returns","text":"<ul> <li>album match percentage</li> </ul> Source code in <code>spotdl/utils/matching.py</code> <pre><code>def calc_album_match(song: Song, result: Result) -&gt; float:\n    \"\"\"\n    Calculate album match percentage\n\n    ### Arguments\n    - song: song to match\n    - result: result to match\n\n    ### Returns\n    - album match percentage\n    \"\"\"\n\n    if not result.album:\n        return 0.0\n\n    return ratio(slugify(song.album_name), slugify(result.album))\n</code></pre>"},{"location":"reference/utils/matching/#spotdl.utils.matching.calc_artists_match","title":"<code>calc_artists_match(song, result)</code>","text":"<p>Check if all artists are present in list of artists</p>"},{"location":"reference/utils/matching/#spotdl.utils.matching.calc_artists_match--arguments","title":"Arguments","text":"<ul> <li>song: song to match</li> <li>result: result to match</li> </ul>"},{"location":"reference/utils/matching/#spotdl.utils.matching.calc_artists_match--returns","title":"Returns","text":"<ul> <li>artists match percentage</li> </ul> Source code in <code>spotdl/utils/matching.py</code> <pre><code>def calc_artists_match(song: Song, result: Result) -&gt; float:\n    \"\"\"\n    Check if all artists are present in list of artists\n\n    ### Arguments\n    - song: song to match\n    - result: result to match\n\n    ### Returns\n    - artists match percentage\n    \"\"\"\n\n    artist_match_number = 0.0\n\n    # Result has only one artist, return 0.0\n    if len(song.artists) == 1 or not result.artists:\n        return artist_match_number\n\n    artist1_list, artist2_list = based_sort(\n        list(map(slugify, song.artists)), list(map(slugify, result.artists))\n    )\n\n    # Remove main artist from the lists\n    artist1_list, artist2_list = artist1_list[1:], artist2_list[1:]\n\n    artists_match = 0.0\n    for artist1, artist2 in zip_longest(artist1_list, artist2_list):\n        artist12_match = ratio(artist1, artist2)\n        artists_match += artist12_match\n\n    artist_match_number = artists_match / len(artist1_list)\n\n    return artist_match_number\n</code></pre>"},{"location":"reference/utils/matching/#spotdl.utils.matching.calc_main_artist_match","title":"<code>calc_main_artist_match(song, result)</code>","text":"<p>Check if main artist is present in list of artists</p>"},{"location":"reference/utils/matching/#spotdl.utils.matching.calc_main_artist_match--arguments","title":"Arguments","text":"<ul> <li>main_artist: main artist to check</li> <li>artists: list of artists to check</li> </ul>"},{"location":"reference/utils/matching/#spotdl.utils.matching.calc_main_artist_match--returns","title":"Returns","text":"<ul> <li>True if main artist is present in list of artists, False otherwise</li> </ul> Source code in <code>spotdl/utils/matching.py</code> <pre><code>def calc_main_artist_match(song: Song, result: Result) -&gt; float:\n    \"\"\"\n    Check if main artist is present in list of artists\n\n    ### Arguments\n    - main_artist: main artist to check\n    - artists: list of artists to check\n\n    ### Returns\n    - True if main artist is present in list of artists, False otherwise\n    \"\"\"\n\n    main_artist_match = 0.0\n\n    # Result has no artists, return 0.0\n    if not result.artists:\n        return main_artist_match\n\n    song_artists, result_artists = list(map(slugify, song.artists)), list(\n        map(slugify, result.artists)\n    )\n    sorted_song_artists, sorted_result_artists = based_sort(\n        song_artists, result_artists\n    )\n\n    debug(song.song_id, result.result_id, f\"Song artists: {sorted_song_artists}\")\n    debug(song.song_id, result.result_id, f\"Result artists: {sorted_result_artists}\")\n\n    slug_song_main_artist = slugify(song.artists[0])\n    slug_result_main_artist = sorted_result_artists[0]\n\n    # Result has only one artist, but song has multiple artists\n    # we can assume that other artists are in the main artist name\n    if len(song.artists) &gt; 1 and len(result.artists) == 1:\n        for artist in map(slugify, song.artists[1:]):\n            artist = sort_string(slugify(artist).split(\"-\"), \"-\")\n\n            res_main_artist = sort_string(slug_result_main_artist.split(\"-\"), \"-\")\n\n            if artist in res_main_artist:\n                main_artist_match += 100 / len(song.artists)\n\n        return main_artist_match\n\n    # Match main result artist with main song artist\n    main_artist_match = ratio(slug_song_main_artist, slug_result_main_artist)\n\n    debug(\n        song.song_id, result.result_id, f\"First main artist match: {main_artist_match}\"\n    )\n\n    # Use second artist from the sorted list to\n    # calculate the match if the first artist match is too low\n    if main_artist_match &lt; 50 and len(song_artists) &gt; 1:\n        for song_artist, result_artist in product(\n            song_artists[:2], sorted_result_artists[:2]\n        ):\n            new_artist_match = ratio(song_artist, result_artist)\n            debug(\n                song.song_id,\n                result.result_id,\n                f\"Matched {song_artist} with {result_artist}: {new_artist_match}\",\n            )\n\n            main_artist_match = max(main_artist_match, new_artist_match)\n\n    return main_artist_match\n</code></pre>"},{"location":"reference/utils/matching/#spotdl.utils.matching.calc_name_match","title":"<code>calc_name_match(song, result, search_query=None)</code>","text":"<p>Calculate name match percentage</p>"},{"location":"reference/utils/matching/#spotdl.utils.matching.calc_name_match--arguments","title":"Arguments","text":"<ul> <li>song: song to match</li> <li>result: result to match</li> </ul>"},{"location":"reference/utils/matching/#spotdl.utils.matching.calc_name_match--returns","title":"Returns","text":"<ul> <li>name match percentage</li> </ul> Source code in <code>spotdl/utils/matching.py</code> <pre><code>def calc_name_match(\n    song: Song, result: Result, search_query: Optional[str] = None\n) -&gt; float:\n    \"\"\"\n    Calculate name match percentage\n\n    ### Arguments\n    - song: song to match\n    - result: result to match\n\n    ### Returns\n    - name match percentage\n    \"\"\"\n\n    # Create match strings that will be used\n    # to calculate name match value\n    match_str1, match_str2 = create_match_strings(song, result, search_query)\n    result_name, song_name = slugify(result.name), slugify(song.name)\n\n    res_list, song_list = based_sort(result_name.split(\"-\"), song_name.split(\"-\"))\n    result_name, song_name = \"-\".join(res_list), \"-\".join(song_list)\n\n    # Calculate initial name match\n    name_match = ratio(result_name, song_name)\n\n    debug(song.song_id, result.result_id, f\"MATCH STRINGS: {match_str1} - {match_str2}\")\n    debug(\n        song.song_id,\n        result.result_id,\n        f\"SLUG MATCH STRINGS: {song_name} - {result_name}\",\n    )\n    debug(song.song_id, result.result_id, f\"First name match: {name_match}\")\n\n    # If name match is lower than 60%,\n    # we try to match using the test strings\n    if name_match &lt;= 75:\n        second_name_match = ratio(\n            match_str1,\n            match_str2,\n        )\n\n        debug(\n            song.song_id,\n            result.result_id,\n            f\"Second name match: {second_name_match}\",\n        )\n\n        name_match = max(name_match, second_name_match)\n\n    return name_match\n</code></pre>"},{"location":"reference/utils/matching/#spotdl.utils.matching.calc_time_match","title":"<code>calc_time_match(song, result)</code>","text":"<p>Calculate time difference between song and result</p>"},{"location":"reference/utils/matching/#spotdl.utils.matching.calc_time_match--arguments","title":"Arguments","text":"<ul> <li>song: song to match</li> <li>result: result to match</li> </ul>"},{"location":"reference/utils/matching/#spotdl.utils.matching.calc_time_match--returns","title":"Returns","text":"<ul> <li>time difference between song and result</li> </ul> Source code in <code>spotdl/utils/matching.py</code> <pre><code>def calc_time_match(song: Song, result: Result) -&gt; float:\n    \"\"\"\n    Calculate time difference between song and result\n\n    ### Arguments\n    - song: song to match\n    - result: result to match\n\n    ### Returns\n    - time difference between song and result\n    \"\"\"\n\n    time_diff = abs(song.duration - result.duration)\n    score = exp(-0.1 * time_diff)\n    return score * 100\n</code></pre>"},{"location":"reference/utils/matching/#spotdl.utils.matching.check_common_word","title":"<code>check_common_word(song, result)</code>","text":"<p>Check if a word is present in a sentence</p>"},{"location":"reference/utils/matching/#spotdl.utils.matching.check_common_word--arguments","title":"Arguments","text":"<ul> <li>song: song to match</li> <li>result: result to match</li> </ul>"},{"location":"reference/utils/matching/#spotdl.utils.matching.check_common_word--returns","title":"Returns","text":"<ul> <li>True if word is present in sentence, False otherwise</li> </ul> Source code in <code>spotdl/utils/matching.py</code> <pre><code>def check_common_word(song: Song, result: Result) -&gt; bool:\n    \"\"\"\n    Check if a word is present in a sentence\n\n    ### Arguments\n    - song: song to match\n    - result: result to match\n\n    ### Returns\n    - True if word is present in sentence, False otherwise\n    \"\"\"\n\n    sentence_words = slugify(song.name).split(\"-\")\n    to_check = slugify(result.name).replace(\"-\", \"\")\n\n    for word in sentence_words:\n        if word != \"\" and word in to_check:\n            return True\n\n    return False\n</code></pre>"},{"location":"reference/utils/matching/#spotdl.utils.matching.check_forbidden_words","title":"<code>check_forbidden_words(song, result)</code>","text":"<p>Check if a forbidden word is present in the result name</p>"},{"location":"reference/utils/matching/#spotdl.utils.matching.check_forbidden_words--arguments","title":"Arguments","text":"<ul> <li>song: song to match</li> <li>result: result to match</li> </ul>"},{"location":"reference/utils/matching/#spotdl.utils.matching.check_forbidden_words--returns","title":"Returns","text":"<ul> <li>True if forbidden word is present in result name, False otherwise</li> </ul> Source code in <code>spotdl/utils/matching.py</code> <pre><code>def check_forbidden_words(song: Song, result: Result) -&gt; Tuple[bool, List[str]]:\n    \"\"\"\n    Check if a forbidden word is present in the result name\n\n    ### Arguments\n    - song: song to match\n    - result: result to match\n\n    ### Returns\n    - True if forbidden word is present in result name, False otherwise\n    \"\"\"\n\n    song_name = slugify(song.name).replace(\"-\", \"\")\n    to_check = slugify(result.name).replace(\"-\", \"\")\n\n    words = []\n    for word in FORBIDDEN_WORDS:\n        if word in to_check and word not in song_name:\n            words.append(word)\n\n    return len(words) &gt; 0, words\n</code></pre>"},{"location":"reference/utils/matching/#spotdl.utils.matching.create_clean_string","title":"<code>create_clean_string(words, string, sort=False, join_str='-')</code>","text":"<p>Create a string with strings from <code>words</code> list if they are not yet present in <code>string</code></p>"},{"location":"reference/utils/matching/#spotdl.utils.matching.create_clean_string--arguments","title":"Arguments","text":"<ul> <li>words: strings to check</li> <li>string: string to check if strings are present in</li> <li>sort: sort strings in list</li> <li>join_str: string to join strings with</li> </ul>"},{"location":"reference/utils/matching/#spotdl.utils.matching.create_clean_string--returns","title":"Returns","text":"<ul> <li>string with strings from <code>words</code> list</li> </ul> Source code in <code>spotdl/utils/matching.py</code> <pre><code>def create_clean_string(\n    words: List[str], string: str, sort: bool = False, join_str: str = \"-\"\n) -&gt; str:\n    \"\"\"\n    Create a string with strings from `words` list\n    if they are not yet present in `string`\n\n    ### Arguments\n    - words: strings to check\n    - string: string to check if strings are present in\n    - sort: sort strings in list\n    - join_str: string to join strings with\n\n    ### Returns\n    - string with strings from `words` list\n    \"\"\"\n\n    string = slugify(string).replace(\"-\", \"\")\n\n    final = []\n    for word in words:\n        word = slugify(word).replace(\"-\", \"\")\n\n        if word in string:\n            continue\n\n        final.append(word)\n\n    if sort:\n        return sort_string(final, join_str)\n\n    return f\"{join_str}\".join(final)\n</code></pre>"},{"location":"reference/utils/matching/#spotdl.utils.matching.create_match_strings","title":"<code>create_match_strings(song, result, search_query=None)</code>","text":"<p>Create strings based on song and result to match fill strings with missing artists</p>"},{"location":"reference/utils/matching/#spotdl.utils.matching.create_match_strings--arguments","title":"Arguments","text":"<ul> <li>song: song to match</li> <li>result: result to match</li> </ul>"},{"location":"reference/utils/matching/#spotdl.utils.matching.create_match_strings--returns","title":"Returns","text":"<ul> <li>tuple of strings to match</li> </ul> Source code in <code>spotdl/utils/matching.py</code> <pre><code>def create_match_strings(\n    song: Song, result: Result, search_query: Optional[str] = None\n) -&gt; Tuple[str, str]:\n    \"\"\"\n    Create strings based on song and result to match\n    fill strings with missing artists\n\n    ### Arguments\n    - song: song to match\n    - result: result to match\n\n    ### Returns\n    - tuple of strings to match\n    \"\"\"\n\n    slug_song_name = slugify(song.name)\n    slug_song_title = slugify(\n        create_song_title(song.name, song.artists)\n        if not search_query\n        else create_search_query(song, search_query, False, None, True)\n    )\n\n    test_str1 = slugify(result.name)\n    test_str2 = slug_song_name if result.verified else slug_song_title\n\n    # Fill strings with missing artists\n    test_str1 = fill_string(song.artists, test_str1, test_str2)\n    test_str2 = fill_string(song.artists, test_str2, test_str1)\n\n    # Sort both strings and then join them\n    test_list1, test_list2 = based_sort(test_str1.split(\"-\"), test_str2.split(\"-\"))\n    test_str1, test_str2 = \"-\".join(test_list1), \"-\".join(test_list2)\n\n    return test_str1, test_str2\n</code></pre>"},{"location":"reference/utils/matching/#spotdl.utils.matching.debug","title":"<code>debug(song_id, result_id, message)</code>","text":"<p>Log a message with MATCH level</p>"},{"location":"reference/utils/matching/#spotdl.utils.matching.debug--arguments","title":"Arguments","text":"<ul> <li>message: message to log</li> </ul> Source code in <code>spotdl/utils/matching.py</code> <pre><code>def debug(song_id: str, result_id: str, message: str) -&gt; None:\n    \"\"\"\n    Log a message with MATCH level\n\n    ### Arguments\n    - message: message to log\n    \"\"\"\n\n    logger.log(MATCH, \"[%s|%s] %s\", song_id, result_id, message)\n</code></pre>"},{"location":"reference/utils/matching/#spotdl.utils.matching.fill_string","title":"<code>fill_string(strings, main_string, string_to_check)</code>","text":"<p>Create a string with strings from <code>strings</code> list if they are not yet present in main_string but are present in string_to_check</p>"},{"location":"reference/utils/matching/#spotdl.utils.matching.fill_string--arguments","title":"Arguments","text":"<ul> <li>strings: strings to check</li> <li>main_string: string to add strings to</li> <li>string_to_check: string to check if strings are present in</li> </ul>"},{"location":"reference/utils/matching/#spotdl.utils.matching.fill_string--returns","title":"Returns","text":"<ul> <li>string with strings from <code>strings</code> list</li> </ul> Source code in <code>spotdl/utils/matching.py</code> <pre><code>def fill_string(strings: List[str], main_string: str, string_to_check: str) -&gt; str:\n    \"\"\"\n    Create a string with strings from `strings` list\n    if they are not yet present in main_string\n    but are present in string_to_check\n\n    ### Arguments\n    - strings: strings to check\n    - main_string: string to add strings to\n    - string_to_check: string to check if strings are present in\n\n    ### Returns\n    - string with strings from `strings` list\n    \"\"\"\n\n    final_str = main_string\n    test_str = final_str.replace(\"-\", \"\")\n    simple_test_str = string_to_check.replace(\"-\", \"\")\n    for string in strings:\n        slug_str = slugify(string).replace(\"-\", \"\")\n\n        if slug_str in simple_test_str and slug_str not in test_str:\n            final_str += f\"-{slug_str}\"\n            test_str += slug_str\n\n    return final_str\n</code></pre>"},{"location":"reference/utils/matching/#spotdl.utils.matching.get_best_matches","title":"<code>get_best_matches(results, score_threshold)</code>","text":"<p>Get best matches from a list of results</p>"},{"location":"reference/utils/matching/#spotdl.utils.matching.get_best_matches--arguments","title":"Arguments","text":"<ul> <li>results: list of results to match</li> <li>score_threshold: threshold to match results</li> </ul>"},{"location":"reference/utils/matching/#spotdl.utils.matching.get_best_matches--returns","title":"Returns","text":"<ul> <li>list of best matches</li> </ul> Source code in <code>spotdl/utils/matching.py</code> <pre><code>def get_best_matches(\n    results: Dict[Result, float], score_threshold: float\n) -&gt; List[Tuple[Result, float]]:\n    \"\"\"\n    Get best matches from a list of results\n\n    ### Arguments\n    - results: list of results to match\n    - score_threshold: threshold to match results\n\n    ### Returns\n    - list of best matches\n    \"\"\"\n\n    result_items = list(results.items())\n\n    # Sort results by highest score\n    sorted_results = sorted(result_items, key=lambda x: x[1], reverse=True)\n\n    best_score = sorted_results[0][1]\n\n    return [\n        result\n        for result in sorted_results\n        if (best_score - result[1]) &lt;= score_threshold\n    ]\n</code></pre>"},{"location":"reference/utils/matching/#spotdl.utils.matching.order_results","title":"<code>order_results(results, song, search_query=None)</code>","text":"<p>Order results.</p>"},{"location":"reference/utils/matching/#spotdl.utils.matching.order_results--arguments","title":"Arguments","text":"<ul> <li>results: The results to order.</li> <li>song: The song to order for.</li> <li>search_query: The search query.</li> </ul>"},{"location":"reference/utils/matching/#spotdl.utils.matching.order_results--returns","title":"Returns","text":"<ul> <li>The ordered results.</li> </ul> Source code in <code>spotdl/utils/matching.py</code> <pre><code>def order_results(\n    results: List[Result],\n    song: Song,\n    search_query: Optional[str] = None,\n) -&gt; Dict[Result, float]:\n    \"\"\"\n    Order results.\n\n    ### Arguments\n    - results: The results to order.\n    - song: The song to order for.\n    - search_query: The search query.\n\n    ### Returns\n    - The ordered results.\n    \"\"\"\n\n    # Assign an overall avg match value to each result\n    links_with_match_value = {}\n\n    # Iterate over all results\n    for result in results:\n        debug(\n            song.song_id,\n            result.result_id,\n            f\"Calculating match value for {result.url} - {result.json}\",\n        )\n\n        # skip results that have no common words in their name\n        if not check_common_word(song, result):\n            debug(\n                song.song_id, result.result_id, \"Skipping result due to no common words\"\n            )\n\n            continue\n\n        # Calculate match value for main artist\n        artists_match = calc_main_artist_match(song, result)\n        debug(song.song_id, result.result_id, f\"Main artist match: {artists_match}\")\n\n        # Calculate match value for all artists\n        other_artists_match = calc_artists_match(song, result)\n        debug(\n            song.song_id,\n            result.result_id,\n            f\"Other artists match: {other_artists_match}\",\n        )\n\n        artists_match += other_artists_match\n\n        # Calculate initial artist match value\n        debug(song.song_id, result.result_id, f\"Initial artists match: {artists_match}\")\n        artists_match = artists_match / (2 if len(song.artists) &gt; 1 else 1)\n        debug(song.song_id, result.result_id, f\"First artists match: {artists_match}\")\n\n        # First attempt to fix artist match\n        artists_match = artists_match_fixup1(song, result, artists_match)\n        debug(\n            song.song_id,\n            result.result_id,\n            f\"Artists match after fixup1: {artists_match}\",\n        )\n\n        # Second attempt to fix artist match\n        artists_match = artists_match_fixup2(song, result, artists_match)\n        debug(\n            song.song_id,\n            result.result_id,\n            f\"Artists match after fixup2: {artists_match}\",\n        )\n\n        # Third attempt to fix artist match\n        artists_match = artists_match_fixup3(song, result, artists_match)\n        debug(\n            song.song_id,\n            result.result_id,\n            f\"Artists match after fixup3: {artists_match}\",\n        )\n\n        debug(song.song_id, result.result_id, f\"Final artists match: {artists_match}\")\n\n        # Calculate name match\n        name_match = calc_name_match(song, result, search_query)\n        debug(song.song_id, result.result_id, f\"Initial name match: {name_match}\")\n\n        # Check if result contains forbidden words\n        contains_fwords, found_fwords = check_forbidden_words(song, result)\n        if contains_fwords:\n            for _ in found_fwords:\n                name_match -= 15\n\n        debug(\n            song.song_id,\n            result.result_id,\n            f\"Contains forbidden words: {contains_fwords}, {found_fwords}\",\n        )\n        debug(song.song_id, result.result_id, f\"Final name match: {name_match}\")\n\n        # Calculate album match\n        album_match = calc_album_match(song, result)\n        debug(song.song_id, result.result_id, f\"Final album match: {album_match}\")\n\n        # Calculate time match\n        time_match = calc_time_match(song, result)\n        debug(song.song_id, result.result_id, f\"Final time match: {time_match}\")\n\n        # Ignore results with name match lower than 60%\n        if name_match &lt;= 60:\n            debug(\n                song.song_id,\n                result.result_id,\n                \"Skipping result due to name match lower than 60%\",\n            )\n            continue\n\n        # Ignore results with artists match lower than 70%\n        if artists_match &lt; 70 and result.source != \"slider.kz\":\n            debug(\n                song.song_id,\n                result.result_id,\n                \"Skipping result due to artists match lower than 70%\",\n            )\n            continue\n\n        # Calculate total match\n        average_match = (artists_match + name_match) / 2\n        debug(song.song_id, result.result_id, f\"Average match: {average_match}\")\n\n        if (\n            result.verified\n            and not result.isrc_search\n            and result.album\n            and album_match &lt;= 80\n        ):\n            # we are almost certain that this is the correct result\n            # so we add the album match to the average match\n            average_match = (average_match + album_match) / 2\n            debug(\n                song.song_id,\n                result.result_id,\n                f\"Average match /w album match: {average_match}\",\n            )\n\n        # Skip results with time match lower than 25%\n        if time_match &lt; 25:\n            debug(\n                song.song_id,\n                result.result_id,\n                \"Skipping result due to time match lower than 25%\",\n            )\n            continue\n\n        # If the time match is lower than 50%\n        # and the average match is lower than 75%\n        # we skip the result\n        if time_match &lt; 50 and average_match &lt; 75:\n            debug(\n                song.song_id,\n                result.result_id,\n                \"Skipping result due to time match &lt; 50% and average match &lt; 75%\",\n            )\n            continue\n\n        if (\n            (not result.isrc_search and average_match &lt;= 85)\n            or result.source == \"slider.kz\"\n            or time_match &lt; 0\n        ):\n            # Don't add time to avg match if average match is not the best\n            # (lower than 85%), always include time match if result is from\n            # slider.kz or if time match is lower than 0\n            average_match = (average_match + time_match) / 2\n\n            debug(\n                song.song_id,\n                result.result_id,\n                f\"Average match /w time match: {average_match}\",\n            )\n\n            if (result.explicit is not None and song.explicit is not None) and (\n                result.explicit != song.explicit\n            ):\n                debug(\n                    song.song_id,\n                    result.result_id,\n                    \"Lowering average match due to explicit mismatch\",\n                )\n\n                average_match -= 5\n\n        average_match = min(average_match, 100)\n        debug(song.song_id, result.result_id, f\"Final average match: {average_match}\")\n\n        # the results along with the avg Match\n        links_with_match_value[result] = average_match\n\n    return links_with_match_value\n</code></pre>"},{"location":"reference/utils/matching/#spotdl.utils.matching.sort_string","title":"<code>sort_string(strings, join_str)</code>","text":"<p>Sort strings in list and join them with <code>join</code> string</p>"},{"location":"reference/utils/matching/#spotdl.utils.matching.sort_string--arguments","title":"Arguments","text":"<ul> <li>strings: strings to sort</li> <li>join: string to join strings with</li> </ul>"},{"location":"reference/utils/matching/#spotdl.utils.matching.sort_string--returns","title":"Returns","text":"<ul> <li>joined sorted string</li> </ul> Source code in <code>spotdl/utils/matching.py</code> <pre><code>def sort_string(strings: List[str], join_str: str) -&gt; str:\n    \"\"\"\n    Sort strings in list and join them with `join` string\n\n    ### Arguments\n    - strings: strings to sort\n    - join: string to join strings with\n\n    ### Returns\n    - joined sorted string\n    \"\"\"\n\n    final_str = strings\n    final_str.sort()\n\n    return f\"{join_str}\".join(final_str)\n</code></pre>"},{"location":"reference/utils/metadata/","title":"metadata","text":"<p>Module for embedding metadata into audio files using Mutagen.</p> <pre><code>embed_metadata(\n    output_file=Path(\"test.mp3\"),\n    song=song_object,\n    file_format=\"mp3\",\n)\n</code></pre>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.MetadataError","title":"<code>MetadataError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all exceptions related to metadata and id3 embedding.</p>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.embed_cover","title":"<code>embed_cover(audio_file, song, encoding)</code>","text":"<p>Embed the album art in the audio file.</p>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.embed_cover--arguments","title":"Arguments","text":"<ul> <li>audio_file: Audio file object.</li> <li>song: Song object.</li> </ul> Source code in <code>spotdl/utils/metadata.py</code> <pre><code>def embed_cover(audio_file, song: Song, encoding: str):\n    \"\"\"\n    Embed the album art in the audio file.\n\n    ### Arguments\n    - audio_file: Audio file object.\n    - song: Song object.\n    \"\"\"\n\n    if not song.cover_url:\n        return audio_file\n\n    # Try to download the cover art\n    try:\n        cover_data = requests.get(\n            song.cover_url,\n            timeout=10,\n            proxies=GlobalConfig.get_parameter(\"proxies\"),\n        ).content\n    except Exception:\n        return audio_file\n\n    # Create the image object for the file type\n    if encoding in [\"flac\", \"ogg\", \"opus\"]:\n        picture = Picture()\n        picture.type = 3\n        picture.desc = \"Cover\"\n        picture.mime = \"image/jpeg\"\n        picture.data = cover_data\n\n        if encoding in [\"ogg\", \"opus\"]:\n            image_data = picture.write()\n            encoded_data = base64.b64encode(image_data)\n            vcomment_value = encoded_data.decode(\"ascii\")\n            if \"metadata_block_picture\" in audio_file.keys():\n                audio_file.pop(\"metadata_block_picture\")\n            audio_file[\"metadata_block_picture\"] = [vcomment_value]\n        elif encoding == \"flac\":\n            if audio_file.pictures:\n                audio_file.clear_pictures()\n            audio_file.add_picture(picture)\n    elif encoding == \"m4a\":\n        if M4A_TAG_PRESET[\"albumart\"] in audio_file.keys():\n            audio_file.pop(M4A_TAG_PRESET[\"albumart\"])\n        audio_file[M4A_TAG_PRESET[\"albumart\"]] = [\n            MP4Cover(\n                cover_data,\n                imageformat=MP4Cover.FORMAT_JPEG,\n            )\n        ]\n    elif encoding == \"mp3\":\n        if \"APIC:Cover\" in audio_file.keys():\n            audio_file.pop(\"APIC:Cover\")\n        audio_file[\"APIC\"] = APIC(\n            encoding=3,\n            mime=\"image/jpeg\",\n            type=3,\n            desc=\"Cover\",\n            data=cover_data,\n        )\n\n    return audio_file\n</code></pre>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.embed_lyrics","title":"<code>embed_lyrics(audio_file, song, encoding)</code>","text":"<p>Detect lyrics type (lrc or txt) and embed them in the audio file.</p>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.embed_lyrics--arguments","title":"Arguments","text":"<ul> <li>audio_file: Audio file object.</li> <li>song: Song object.</li> <li>encoding: Encoding type.</li> </ul> Source code in <code>spotdl/utils/metadata.py</code> <pre><code>def embed_lyrics(audio_file, song: Song, encoding: str):\n    \"\"\"\n    Detect lyrics type (lrc or txt) and embed them in the audio file.\n\n    ### Arguments\n    - audio_file: Audio file object.\n    - song: Song object.\n    - encoding: Encoding type.\n    \"\"\"\n\n    lyrics = song.lyrics\n    if not lyrics:\n        return audio_file\n\n    tag_preset = TAG_PRESET if encoding != \"m4a\" else M4A_TAG_PRESET\n\n    # Check if the lyrics are in lrc format\n    # using regex on the first 5 lines\n    lrc_lines = lyrics.splitlines()[:5]\n    lrc_lines = [line for line in lrc_lines if line and LRC_REGEX.match(line)]\n\n    if len(lrc_lines) == 0:\n        # Lyrics are not in lrc format\n        # Embed them normally\n        if encoding == \"mp3\":\n            audio_file.add(USLT(encoding=Encoding.UTF8, text=song.lyrics))\n        else:\n            audio_file[tag_preset[\"lyrics\"]] = song.lyrics\n    else:\n        # Lyrics are in lrc format\n        # Embed them as SYLT id3 tag\n        clean_lyrics = remomve_lrc(lyrics)\n        if encoding == \"mp3\":\n            lrc_data = []\n            for line in lyrics.splitlines():\n                time_tag = line.split(\"]\", 1)[0] + \"]\"\n                text = line.replace(time_tag, \"\")\n\n                time_tag = time_tag.replace(\"[\", \"\")\n                time_tag = time_tag.replace(\"]\", \"\")\n                time_tag = time_tag.replace(\".\", \":\")\n                time_tag_vals = time_tag.split(\":\")\n                if len(time_tag_vals) != 3 or any(\n                    not isinstance(tag, int) for tag in time_tag_vals\n                ):\n                    continue\n\n                minute, sec, millisecond = time_tag_vals\n                time = to_ms(min=minute, sec=sec, ms=millisecond)\n                lrc_data.append((text, time))\n\n            audio_file.add(USLT(encoding=3, text=clean_lyrics))\n            audio_file.add(SYLT(encoding=3, text=lrc_data, format=2, type=1))\n        else:\n            audio_file[tag_preset[\"lyrics\"]] = song.lyrics\n\n    return audio_file\n</code></pre>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.embed_metadata","title":"<code>embed_metadata(output_file, song, id3_separator='/', skip_album_art=False)</code>","text":"<p>Set ID3 tags for generic files (FLAC, OPUS, OGG)</p>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.embed_metadata--arguments","title":"Arguments","text":"<ul> <li>output_file: Path to the output file.</li> <li>song: Song object.</li> <li>id3_separator: The separator used for the id3 tags.</li> <li>skip_album_art: Boolean to skip album art embedding.</li> </ul> Source code in <code>spotdl/utils/metadata.py</code> <pre><code>def embed_metadata(\n    output_file: Path,\n    song: Song,\n    id3_separator: str = \"/\",\n    skip_album_art: Optional[bool] = False,\n):\n    \"\"\"\n    Set ID3 tags for generic files (FLAC, OPUS, OGG)\n\n    ### Arguments\n    - output_file: Path to the output file.\n    - song: Song object.\n    - id3_separator: The separator used for the id3 tags.\n    - skip_album_art: Boolean to skip album art embedding.\n    \"\"\"\n\n    # Get the file extension for the output file\n    encoding = output_file.suffix[1:]\n\n    if encoding == \"wav\":\n        embed_wav_file(output_file, song)\n        return\n\n    # Get the tag preset for the file extension\n    tag_preset = TAG_PRESET if encoding != \"m4a\" else M4A_TAG_PRESET\n\n    try:\n        audio_file = File(str(output_file.resolve()), easy=encoding == \"mp3\")\n\n        if audio_file is None:\n            raise MetadataError(\n                f\"Unrecognized file format for {output_file} from {song.url}\"\n            )\n    except Exception as exc:\n        raise MetadataError(\"Unable to load file.\") from exc\n\n    # Embed basic metadata\n    audio_file[tag_preset[\"artist\"]] = song.artists\n    audio_file[tag_preset[\"albumartist\"]] = (\n        song.album_artist if song.album_artist else song.artist\n    )\n    audio_file[tag_preset[\"title\"]] = song.name\n    audio_file[tag_preset[\"date\"]] = song.date\n    audio_file[tag_preset[\"encodedby\"]] = song.publisher\n\n    # Embed metadata that isn't always present\n    album_name = song.album_name\n    if album_name:\n        audio_file[tag_preset[\"album\"]] = album_name\n\n    if song.genres:\n        audio_file[tag_preset[\"genre\"]] = song.genres[0].title()\n\n    if song.copyright_text:\n        audio_file[tag_preset[\"copyright\"]] = song.copyright_text\n\n    if song.download_url and encoding != \"mp3\":\n        audio_file[tag_preset[\"comment\"]] = song.download_url\n\n    # Embed some metadata in format specific ways\n    if encoding in [\"flac\", \"ogg\", \"opus\"]:\n        audio_file[\"discnumber\"] = str(song.disc_number)\n        audio_file[\"disctotal\"] = str(song.disc_count)\n        audio_file[\"tracktotal\"] = str(song.tracks_count)\n        audio_file[\"tracknumber\"] = str(song.track_number)\n        audio_file[\"woas\"] = song.url\n        audio_file[\"isrc\"] = song.isrc\n    elif encoding == \"m4a\":\n        audio_file[tag_preset[\"discnumber\"]] = [(song.disc_number, song.disc_count)]\n        audio_file[tag_preset[\"tracknumber\"]] = [(song.track_number, song.tracks_count)]\n        audio_file[tag_preset[\"explicit\"]] = (4 if song.explicit is True else 2,)\n        audio_file[tag_preset[\"woas\"]] = song.url.encode(\"utf-8\")\n    elif encoding == \"mp3\":\n        audio_file[\"tracknumber\"] = f\"{str(song.track_number)}/{str(song.tracks_count)}\"\n        audio_file[\"discnumber\"] = f\"{str(song.disc_number)}/{str(song.disc_count)}\"\n        audio_file[\"isrc\"] = song.isrc\n\n    # Mp3 specific encoding\n    if encoding == \"mp3\":\n        if id3_separator != \"/\":\n            audio_file.save(v23_sep=id3_separator, v2_version=3)\n        else:\n            audio_file.save(v2_version=3)\n\n        audio_file = ID3(str(output_file.resolve()))\n\n        audio_file.add(WOAS(encoding=3, url=song.url))\n\n        if song.download_url:\n            audio_file.add(COMM(encoding=3, text=song.download_url))\n\n        if song.popularity:\n            audio_file.add(\n                POPM(\n                    rating=int(song.popularity * 255 / 100),\n                )\n            )\n\n        if song.year:\n            audio_file.add(TYER(encoding=3, text=str(song.year)))\n\n    if not skip_album_art:\n        # Embed album art\n        audio_file = embed_cover(audio_file, song, encoding)\n\n    # Embed lyrics\n    audio_file = embed_lyrics(audio_file, song, encoding)\n\n    # Mp3 specific encoding\n    if encoding == \"mp3\":\n        audio_file.save(v23_sep=id3_separator, v2_version=3)\n    else:\n        audio_file.save()\n</code></pre>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.embed_wav_file","title":"<code>embed_wav_file(output_file, song)</code>","text":"<p>Embeds the song metadata into the wav file</p>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.embed_wav_file--arguments","title":"Arguments","text":"<ul> <li>output_file: The output file path</li> <li>song: The song object</li> <li>id3_separator: The separator used for the id3 tags</li> </ul> Source code in <code>spotdl/utils/metadata.py</code> <pre><code>def embed_wav_file(output_file: Path, song: Song):\n    \"\"\"\n    Embeds the song metadata into the wav file\n\n    ### Arguments\n    - output_file: The output file path\n    - song: The song object\n    - id3_separator: The separator used for the id3 tags\n    \"\"\"\n    audio = WAVE(output_file)\n    if audio is None:\n        raise ValueError(\"Invalid audio file\")\n\n    if audio.tags:\n        audio.tags.clear()\n\n    audio.add_tags()\n\n    audio.tags.add(TIT2(encoding=3, text=song.name))  # type: ignore\n    audio.tags.add(TPE1(encoding=3, text=song.artists))  # type: ignore\n    audio.tags.add(TALB(encoding=3, text=song.album_name))  # type: ignore\n    audio.tags.add(TCOM(encoding=3, text=song.publisher))  # type: ignore\n    audio.tags.add(TCON(encoding=3, text=song.genres))  # type: ignore\n    audio.tags.add(TDRC(encoding=3, text=song.date))  # type: ignore\n    audio.tags.add(  # type: ignore\n        TRCK(encoding=3, text=f\"{song.track_number}/{song.tracks_count}\")  # type: ignore\n    )\n    audio.tags.add(TDRC(encoding=3, text=song.date))  # type: ignore\n    audio.tags.add(WOAS(encoding=3, text=song.url))  # type: ignore\n    audio.tags.add(TSRC(encoding=3, text=song.isrc))  # type: ignore\n\n    if song.download_url:\n        audio.tags.add(COMM(encoding=3, text=song.download_url))  # type: ignore\n\n    if song.copyright_text:\n        audio.tags.add(TCOP(encoding=3, text=song.copyright_text))  # type: ignore\n\n    if song.popularity:\n        audio.tags.add(  # type: ignore\n            COMM(\n                encoding=3,\n                lang=\"eng\",\n                text=\"Spotify Popularity: \" + str(song.popularity),\n            )\n        )\n\n    if song.cover_url:\n        try:\n            cover_data = requests.get(song.cover_url, timeout=10).content\n            audio.tags.add(  # type: ignore\n                APIC(\n                    encoding=3, mime=\"image/jpeg\", type=3, desc=\"Cover\", data=cover_data\n                )\n            )\n        except Exception:\n            pass\n\n    if song.lyrics:\n        # Check if the lyrics are in lrc format\n        # using regex on the first 5 lines\n        lrc_lines = song.lyrics.splitlines()[:5]\n        lrc_lines = [line for line in lrc_lines if line and LRC_REGEX.match(line)]\n\n        if len(lrc_lines) == 0:\n            audio.tags.add(USLT(encoding=Encoding.UTF8, text=song.lyrics))  # type: ignore\n        else:\n            lrc_data = []\n            clean_lyrics = remomve_lrc(song.lyrics)\n            for line in song.lyrics.splitlines():\n                time_tag = line.split(\"]\", 1)[0] + \"]\"\n                text = line.replace(time_tag, \"\")\n\n                time_tag = time_tag.replace(\"[\", \"\")\n                time_tag = time_tag.replace(\"]\", \"\")\n                time_tag = time_tag.replace(\".\", \":\")\n                time_tag_vals = time_tag.split(\":\")\n                if len(time_tag_vals) != 3 or any(\n                    not isinstance(tag, int) for tag in time_tag_vals\n                ):\n                    continue\n\n                minute, sec, millisecond = time_tag_vals\n                time = to_ms(min=minute, sec=sec, ms=millisecond)\n                lrc_data.append((text, time))\n\n            audio.tags.add(USLT(encoding=3, text=clean_lyrics))  # type: ignore\n            audio.tags.add(SYLT(encoding=3, text=lrc_data, format=2, type=1))  # type: ignore\n\n    audio.save()\n</code></pre>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.get_file_metadata","title":"<code>get_file_metadata(path, id3_separator='/')</code>","text":"<p>Get song metadata.</p>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.get_file_metadata--arguments","title":"Arguments","text":"<ul> <li>path: Path to the song.</li> </ul>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.get_file_metadata--returns","title":"Returns","text":"<ul> <li>Dict of song metadata.</li> </ul>"},{"location":"reference/utils/metadata/#spotdl.utils.metadata.get_file_metadata--raises","title":"Raises","text":"<ul> <li>OSError: If the file is not found.</li> <li>MetadataError: If the file is not a valid audio file.</li> </ul> Source code in <code>spotdl/utils/metadata.py</code> <pre><code>def get_file_metadata(path: Path, id3_separator: str = \"/\") -&gt; Optional[Dict[str, Any]]:\n    \"\"\"\n    Get song metadata.\n\n    ### Arguments\n    - path: Path to the song.\n\n    ### Returns\n    - Dict of song metadata.\n\n    ### Raises\n    - OSError: If the file is not found.\n    - MetadataError: If the file is not a valid audio file.\n    \"\"\"\n\n    if path.exists() is False:\n        raise OSError(f\"File not found: {path}\")\n\n    audio_file = File(str(path.resolve()))\n\n    if audio_file is None or audio_file == {}:\n        return None\n\n    song_meta: Dict[str, Any] = {}\n    for key in TAG_PRESET:\n        if path.suffix == \".m4a\":\n            val = audio_file.get(M4A_TAG_PRESET[key])\n        elif path.suffix == \".mp3\":\n            val = audio_file.get(MP3_TAG_PRESET[key])\n        else:\n            val = audio_file.get(key)\n\n        # Cover art is a special case and\n        # has to be handled before checking the val\n        # M4A is handled in the m4a section since it\n        # has data in the val variable\n        if key == \"albumart\":\n            if path.suffix == \".mp3\":\n                cover = audio_file.get(\"APIC:Cover\")\n                if cover:\n                    song_meta[\"album_art\"] = cover.data\n                else:\n                    song_meta[\"album_art\"] = None\n\n                continue\n\n            if path.suffix == \".flac\":\n                if audio_file.pictures:\n                    song_meta[\"album_art\"] = audio_file.pictures[0].data\n                else:\n                    song_meta[\"album_art\"] = None\n\n                continue\n\n            if path.suffix in [\".ogg\", \".opus\"]:\n                pictures = audio_file.get(\"metadata_block_picture\")\n                if pictures and pictures[0]:\n                    song_meta[\"album_art\"] = pictures[0]\n                else:\n                    song_meta[\"album_art\"] = None\n\n                continue\n\n        # If the tag is empty, skip it\n        if val is None:\n            # If the tag is empty but it's key is in the\n            # song object, set it to None\n            empty_key = TAG_TO_SONG.get(key)\n            if empty_key:\n                song_meta[empty_key] = None\n\n            continue\n\n        # MP3 specific decoding\n        if path.suffix == \".mp3\":\n            if key == \"woas\":\n                song_meta[\"url\"] = val.url\n            elif key == \"comment\":\n                song_meta[\"download_url\"] = val.text[0]\n            elif key == \"year\":\n                song_meta[\"year\"] = int(str(val.text[0])[:4])\n            elif key == \"date\":\n                song_meta[\"date\"] = str(val.text[0])\n            elif key in [\"tracknumber\", \"trackcount\"]:\n                count = val.text[0].split(id3_separator)\n                if len(count) == 2:\n                    song_meta[\"track_number\"] = int(count[0])\n                    song_meta[\"tracks_count\"] = int(count[1])\n                else:\n                    song_meta[\"track_number\"] = val.text[0]\n            elif key in [\"discnumber\", \"disccount\"]:\n                count = val.text[0].split(id3_separator)\n                if len(count) == 2:\n                    song_meta[\"disc_number\"] = int(count[0])\n                    song_meta[\"disc_count\"] = int(count[1])\n                else:\n                    song_meta[\"disc_number\"] = val.text[0]\n            elif key == \"artist\":\n                artists_val: str = (\n                    val.text[0] if isinstance(val.text, list) else val.text\n                )\n                song_meta[\"artists\"] = artists_val.split(id3_separator)\n            else:\n                meta_key = TAG_TO_SONG.get(key)\n                if meta_key and song_meta.get(meta_key) is None:\n                    song_meta[meta_key] = (\n                        val.text[0]\n                        if isinstance(val.text, list) and len(val.text) == 1\n                        else val.text\n                    )\n\n        # M4A specific decoding\n        elif path.suffix == \".m4a\":\n            if key == \"artist\":\n                song_meta[\"artists\"] = val\n            elif key == \"woas\":\n                song_meta[\"url\"] = val[0].decode(\"utf-8\")\n            elif key == \"explicit\":\n                song_meta[\"explicit\"] = val == [4] if val else None\n            elif key == \"year\":\n                song_meta[\"year\"] = int(str(val[0])[:4])\n            elif key == \"discnumber\":\n                song_meta[\"disc_number\"] = val[0][0]\n                song_meta[\"disc_count\"] = val[0][1]\n            elif key == \"tracknumber\":\n                song_meta[\"track_number\"] = val[0][0]\n                song_meta[\"tracks_count\"] = val[0][1]\n            else:\n                meta_key = TAG_TO_SONG.get(key)\n                if meta_key:\n                    song_meta[meta_key] = (\n                        val[0] if isinstance(val, list) and len(val) == 1 else val\n                    )\n\n        # FLAC, OGG, OPUS specific decoding\n        else:\n            if key == \"artist\":\n                song_meta[\"artists\"] = val\n            elif key == \"tracknumber\":\n                song_meta[\"track_number\"] = int(val[0])\n            elif key == \"discnumber\":\n                song_meta[\"disc_count\"] = int(val[0])\n                song_meta[\"disc_number\"] = int(val[0])\n            else:\n                meta_key = TAG_TO_SONG.get(key)\n                if meta_key:\n                    song_meta[meta_key] = (\n                        val[0] if isinstance(val, list) and len(val) == 1 else val\n                    )\n\n    # Make sure that artists is a list\n    if isinstance(song_meta[\"artists\"], str):\n        song_meta[\"artists\"] = [song_meta[\"artists\"]]\n    elif song_meta[\"artists\"] is not None:\n        song_meta[\"artists\"] = list(song_meta[\"artists\"])\n    else:\n        song_meta[\"artists\"] = []\n\n    # Make sure that genres is a list\n    if isinstance(song_meta[\"genres\"], str):\n        song_meta[\"genres\"] = [song_meta[\"genres\"]]\n\n    # Add main artist to the song meta object\n    if song_meta[\"artists\"]:\n        song_meta[\"artist\"] = song_meta[\"artists\"][0]\n    else:\n        song_meta[\"artist\"] = None\n\n    return song_meta\n</code></pre>"},{"location":"reference/utils/search/","title":"search","text":"<p>Module for creating Song objects by interacting with Spotify API or by parsing a query.</p> <p>To use this module you must first initialize the SpotifyClient.</p>"},{"location":"reference/utils/search/#spotdl.utils.search.QueryError","title":"<code>QueryError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all exceptions related to query.</p>"},{"location":"reference/utils/search/#spotdl.utils.search.create_ytm_album","title":"<code>create_ytm_album(url, fetch_songs=True)</code>","text":"<p>Creates a list of Song objects from an album query.</p>"},{"location":"reference/utils/search/#spotdl.utils.search.create_ytm_album--arguments","title":"Arguments","text":"<ul> <li>album_query: the url of the album</li> </ul>"},{"location":"reference/utils/search/#spotdl.utils.search.create_ytm_album--returns","title":"Returns","text":"<ul> <li>a list of Song objects</li> </ul> Source code in <code>spotdl/utils/search.py</code> <pre><code>def create_ytm_album(url: str, fetch_songs: bool = True) -&gt; Album:\n    \"\"\"\n    Creates a list of Song objects from an album query.\n\n    ### Arguments\n    - album_query: the url of the album\n\n    ### Returns\n    - a list of Song objects\n    \"\"\"\n\n    if \"?list=\" not in url or not url.startswith(\"https://music.youtube.com/\"):\n        raise ValueError(f\"Invalid album url: {url}\")\n\n    browse_id = get_ytm_client().get_album_browse_id(\n        url.split(\"?list=\")[1].split(\"&amp;\")[0]\n    )\n    if browse_id is None:\n        raise ValueError(f\"Invalid album url: {url}\")\n\n    album = get_ytm_client().get_album(browse_id)\n\n    if album is None:\n        raise ValueError(f\"Couldn't fetch album: {url}\")\n\n    metadata = {\n        \"artist\": album[\"artists\"][0][\"name\"],\n        \"name\": album[\"title\"],\n        \"url\": url,\n    }\n\n    songs = []\n    for track in album[\"tracks\"]:\n        artists = [artist[\"name\"] for artist in track[\"artists\"]]\n\n        song = Song.from_missing_data(\n            name=track[\"title\"],\n            artists=artists,\n            artist=artists[0],\n            album_name=metadata[\"name\"],\n            album_artist=metadata[\"artist\"],\n            duration=track[\"duration_seconds\"],\n            download_url=f\"https://music.youtube.com/watch?v={track['videoId']}\",\n        )\n\n        if fetch_songs:\n            song = Song.from_search_term(f\"{song.artist} - {song.name}\")\n\n        songs.append(song)\n\n    return Album(**metadata, songs=songs, urls=[song.url for song in songs])\n</code></pre>"},{"location":"reference/utils/search/#spotdl.utils.search.create_ytm_playlist","title":"<code>create_ytm_playlist(url, fetch_songs=True)</code>","text":"<p>Returns a playlist object from a youtube playlist url</p>"},{"location":"reference/utils/search/#spotdl.utils.search.create_ytm_playlist--arguments","title":"Arguments","text":"<ul> <li>url: the url of the playlist</li> </ul>"},{"location":"reference/utils/search/#spotdl.utils.search.create_ytm_playlist--returns","title":"Returns","text":"<ul> <li>a Playlist object</li> </ul> Source code in <code>spotdl/utils/search.py</code> <pre><code>def create_ytm_playlist(url: str, fetch_songs: bool = True) -&gt; Playlist:\n    \"\"\"\n    Returns a playlist object from a youtube playlist url\n\n    ### Arguments\n    - url: the url of the playlist\n\n    ### Returns\n    - a Playlist object\n    \"\"\"\n\n    if not (\"?list=\" in url or \"/browse/VLPL\" in url) or not url.startswith(\n        \"https://music.youtube.com/\"\n    ):\n        raise ValueError(f\"Invalid playlist url: {url}\")\n\n    if \"/browse/VLPL\" in url:\n        playlist_id = url.split(\"/browse/\")[1]\n    else:\n        playlist_id = url.split(\"?list=\")[1]\n    playlist = get_ytm_client().get_playlist(playlist_id, None)  # type: ignore\n\n    if playlist is None:\n        raise ValueError(f\"Couldn't fetch playlist: {url}\")\n\n    metadata = {\n        \"description\": (\n            playlist[\"description\"] if playlist[\"description\"] is not None else \"\"\n        ),\n        \"author_url\": (\n            f\"https://music.youtube.com/channel/{playlist['author']['id']}\"\n            if playlist.get(\"author\") is not None\n            else \"Missing author url\"\n        ),\n        \"author_name\": (\n            playlist[\"author\"][\"name\"]\n            if playlist.get(\"author\") is not None\n            else \"Missing author\"\n        ),\n        \"cover_url\": (\n            playlist[\"thumbnails\"][0][\"url\"]\n            if playlist.get(\"thumbnails\") is not None\n            else \"Missing thumbnails\"\n        ),\n        \"name\": playlist[\"title\"],\n        \"url\": url,\n    }\n\n    songs = []\n    for track in playlist[\"tracks\"]:\n        if track[\"videoId\"] is None or track[\"isAvailable\"] is False:\n            continue\n\n        song = Song.from_missing_data(\n            name=track[\"title\"],\n            artists=(\n                [artist[\"name\"] for artist in track[\"artists\"]]\n                if track.get(\"artists\") is not None\n                else []\n            ),\n            artist=(\n                track[\"artists\"][0][\"name\"]\n                if track.get(\"artists\") is not None\n                else None\n            ),\n            album_name=(\n                track.get(\"album\", {}).get(\"name\")\n                if track.get(\"album\") is not None\n                else None\n            ),\n            duration=track.get(\"duration_seconds\"),\n            explicit=track.get(\"isExplicit\"),\n            download_url=f\"https://music.youtube.com/watch?v={track['videoId']}\",\n        )\n\n        if fetch_songs:\n            song = reinit_song(song)\n\n        songs.append(song)\n\n    return Playlist(**metadata, songs=songs, urls=[song.url for song in songs])\n</code></pre>"},{"location":"reference/utils/search/#spotdl.utils.search.gather_known_songs","title":"<code>gather_known_songs(output, output_format)</code>","text":"<p>Gather all known songs from the output directory</p>"},{"location":"reference/utils/search/#spotdl.utils.search.gather_known_songs--arguments","title":"Arguments","text":"<ul> <li>output: Output path template</li> <li>output_format: Output format</li> </ul>"},{"location":"reference/utils/search/#spotdl.utils.search.gather_known_songs--returns","title":"Returns","text":"<ul> <li>Dictionary containing all known songs and their paths</li> </ul> Source code in <code>spotdl/utils/search.py</code> <pre><code>def gather_known_songs(output: str, output_format: str) -&gt; Dict[str, List[Path]]:\n    \"\"\"\n    Gather all known songs from the output directory\n\n    ### Arguments\n    - output: Output path template\n    - output_format: Output format\n\n    ### Returns\n    - Dictionary containing all known songs and their paths\n    \"\"\"\n\n    # Get the base directory from the path template\n    # Path(\"/Music/test/{artist}/{artists} - {title}.{output-ext}\") -&gt; \"/Music/test\"\n    base_dir = output.split(\"{\", 1)[0]\n    paths = Path(base_dir).glob(f\"**/*.{output_format}\")\n\n    known_songs: Dict[str, List[Path]] = {}\n    for path in paths:\n        # Try to get the song from the metadata\n        song = get_song_from_file_metadata(path)\n\n        # If the songs doesn't have metadata, try to get it from the filename\n        if song is None or song.url is None:\n            search_results = get_search_results(path.stem)\n            if len(search_results) == 0:\n                continue\n\n            song = search_results[0]\n\n        known_paths = known_songs.get(song.url)\n        if known_paths is None:\n            known_songs[song.url] = [path]\n        else:\n            known_songs[song.url].append(path)\n\n    return known_songs\n</code></pre>"},{"location":"reference/utils/search/#spotdl.utils.search.get_all_saved_playlists","title":"<code>get_all_saved_playlists()</code>","text":"<p>Get all user playlists.</p>"},{"location":"reference/utils/search/#spotdl.utils.search.get_all_saved_playlists--args-optional","title":"Args (optional)","text":"<ul> <li>user_url: Spotify user profile url.     If a url is mentioned, get all public playlists of that specific user.</li> </ul>"},{"location":"reference/utils/search/#spotdl.utils.search.get_all_saved_playlists--returns","title":"Returns","text":"<ul> <li>List of all user playlists</li> </ul> Source code in <code>spotdl/utils/search.py</code> <pre><code>def get_all_saved_playlists() -&gt; List[Playlist]:\n    \"\"\"\n    Get all user playlists.\n\n    ### Args (optional)\n    - user_url: Spotify user profile url.\n        If a url is mentioned, get all public playlists of that specific user.\n\n    ### Returns\n    - List of all user playlists\n    \"\"\"\n\n    spotify_client = SpotifyClient()\n    if spotify_client.user_auth is False:  # type: ignore\n        raise SpotifyError(\"You must be logged in to use this function\")\n\n    user_playlists_response = spotify_client.current_user_playlists()\n\n    if user_playlists_response is None:\n        raise SpotifyError(\"Couldn't get user playlists\")\n\n    user_playlists = user_playlists_response[\"items\"]\n    user_id = user_playlists_response[\"href\"].split(\"users/\")[-1].split(\"/\")[0]\n\n    # Fetch all saved tracks\n    while user_playlists_response and user_playlists_response[\"next\"]:\n        response = spotify_client.next(user_playlists_response)\n        if response is None:\n            break\n\n        user_playlists_response = response\n        user_playlists.extend(user_playlists_response[\"items\"])\n\n    return [\n        Playlist.from_url(playlist[\"external_urls\"][\"spotify\"], fetch_songs=False)\n        for playlist in user_playlists\n        if playlist[\"owner\"][\"id\"] != user_id\n    ]\n</code></pre>"},{"location":"reference/utils/search/#spotdl.utils.search.get_all_user_playlists","title":"<code>get_all_user_playlists(user_url='')</code>","text":"<p>Get all user playlists.</p>"},{"location":"reference/utils/search/#spotdl.utils.search.get_all_user_playlists--args-optional","title":"Args (optional)","text":"<ul> <li>user_url: Spotify user profile url.     If a url is mentioned, get all public playlists of that specific user.</li> </ul>"},{"location":"reference/utils/search/#spotdl.utils.search.get_all_user_playlists--returns","title":"Returns","text":"<ul> <li>List of all user playlists</li> </ul> Source code in <code>spotdl/utils/search.py</code> <pre><code>def get_all_user_playlists(user_url: str = \"\") -&gt; List[Playlist]:\n    \"\"\"\n    Get all user playlists.\n\n    ### Args (optional)\n    - user_url: Spotify user profile url.\n        If a url is mentioned, get all public playlists of that specific user.\n\n    ### Returns\n    - List of all user playlists\n    \"\"\"\n\n    spotify_client = SpotifyClient()\n    if spotify_client.user_auth is False:  # type: ignore\n        raise SpotifyError(\"You must be logged in to use this function\")\n\n    if user_url and not user_url.startswith(\"https://open.spotify.com/user/\"):\n        raise ValueError(f\"Invalid user profile url: {user_url}\")\n\n    user_id = user_url.split(\"https://open.spotify.com/user/\")[-1].replace(\"/\", \"\")\n\n    if user_id:\n        user_playlists_response = spotify_client.user_playlists(user_id)\n    else:\n        user_playlists_response = spotify_client.current_user_playlists()\n        user_resp = spotify_client.current_user()\n        if user_resp is None:\n            raise SpotifyError(\"Couldn't get user info\")\n\n        user_id = user_resp[\"id\"]\n\n    if user_playlists_response is None:\n        raise SpotifyError(\"Couldn't get user playlists\")\n\n    user_playlists = user_playlists_response[\"items\"]\n\n    # Fetch all saved tracks\n    while user_playlists_response and user_playlists_response[\"next\"]:\n        response = spotify_client.next(user_playlists_response)\n        if response is None:\n            break\n\n        user_playlists_response = response\n        user_playlists.extend(user_playlists_response[\"items\"])\n\n    return [\n        Playlist.from_url(playlist[\"external_urls\"][\"spotify\"], fetch_songs=False)\n        for playlist in user_playlists\n        if playlist[\"owner\"][\"id\"] == user_id\n    ]\n</code></pre>"},{"location":"reference/utils/search/#spotdl.utils.search.get_search_results","title":"<code>get_search_results(search_term)</code>","text":"<p>Creates a list of Song objects from a search term.</p>"},{"location":"reference/utils/search/#spotdl.utils.search.get_search_results--arguments","title":"Arguments","text":"<ul> <li>search_term: the search term to use</li> </ul>"},{"location":"reference/utils/search/#spotdl.utils.search.get_search_results--returns","title":"Returns","text":"<ul> <li>a list of Song objects</li> </ul> Source code in <code>spotdl/utils/search.py</code> <pre><code>def get_search_results(search_term: str) -&gt; List[Song]:\n    \"\"\"\n    Creates a list of Song objects from a search term.\n\n    ### Arguments\n    - search_term: the search term to use\n\n    ### Returns\n    - a list of Song objects\n    \"\"\"\n\n    return Song.list_from_search_term(search_term)\n</code></pre>"},{"location":"reference/utils/search/#spotdl.utils.search.get_simple_songs","title":"<code>get_simple_songs(query, use_ytm_data=False, playlist_numbering=False, albums_to_ignore=None, album_type=None, playlist_retain_track_cover=False)</code>","text":"<p>Parse query and return list containing simple song objects</p>"},{"location":"reference/utils/search/#spotdl.utils.search.get_simple_songs--arguments","title":"Arguments","text":"<ul> <li>query: List of strings containing query</li> </ul>"},{"location":"reference/utils/search/#spotdl.utils.search.get_simple_songs--returns","title":"Returns","text":"<ul> <li>List of simple song objects</li> </ul> Source code in <code>spotdl/utils/search.py</code> <pre><code>def get_simple_songs(\n    query: List[str],\n    use_ytm_data: bool = False,\n    playlist_numbering: bool = False,\n    albums_to_ignore=None,\n    album_type=None,\n    playlist_retain_track_cover: bool = False,\n) -&gt; List[Song]:\n    \"\"\"\n    Parse query and return list containing simple song objects\n\n    ### Arguments\n    - query: List of strings containing query\n\n    ### Returns\n    - List of simple song objects\n    \"\"\"\n\n    songs: List[Song] = []\n    lists: List[SongList] = []\n    for request in query:\n        logger.info(\"Processing query: %s\", request)\n\n        # Remove /intl-xxx/ from Spotify URLs with regex\n        request = re.sub(r\"\\/intl-\\w+\\/\", \"/\", request)\n\n        if (\n            (  # pylint: disable=too-many-boolean-expressions\n                \"watch?v=\" in request\n                or \"youtu.be/\" in request\n                or \"soundcloud.com/\" in request\n                or \"bandcamp.com/\" in request\n            )\n            and \"open.spotify.com\" in request\n            and \"track\" in request\n            and \"|\" in request\n        ):\n            split_urls = request.split(\"|\")\n            if (\n                len(split_urls) &lt;= 1\n                or not (\n                    \"watch?v=\" in split_urls[0]\n                    or \"youtu.be\" in split_urls[0]\n                    or \"soundcloud.com/\" in split_urls[0]\n                    or \"bandcamp.com/\" in split_urls[0]\n                )\n                or \"spotify\" not in split_urls[1]\n            ):\n                raise QueryError(\n                    'Incorrect format used, please use \"YouTubeURL|SpotifyURL\"'\n                )\n\n            songs.append(\n                Song.from_missing_data(url=split_urls[1], download_url=split_urls[0])\n            )\n        elif \"music.youtube.com/watch?v\" in request:\n            track_data = get_ytm_client().get_song(request.split(\"?v=\", 1)[1])\n\n            yt_song = Song.from_search_term(\n                f\"{track_data['videoDetails']['author']} - {track_data['videoDetails']['title']}\"\n            )\n\n            if use_ytm_data:\n                yt_song.name = track_data[\"title\"]\n                yt_song.artist = track_data[\"author\"]\n                yt_song.artists = [track_data[\"author\"]]\n                yt_song.duration = track_data[\"lengthSeconds\"]\n\n            yt_song.download_url = request\n            songs.append(yt_song)\n        elif (\n            \"youtube.com/playlist?list=\" in request\n            or \"youtube.com/browse/VLPL\" in request\n        ):\n            request = request.replace(\n                \"https://www.youtube.com/\", \"https://music.youtube.com/\"\n            )\n            request = request.replace(\n                \"https://youtube.com/\", \"https://music.youtube.com/\"\n            )\n\n            split_urls = request.split(\"|\")\n            if len(split_urls) == 1:\n                if \"?list=OLAK5uy_\" in request:\n                    lists.append(create_ytm_album(request, fetch_songs=False))\n                elif \"?list=PL\" in request or \"browse/VLPL\" in request:\n                    lists.append(create_ytm_playlist(request, fetch_songs=False))\n            else:\n                if (\"spotify\" not in split_urls[1]) or not any(\n                    x in split_urls[0]\n                    for x in [\"?list=PL\", \"?list=OLAK5uy_\", \"browse/VLPL\"]\n                ):\n                    raise QueryError(\n                        'Incorrect format used, please use \"YouTubeMusicURL|SpotifyURL\". '\n                        \"Currently only supports YouTube Music playlists and albums.\"\n                    )\n\n                if (\"open.spotify.com\" in request and \"album\" in request) and (\n                    \"?list=OLAK5uy_\" in request\n                ):\n                    ytm_list: SongList = create_ytm_album(\n                        split_urls[0], fetch_songs=False\n                    )\n                    spot_list = Album.from_url(split_urls[1], fetch_songs=False)\n                elif (\"open.spotify.com\" in request and \"playlist\" in request) and (\n                    \"?list=PL\" in request or \"browse/VLPL\" in request\n                ):\n                    ytm_list = create_ytm_playlist(split_urls[0], fetch_songs=False)\n                    spot_list = Playlist.from_url(split_urls[1], fetch_songs=False)\n                else:\n                    raise QueryError(\n                        f\"URLs are not of the same type, {split_urls[0]} is not \"\n                        f\"the same type as {split_urls[1]}.\"\n                    )\n\n                if ytm_list.length != spot_list.length:\n                    raise QueryError(\n                        f\"The YouTube Music ({ytm_list.length}) \"\n                        f\"and Spotify ({spot_list.length}) lists have different lengths. \"\n                    )\n\n                if use_ytm_data:\n                    for index, song in enumerate(ytm_list.songs):\n                        song.url = spot_list.songs[index].url\n\n                    lists.append(ytm_list)\n                else:\n                    for index, song in enumerate(spot_list.songs):\n                        song.download_url = ytm_list.songs[index].download_url\n\n                    lists.append(spot_list)\n        elif \"open.spotify.com\" in request and \"track\" in request:\n            songs.append(Song.from_url(url=request))\n        elif \"https://spotify.link/\" in request:\n            resp = requests.head(request, allow_redirects=True, timeout=10)\n            full_url = resp.url\n            full_lists = get_simple_songs(\n                [full_url],\n                use_ytm_data=use_ytm_data,\n                playlist_numbering=playlist_numbering,\n                album_type=album_type,\n                playlist_retain_track_cover=playlist_retain_track_cover,\n            )\n            songs.extend(full_lists)\n        elif \"open.spotify.com\" in request and \"playlist\" in request:\n            lists.append(Playlist.from_url(request, fetch_songs=False))\n        elif \"open.spotify.com\" in request and \"album\" in request:\n            lists.append(Album.from_url(request, fetch_songs=False))\n        elif \"open.spotify.com\" in request and \"artist\" in request:\n            lists.append(Artist.from_url(request, fetch_songs=False))\n        elif \"open.spotify.com\" in request and \"user\" in request:\n            lists.extend(get_all_user_playlists(request))\n        elif \"album:\" in request:\n            lists.append(Album.from_search_term(request, fetch_songs=False))\n        elif \"playlist:\" in request:\n            lists.append(Playlist.from_search_term(request, fetch_songs=False))\n        elif \"artist:\" in request:\n            lists.append(Artist.from_search_term(request, fetch_songs=False))\n        elif request == \"saved\":\n            lists.append(Saved.from_url(request, fetch_songs=False))\n        elif request == \"all-user-playlists\":\n            lists.extend(get_all_user_playlists())\n        elif request == \"all-user-followed-artists\":\n            lists.extend(get_user_followed_artists())\n        elif request == \"all-user-saved-albums\":\n            lists.extend(get_user_saved_albums())\n        elif request == \"all-saved-playlists\":\n            lists.extend(get_all_saved_playlists())\n        elif request.endswith(\".spotdl\"):\n            with open(request, \"r\", encoding=\"utf-8\") as save_file:\n                for track in json.load(save_file):\n                    # Append to songs\n                    songs.append(Song.from_dict(track))\n        else:\n            songs.append(Song.from_search_term(request))\n\n    for song_list in lists:\n        logger.info(\n            \"Found %s songs in %s (%s)\",\n            len(song_list.urls),\n            song_list.name,\n            song_list.__class__.__name__,\n        )\n\n        for index, song in enumerate(song_list.songs):\n            song_data = song.json\n            song_data[\"list_name\"] = song_list.name\n            song_data[\"list_url\"] = song_list.url\n            song_data[\"list_position\"] = song.list_position\n            song_data[\"list_length\"] = song_list.length\n\n            if playlist_numbering:\n                song_data[\"track_number\"] = song_data[\"list_position\"]\n                song_data[\"tracks_count\"] = song_data[\"list_length\"]\n                song_data[\"album_name\"] = song_data[\"list_name\"]\n                song_data[\"disc_number\"] = 1\n                song_data[\"disc_count\"] = 1\n                if isinstance(song_list, Playlist):\n                    song_data[\"album_artist\"] = song_list.author_name\n                    song_data[\"cover_url\"] = song_list.cover_url\n\n            if playlist_retain_track_cover:\n                song_data[\"track_number\"] = song_data[\"list_position\"]\n                song_data[\"tracks_count\"] = song_data[\"list_length\"]\n                song_data[\"album_name\"] = song_data[\"list_name\"]\n                song_data[\"disc_number\"] = 1\n                song_data[\"disc_count\"] = 1\n                song_data[\"cover_url\"] = song_data[\"cover_url\"]\n                if isinstance(song_list, Playlist):\n                    song_data[\"album_artist\"] = song_list.author_name\n\n            songs.append(Song.from_dict(song_data))\n\n    # removing songs for --ignore-albums\n    original_length = len(songs)\n    if albums_to_ignore:\n        songs = [\n            song\n            for song in songs\n            if all(\n                keyword not in song.album_name.lower() for keyword in albums_to_ignore\n            )\n        ]\n        logger.info(\"Skipped %s songs (Ignored albums)\", (original_length - len(songs)))\n\n    if album_type:\n        songs = [song for song in songs if song.album_type == album_type]\n\n        logger.info(\n            \"Skipped %s songs for Album Type %s\",\n            (original_length - len(songs)),\n            album_type,\n        )\n\n    logger.debug(\"Found %s songs in %s lists\", len(songs), len(lists))\n\n    return songs\n</code></pre>"},{"location":"reference/utils/search/#spotdl.utils.search.get_song_from_file_metadata","title":"<code>get_song_from_file_metadata(file, id3_separator='/')</code>","text":"<p>Get song based on the file metadata or file name</p>"},{"location":"reference/utils/search/#spotdl.utils.search.get_song_from_file_metadata--arguments","title":"Arguments","text":"<ul> <li>file: Path to file</li> </ul>"},{"location":"reference/utils/search/#spotdl.utils.search.get_song_from_file_metadata--returns","title":"Returns","text":"<ul> <li>Song object</li> </ul> Source code in <code>spotdl/utils/search.py</code> <pre><code>def get_song_from_file_metadata(file: Path, id3_separator: str = \"/\") -&gt; Optional[Song]:\n    \"\"\"\n    Get song based on the file metadata or file name\n\n    ### Arguments\n    - file: Path to file\n\n    ### Returns\n    - Song object\n    \"\"\"\n\n    file_metadata = get_file_metadata(file, id3_separator)\n\n    if file_metadata is None:\n        return None\n\n    return Song.from_missing_data(**file_metadata)\n</code></pre>"},{"location":"reference/utils/search/#spotdl.utils.search.get_user_followed_artists","title":"<code>get_user_followed_artists()</code>","text":"<p>Get all user playlists</p>"},{"location":"reference/utils/search/#spotdl.utils.search.get_user_followed_artists--returns","title":"Returns","text":"<ul> <li>List of all user playlists</li> </ul> Source code in <code>spotdl/utils/search.py</code> <pre><code>def get_user_followed_artists() -&gt; List[Artist]:\n    \"\"\"\n    Get all user playlists\n\n    ### Returns\n    - List of all user playlists\n    \"\"\"\n\n    spotify_client = SpotifyClient()\n    if spotify_client.user_auth is False:  # type: ignore\n        raise SpotifyError(\"You must be logged in to use this function\")\n\n    user_followed_response = spotify_client.current_user_followed_artists()\n    if user_followed_response is None:\n        raise SpotifyError(\"Couldn't get user followed artists\")\n\n    user_followed_response = user_followed_response[\"artists\"]\n    user_followed = user_followed_response[\"items\"]\n\n    # Fetch all artists\n    while user_followed_response and user_followed_response[\"next\"]:\n        response = spotify_client.next(user_followed_response)\n        if response is None:\n            break\n\n        user_followed_response = response[\"artists\"]\n        user_followed.extend(user_followed_response[\"items\"])\n\n    return [\n        Artist.from_url(followed_artist[\"external_urls\"][\"spotify\"], fetch_songs=False)\n        for followed_artist in user_followed\n    ]\n</code></pre>"},{"location":"reference/utils/search/#spotdl.utils.search.get_user_saved_albums","title":"<code>get_user_saved_albums()</code>","text":"<p>Get all user saved albums</p>"},{"location":"reference/utils/search/#spotdl.utils.search.get_user_saved_albums--returns","title":"Returns","text":"<ul> <li>List of all user saved albums</li> </ul> Source code in <code>spotdl/utils/search.py</code> <pre><code>def get_user_saved_albums() -&gt; List[Album]:\n    \"\"\"\n    Get all user saved albums\n\n    ### Returns\n    - List of all user saved albums\n    \"\"\"\n\n    spotify_client = SpotifyClient()\n    if spotify_client.user_auth is False:  # type: ignore\n        raise SpotifyError(\"You must be logged in to use this function\")\n\n    user_saved_albums_response = spotify_client.current_user_saved_albums()\n    if user_saved_albums_response is None:\n        raise SpotifyError(\"Couldn't get user saved albums\")\n\n    user_saved_albums = user_saved_albums_response[\"items\"]\n\n    # Fetch all saved tracks\n    while user_saved_albums_response and user_saved_albums_response[\"next\"]:\n        response = spotify_client.next(user_saved_albums_response)\n        if response is None:\n            break\n\n        user_saved_albums_response = response\n        user_saved_albums.extend(user_saved_albums_response[\"items\"])\n\n    return [\n        Album.from_url(item[\"album\"][\"external_urls\"][\"spotify\"], fetch_songs=False)\n        for item in user_saved_albums\n    ]\n</code></pre>"},{"location":"reference/utils/search/#spotdl.utils.search.get_ytm_client","title":"<code>get_ytm_client()</code>","text":"<p>Lazily initialize the YTMusic client.</p>"},{"location":"reference/utils/search/#spotdl.utils.search.get_ytm_client--returns","title":"Returns","text":"<ul> <li>the YTMusic client</li> </ul> Source code in <code>spotdl/utils/search.py</code> <pre><code>def get_ytm_client() -&gt; YTMusic:\n    \"\"\"\n    Lazily initialize the YTMusic client.\n\n    ### Returns\n    - the YTMusic client\n    \"\"\"\n\n    global client  # pylint: disable=global-statement\n    if client is None:\n        client = YTMusic()\n\n    return client\n</code></pre>"},{"location":"reference/utils/search/#spotdl.utils.search.parse_query","title":"<code>parse_query(query, threads=1, use_ytm_data=False, playlist_numbering=False, album_type=None, playlist_retain_track_cover=False)</code>","text":"<p>Parse query and return list containing song object</p>"},{"location":"reference/utils/search/#spotdl.utils.search.parse_query--arguments","title":"Arguments","text":"<ul> <li>query: List of strings containing query</li> <li>threads: Number of threads to use</li> </ul>"},{"location":"reference/utils/search/#spotdl.utils.search.parse_query--returns","title":"Returns","text":"<ul> <li>List of song objects</li> </ul> Source code in <code>spotdl/utils/search.py</code> <pre><code>def parse_query(\n    query: List[str],\n    threads: int = 1,\n    use_ytm_data: bool = False,\n    playlist_numbering: bool = False,\n    album_type=None,\n    playlist_retain_track_cover: bool = False,\n) -&gt; List[Song]:\n    \"\"\"\n    Parse query and return list containing song object\n\n    ### Arguments\n    - query: List of strings containing query\n    - threads: Number of threads to use\n\n    ### Returns\n    - List of song objects\n    \"\"\"\n\n    songs: List[Song] = get_simple_songs(\n        query,\n        use_ytm_data=use_ytm_data,\n        playlist_numbering=playlist_numbering,\n        album_type=album_type,\n        playlist_retain_track_cover=playlist_retain_track_cover,\n    )\n\n    results = []\n    with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:\n        future_to_song = {executor.submit(reinit_song, song): song for song in songs}\n        for future in concurrent.futures.as_completed(future_to_song):\n            song = future_to_song[future]\n            try:\n                results.append(future.result())\n            except Exception as exc:\n                logger.error(\"%s generated an exception: %s\", song.display_name, exc)\n\n    return results\n</code></pre>"},{"location":"reference/utils/search/#spotdl.utils.search.reinit_song","title":"<code>reinit_song(song)</code>","text":"<p>Update song object with new data from Spotify</p>"},{"location":"reference/utils/search/#spotdl.utils.search.reinit_song--arguments","title":"Arguments","text":"<ul> <li>song: Song object</li> </ul>"},{"location":"reference/utils/search/#spotdl.utils.search.reinit_song--returns","title":"Returns","text":"<ul> <li>Updated song object</li> </ul> Source code in <code>spotdl/utils/search.py</code> <pre><code>def reinit_song(song: Song) -&gt; Song:\n    \"\"\"\n    Update song object with new data\n    from Spotify\n\n    ### Arguments\n    - song: Song object\n\n    ### Returns\n    - Updated song object\n    \"\"\"\n\n    data = song.json\n    if data.get(\"url\"):\n        new_data = Song.from_url(data[\"url\"]).json\n    elif data.get(\"song_id\"):\n        new_data = Song.from_url(\n            \"https://open.spotify.com/track/\" + data[\"song_id\"]\n        ).json\n    elif data.get(\"name\") and data.get(\"artist\"):\n        new_data = Song.from_search_term(f\"{data['artist']} - {data['name']}\").json\n    else:\n        raise QueryError(\"Song object is missing required data to be reinitialized\")\n\n    for key in Song.__dataclass_fields__:  # type: ignore # pylint: disable=E1101\n        val = data.get(key)\n        new_val = new_data.get(key)\n        if new_val is not None and val is None:\n            data[key] = new_val\n        elif new_val is not None and val is not None:\n            data[key] = val\n\n    # return reinitialized song object\n    return Song(**data)\n</code></pre>"},{"location":"reference/utils/search/#spotdl.utils.search.songs_from_albums","title":"<code>songs_from_albums(albums)</code>","text":"<p>Get all songs from albums ids/urls/etc.</p>"},{"location":"reference/utils/search/#spotdl.utils.search.songs_from_albums--arguments","title":"Arguments","text":"<ul> <li>albums: List of albums ids</li> </ul>"},{"location":"reference/utils/search/#spotdl.utils.search.songs_from_albums--returns","title":"Returns","text":"<ul> <li>List of songs</li> </ul> Source code in <code>spotdl/utils/search.py</code> <pre><code>def songs_from_albums(albums: List[str]):\n    \"\"\"\n    Get all songs from albums ids/urls/etc.\n\n    ### Arguments\n    - albums: List of albums ids\n\n    ### Returns\n    - List of songs\n    \"\"\"\n\n    songs: List[Song] = []\n    for album_id in albums:\n        album = Album.from_url(album_id, fetch_songs=False)\n\n        songs.extend([Song.from_missing_data(**song.json) for song in album.songs])\n\n    return songs\n</code></pre>"},{"location":"reference/utils/spotify/","title":"spotify","text":"<p>Module for interacting with Spotify API. To use this module, you must have a Spotify API key and Spotify API secret.</p> <pre><code>import spotdl.utils.spotify\nspotify.Spotify.init(client_id, client_secret)\n</code></pre>"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.Singleton","title":"<code>Singleton</code>","text":"<p>               Bases: <code>type</code></p> <p>Singleton metaclass for SpotifyClient. Ensures that SpotifyClient is not instantiated without prior initialization. Every other instantiation of SpotifyClient will return the same instance.</p>"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.Singleton.__call__","title":"<code>__call__()</code>","text":"<p>Call method for Singleton metaclass.</p>"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.Singleton.__call__--returns","title":"Returns","text":"<ul> <li>The instance of the SpotifyClient.</li> </ul> Source code in <code>spotdl/utils/spotify.py</code> <pre><code>def __call__(self):  # pylint: disable=bad-mcs-method-argument\n    \"\"\"\n    Call method for Singleton metaclass.\n\n    ### Returns\n    - The instance of the SpotifyClient.\n    \"\"\"\n\n    if self._instance is None:\n        raise SpotifyError(\n            \"Spotify client not created. Call SpotifyClient.init\"\n            \"(client_id, client_secret, user_auth, cache_path, no_cache, open_browser) first.\"\n        )\n    return self._instance\n</code></pre>"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.Singleton.init","title":"<code>init(client_id, client_secret, user_auth=False, no_cache=False, headless=False, max_retries=3, use_cache_file=False, auth_token=None, cache_path=None)</code>","text":"<p>Initializes the SpotifyClient.</p>"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.Singleton.init--arguments","title":"Arguments","text":"<ul> <li>client_id: The client ID of the application.</li> <li>client_secret: The client secret of the application.</li> <li>auth_token: The access token to use.</li> <li>user_auth: Whether or not to use user authentication.</li> <li>cache_path: The path to the cache file.</li> <li>no_cache: Whether or not to use the cache.</li> <li>open_browser: Whether or not to open the browser.</li> </ul>"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.Singleton.init--returns","title":"Returns","text":"<ul> <li>The instance of the SpotifyClient.</li> </ul> Source code in <code>spotdl/utils/spotify.py</code> <pre><code>def init(  # pylint: disable=bad-mcs-method-argument\n    self,\n    client_id: str,\n    client_secret: str,\n    user_auth: bool = False,\n    no_cache: bool = False,\n    headless: bool = False,\n    max_retries: int = 3,\n    use_cache_file: bool = False,\n    auth_token: Optional[str] = None,\n    cache_path: Optional[str] = None,\n) -&gt; \"Singleton\":\n    \"\"\"\n    Initializes the SpotifyClient.\n\n    ### Arguments\n    - client_id: The client ID of the application.\n    - client_secret: The client secret of the application.\n    - auth_token: The access token to use.\n    - user_auth: Whether or not to use user authentication.\n    - cache_path: The path to the cache file.\n    - no_cache: Whether or not to use the cache.\n    - open_browser: Whether or not to open the browser.\n\n    ### Returns\n    - The instance of the SpotifyClient.\n    \"\"\"\n\n    # check if initialization has been completed, if yes, raise an Exception\n    if isinstance(self._instance, self):\n        raise SpotifyError(\"A spotify client has already been initialized\")\n\n    credential_manager = None\n\n    cache_handler = (\n        CacheFileHandler(cache_path or get_cache_path())\n        if not no_cache\n        else MemoryCacheHandler()\n    )\n    # Use SpotifyOAuth as auth manager\n    if user_auth:\n        credential_manager = SpotifyOAuth(\n            client_id=client_id,\n            client_secret=client_secret,\n            redirect_uri=\"http://127.0.0.1:9900/\",\n            scope=\"user-library-read,user-follow-read,playlist-read-private\",\n            cache_handler=cache_handler,\n            open_browser=not headless,\n        )\n    # Use SpotifyClientCredentials as auth manager\n    else:\n        credential_manager = SpotifyClientCredentials(\n            client_id=client_id,\n            client_secret=client_secret,\n            cache_handler=cache_handler,\n        )\n    if auth_token is not None:\n        credential_manager = None\n\n    self.user_auth = user_auth\n    self.no_cache = no_cache\n    self.max_retries = max_retries\n    self.use_cache_file = use_cache_file\n\n    # Create instance\n    self._instance = super().__call__(\n        auth=auth_token,\n        auth_manager=credential_manager,\n        status_forcelist=(429, 500, 502, 503, 504, 404),\n    )\n\n    # Return instance\n    return self._instance\n</code></pre>"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.SpotifyClient","title":"<code>SpotifyClient(*args, **kwargs)</code>","text":"<p>               Bases: <code>Spotify</code></p> <p>This is the Spotify client meant to be used in the app. Has to be initialized first by calling <code>SpotifyClient.init(client_id, client_secret, user_auth, cache_path, no_cache, open_browser)</code>.</p>"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.SpotifyClient--arguments","title":"Arguments","text":"<ul> <li>auth: The access token to use.</li> <li>auth_manager: The auth manager to use.</li> </ul> Source code in <code>spotdl/utils/spotify.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"\n    Initializes the SpotifyClient.\n\n    ### Arguments\n    - auth: The access token to use.\n    - auth_manager: The auth manager to use.\n    \"\"\"\n\n    super().__init__(*args, **kwargs)\n    self._initialized = True\n\n    use_cache_file: bool = self.use_cache_file  # type: ignore # pylint: disable=E1101\n    cache_file_loc = get_spotify_cache_path()\n\n    if use_cache_file and cache_file_loc.exists():\n        with open(cache_file_loc, \"r\", encoding=\"utf-8\") as cache_file:\n            self.cache = json.load(cache_file)\n    elif use_cache_file:\n        with open(cache_file_loc, \"w\", encoding=\"utf-8\") as cache_file:\n            json.dump(self.cache, cache_file)\n</code></pre>"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.SpotifyError","title":"<code>SpotifyError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all exceptions related to SpotifyClient.</p>"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.save_spotify_cache","title":"<code>save_spotify_cache(cache)</code>","text":"<p>Saves the Spotify cache to a file.</p>"},{"location":"reference/utils/spotify/#spotdl.utils.spotify.save_spotify_cache--arguments","title":"Arguments","text":"<ul> <li>cache: The cache to save.</li> </ul> Source code in <code>spotdl/utils/spotify.py</code> <pre><code>def save_spotify_cache(cache: Dict[str, Optional[Dict]]):\n    \"\"\"\n    Saves the Spotify cache to a file.\n\n    ### Arguments\n    - cache: The cache to save.\n    \"\"\"\n\n    cache_file_loc = get_spotify_cache_path()\n\n    logger.debug(\"Saving Spotify cache to %s\", cache_file_loc)\n\n    # Only cache tracks\n    cache = {\n        key: value\n        for key, value in cache.items()\n        if value is not None and \"tracks/\" in key\n    }\n\n    with open(cache_file_loc, \"w\", encoding=\"utf-8\") as cache_file:\n        json.dump(cache, cache_file)\n</code></pre>"},{"location":"reference/utils/static/","title":"static","text":"<p>Module for holding static variables that are used throughout the project. And are for the most part, not likely to change. (Also holds really large variables, so pylint is disabled here)</p>"},{"location":"reference/utils/web/","title":"web","text":"<p>Module which contains the web server related function FastAPI routes/classes etc.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.ApplicationState","title":"<code>ApplicationState</code>","text":"<p>Class that holds the application state.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.Client","title":"<code>Client(websocket, client_id)</code>","text":"<p>Holds the client's state.</p> <ul> <li>websocket: The WebSocket instance.</li> <li>client_id: The client's ID.</li> <li>downloader_settings: The downloader settings.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>def __init__(\n    self,\n    websocket: WebSocket,\n    client_id: str,\n):\n    \"\"\"\n    Initialize the WebSocket handler.\n    ### Arguments\n    - websocket: The WebSocket instance.\n    - client_id: The client's ID.\n    - downloader_settings: The downloader settings.\n    \"\"\"\n\n    self.downloader_settings = DownloaderOptions(\n        **create_settings_type(\n            Namespace(config=False),\n            dict(app_state.downloader_settings),\n            DOWNLOADER_OPTIONS,\n        )  # type: ignore\n    )\n\n    self.websocket = websocket\n    self.client_id = client_id\n    self.downloader = Downloader(\n        settings=self.downloader_settings, loop=app_state.loop\n    )\n\n    self.downloader.progress_handler.web_ui = True\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.Client.connect","title":"<code>connect()</code>  <code>async</code>","text":"<p>Called when a new client connects to the websocket.</p> Source code in <code>spotdl/utils/web.py</code> <pre><code>async def connect(self):\n    \"\"\"\n    Called when a new client connects to the websocket.\n    \"\"\"\n\n    await self.websocket.accept()\n\n    # Add the connection to the list of connections\n    app_state.clients[self.client_id] = self\n    app_state.logger.info(\"Client %s connected\", self.client_id)\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.Client.get_instance","title":"<code>get_instance(client_id)</code>  <code>classmethod</code>","text":"<p>Get the WebSocket instance for a client.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.Client.get_instance--arguments","title":"Arguments","text":"<ul> <li>client_id: The client's ID.</li> </ul>"},{"location":"reference/utils/web/#spotdl.utils.web.Client.get_instance--returns","title":"Returns","text":"<ul> <li>returns the WebSocket instance.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>@classmethod\ndef get_instance(cls, client_id: str) -&gt; Optional[\"Client\"]:\n    \"\"\"\n    Get the WebSocket instance for a client.\n\n    ### Arguments\n    - client_id: The client's ID.\n\n    ### Returns\n    - returns the WebSocket instance.\n    \"\"\"\n\n    instance = app_state.clients.get(client_id)\n    if instance:\n        return instance\n\n    app_state.logger.error(\"Client %s not found\", client_id)\n\n    return None\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.Client.send_update","title":"<code>send_update(update)</code>  <code>async</code>","text":"<p>Send an update to the client.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.Client.send_update--arguments","title":"Arguments","text":"<ul> <li>update: The update to send.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>async def send_update(self, update: Dict[str, Any]):\n    \"\"\"\n    Send an update to the client.\n\n    ### Arguments\n    - update: The update to send.\n    \"\"\"\n\n    await self.websocket.send_json(update)\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.Client.song_update","title":"<code>song_update(progress_handler, message)</code>","text":"<p>Called when a song updates.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.Client.song_update--arguments","title":"Arguments","text":"<ul> <li>progress_handler: The progress handler.</li> <li>message: The message to send.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>def song_update(self, progress_handler: SongTracker, message: str):\n    \"\"\"\n    Called when a song updates.\n\n    ### Arguments\n    - progress_handler: The progress handler.\n    - message: The message to send.\n    \"\"\"\n\n    update_message = {\n        \"song\": progress_handler.song.json,\n        \"progress\": progress_handler.progress,\n        \"message\": message,\n    }\n\n    asyncio.run_coroutine_threadsafe(\n        self.send_update(update_message), app_state.loop\n    )\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.SPAStaticFiles","title":"<code>SPAStaticFiles</code>","text":"<p>               Bases: <code>StaticFiles</code></p> <p>Override the static files to serve the index.html and other assets.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.SPAStaticFiles.get_response","title":"<code>get_response(path, scope)</code>  <code>async</code>","text":"<p>Serve static files from the SPA.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.SPAStaticFiles.get_response--arguments","title":"Arguments","text":"<ul> <li>path: The path to the file.</li> <li>scope: The scope of the request.</li> </ul>"},{"location":"reference/utils/web/#spotdl.utils.web.SPAStaticFiles.get_response--returns","title":"Returns","text":"<ul> <li>returns the response.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>async def get_response(self, path: str, scope: Scope) -&gt; Response:\n    \"\"\"\n    Serve static files from the SPA.\n\n    ### Arguments\n    - path: The path to the file.\n    - scope: The scope of the request.\n\n    ### Returns\n    - returns the response.\n    \"\"\"\n\n    response = await super().get_response(path, scope)\n    if response.status_code == 404:\n        response = await super().get_response(\".\", scope)\n\n    response.headers.setdefault(\n        \"Cache-Control\", \"max-age=0, no-cache, no-store, , must-revalidate\"\n    )\n    response.headers.setdefault(\"Pragma\", \"no-cache\")\n    response.headers.setdefault(\"Expires\", \"0\")\n\n    return response\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.check_update","title":"<code>check_update()</code>","text":"<p>Check for update.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.check_update--returns","title":"Returns","text":"<ul> <li>returns True if there is an update.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>@router.get(\"/api/check_update\")\ndef check_update() -&gt; bool:\n    \"\"\"\n    Check for update.\n\n    ### Returns\n    - returns True if there is an update.\n    \"\"\"\n\n    try:\n        _, ahead, _ = get_status(__version__, \"master\")\n        if ahead &gt; 0:\n            return True\n    except RuntimeError:\n        latest_version = get_latest_version()\n        latest_tuple = tuple(latest_version.replace(\"v\", \"\").split(\".\"))\n        current_tuple = tuple(__version__.split(\".\"))\n        if latest_tuple &gt; current_tuple:\n            return True\n    except RateLimitError:\n        return False\n\n    return False\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.download_file","title":"<code>download_file(file, client=Depends(get_client), state=Depends(get_current_state))</code>  <code>async</code>","text":"<p>Download file using path.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.download_file--arguments","title":"Arguments","text":"<ul> <li>file: The file path.</li> <li>client: The client's state.</li> </ul>"},{"location":"reference/utils/web/#spotdl.utils.web.download_file--returns","title":"Returns","text":"<ul> <li>returns the file response, filename specified to return as attachment.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>@router.get(\"/api/download/file\")\nasync def download_file(\n    file: str,\n    client: Client = Depends(get_client),\n    state: ApplicationState = Depends(get_current_state),\n):\n    \"\"\"\n    Download file using path.\n\n    ### Arguments\n    - file: The file path.\n    - client: The client's state.\n\n    ### Returns\n    - returns the file response, filename specified to return as attachment.\n    \"\"\"\n\n    expected_path = str((get_spotdl_path() / \"web/sessions\").absolute())\n    if state.web_settings.get(\"web_use_output_dir\", False):\n        expected_path = str(\n            Path(client.downloader_settings[\"output\"].split(\"{\", 1)[0]).absolute()\n        )\n\n    if (not file.endswith(client.downloader_settings[\"format\"])) or (\n        not file.startswith(expected_path)\n    ):\n        raise HTTPException(status_code=400, detail=\"Invalid download path.\")\n\n    return FileResponse(\n        file,\n        filename=os.path.basename(file),\n    )\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.download_url","title":"<code>download_url(url, client=Depends(get_client), state=Depends(get_current_state))</code>  <code>async</code>","text":"<p>Download songs using Song url.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.download_url--arguments","title":"Arguments","text":"<ul> <li>url: The url to download.</li> </ul>"},{"location":"reference/utils/web/#spotdl.utils.web.download_url--returns","title":"Returns","text":"<ul> <li>returns the file path if the song was downloaded.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>@router.post(\"/api/download/url\")\nasync def download_url(\n    url: str,\n    client: Client = Depends(get_client),\n    state: ApplicationState = Depends(get_current_state),\n) -&gt; Optional[str]:\n    \"\"\"\n    Download songs using Song url.\n\n    ### Arguments\n    - url: The url to download.\n\n    ### Returns\n    - returns the file path if the song was downloaded.\n    \"\"\"\n\n    if state.web_settings.get(\"web_use_output_dir\", False):\n        client.downloader.settings[\"output\"] = client.downloader_settings[\"output\"]\n    else:\n        client.downloader.settings[\"output\"] = str(\n            (get_spotdl_path() / f\"web/sessions/{client.client_id}\").absolute()\n        )\n\n    client.downloader.progress_handler = ProgressHandler(\n        simple_tui=True,\n        update_callback=client.song_update,\n    )\n\n    try:\n        # Fetch song metadata\n        song = Song.from_url(url)\n\n        # Download Song\n        _, path = await client.downloader.pool_download(song)\n\n        if path is None:\n            state.logger.error(f\"Failure downloading {song.name}\")\n\n            raise HTTPException(\n                status_code=500, detail=f\"Error downloading: {song.name}\"\n            )\n\n        return str(path.absolute())\n\n    except Exception as exception:\n        state.logger.error(f\"Error downloading! {exception}\")\n\n        raise HTTPException(\n            status_code=500, detail=f\"Error downloading: {exception}\"\n        ) from exception\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.fix_mime_types","title":"<code>fix_mime_types()</code>","text":"<p>Fix incorrect entries in the <code>mimetypes</code> registry. On Windows, the Python standard library's <code>mimetypes</code> reads in mappings from file extension to MIME type from the Windows registry. Other applications can and do write incorrect values to this registry, which causes <code>mimetypes.guess_type</code> to return incorrect values, which causes spotDL to fail to render on the frontend. This method hard-codes the correct mappings for certain MIME types that are known to be either used by TensorBoard or problematic in general.</p> Source code in <code>spotdl/utils/web.py</code> <pre><code>def fix_mime_types():\n    \"\"\"Fix incorrect entries in the `mimetypes` registry.\n    On Windows, the Python standard library's `mimetypes` reads in\n    mappings from file extension to MIME type from the Windows\n    registry. Other applications can and do write incorrect values\n    to this registry, which causes `mimetypes.guess_type` to return\n    incorrect values, which causes spotDL to fail to render on\n    the frontend.\n    This method hard-codes the correct mappings for certain MIME\n    types that are known to be either used by TensorBoard or\n    problematic in general.\n    \"\"\"\n\n    # Known to be problematic when Visual Studio is installed:\n    # &lt;https://github.com/tensorflow/tensorboard/issues/3120&gt;\n    # https://github.com/spotDL/spotify-downloader/issues/1540\n    mimetypes.add_type(\"application/javascript\", \".js\")\n\n    # Not known to be problematic, but used by spotDL:\n    mimetypes.add_type(\"text/css\", \".css\")\n    mimetypes.add_type(\"image/svg+xml\", \".svg\")\n    mimetypes.add_type(\"text/html\", \".html\")\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.get_client","title":"<code>get_client(client_id=Query(default=None))</code>","text":"<p>Get the client's state.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.get_client--arguments","title":"Arguments","text":"<ul> <li>client_id: The client's ID.</li> </ul>"},{"location":"reference/utils/web/#spotdl.utils.web.get_client--returns","title":"Returns","text":"<ul> <li>returns the client's state.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>def get_client(client_id: Union[str, None] = Query(default=None)) -&gt; Client:\n    \"\"\"\n    Get the client's state.\n\n    ### Arguments\n    - client_id: The client's ID.\n\n    ### Returns\n    - returns the client's state.\n    \"\"\"\n\n    if client_id is None:\n        raise HTTPException(status_code=400, detail=\"client_id is required\")\n\n    instance = Client.get_instance(client_id)\n    if instance is None:\n        raise HTTPException(status_code=404, detail=\"client not found\")\n\n    return instance\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.get_current_state","title":"<code>get_current_state()</code>","text":"<p>Get the current state of the application.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.get_current_state--returns","title":"Returns","text":"<ul> <li>returns the application state.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>def get_current_state() -&gt; ApplicationState:\n    \"\"\"\n    Get the current state of the application.\n\n    ### Returns\n    - returns the application state.\n    \"\"\"\n\n    return app_state\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.get_options","title":"<code>get_options()</code>","text":"<p>Get options model (possible settings).</p>"},{"location":"reference/utils/web/#spotdl.utils.web.get_options--returns","title":"Returns","text":"<ul> <li>returns the options.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>@router.get(\"/api/options_model\")\ndef get_options() -&gt; Dict[str, Any]:\n    \"\"\"\n    Get options model (possible settings).\n\n    ### Returns\n    - returns the options.\n    \"\"\"\n\n    parser = create_parser()\n\n    # Forbidden actions\n    forbidden_actions = [\n        \"help\",\n        \"operation\",\n        \"version\",\n        \"config\",\n        \"user_auth\",\n        \"client_id\",\n        \"client_secret\",\n        \"auth_token\",\n        \"cache_path\",\n        \"no_cache\",\n        \"cookie_file\",\n        \"ffmpeg\",\n        \"archive\",\n        \"host\",\n        \"port\",\n        \"keep_alive\",\n        \"enable_tls\",\n        \"key_file\",\n        \"cert_file\",\n        \"ca_file\",\n        \"allowed_origins\",\n        \"web_use_output_dir\",\n        \"keep_sessions\",\n        \"log_level\",\n        \"simple_tui\",\n        \"headless\",\n        \"download_ffmpeg\",\n        \"generate_config\",\n        \"check_for_updates\",\n        \"profile\",\n        \"version\",\n    ]\n\n    options = {}\n    for action in parser._actions:  # pylint: disable=protected-access\n        if action.dest in forbidden_actions:\n            continue\n\n        default = app_state.downloader_settings.get(action.dest, None)\n        choices = list(action.choices) if action.choices else None\n\n        type_name = \"\"\n        if action.type is not None:\n            if hasattr(action.type, \"__objclass__\"):\n                type_name: str = action.type.__objclass__.__name__  # type: ignore\n            else:\n                type_name: str = action.type.__name__  # type: ignore\n\n        if isinstance(\n            action, argparse._StoreConstAction  # pylint: disable=protected-access\n        ):\n            type_name = \"bool\"\n\n        if choices is not None and action.nargs == \"*\":\n            type_name = \"list\"\n\n        options[action.dest] = {\n            \"type\": type_name,\n            \"choices\": choices,\n            \"default\": default,\n            \"help\": action.help,\n        }\n\n    return options\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.get_settings","title":"<code>get_settings(client=Depends(get_client))</code>","text":"<p>Get client settings.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.get_settings--arguments","title":"Arguments","text":"<ul> <li>client: The client's state.</li> </ul>"},{"location":"reference/utils/web/#spotdl.utils.web.get_settings--returns","title":"Returns","text":"<ul> <li>returns the settings.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>@router.get(\"/api/settings\")\ndef get_settings(\n    client: Client = Depends(get_client),\n) -&gt; DownloaderOptions:\n    \"\"\"\n    Get client settings.\n\n    ### Arguments\n    - client: The client's state.\n\n    ### Returns\n    - returns the settings.\n    \"\"\"\n\n    return client.downloader_settings\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.query_search","title":"<code>query_search(query)</code>","text":"<p>Parse search term and return list of Song objects.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.query_search--arguments","title":"Arguments","text":"<ul> <li>query: The query to parse.</li> </ul>"},{"location":"reference/utils/web/#spotdl.utils.web.query_search--returns","title":"Returns","text":"<ul> <li>returns a list of Song objects.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>@router.get(\"/api/songs/search\", response_model=None)\ndef query_search(query: str) -&gt; List[Song]:\n    \"\"\"\n    Parse search term and return list of Song objects.\n\n    ### Arguments\n    - query: The query to parse.\n\n    ### Returns\n    - returns a list of Song objects.\n    \"\"\"\n\n    return get_search_results(query)\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.shutdown_event","title":"<code>shutdown_event()</code>  <code>async</code>","text":"<p>Called when the server is shutting down.</p> Source code in <code>spotdl/utils/web.py</code> <pre><code>@router.on_event(\"shutdown\")\nasync def shutdown_event():\n    \"\"\"\n    Called when the server is shutting down.\n    \"\"\"\n\n    if (\n        not app_state.web_settings[\"keep_sessions\"]\n        and not app_state.web_settings[\"web_use_output_dir\"]\n    ):\n        app_state.logger.info(\"Removing sessions directories\")\n        sessions_dir = Path(get_spotdl_path(), \"web/sessions\")\n        if sessions_dir.exists():\n            shutil.rmtree(sessions_dir)\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.song_from_url","title":"<code>song_from_url(url)</code>","text":"<p>Search for a song on spotify using url.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.song_from_url--arguments","title":"Arguments","text":"<ul> <li>url: The url to search.</li> </ul>"},{"location":"reference/utils/web/#spotdl.utils.web.song_from_url--returns","title":"Returns","text":"<ul> <li>returns the first result as a Song object.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>@router.get(\"/api/song/url\", response_model=None)\ndef song_from_url(url: str) -&gt; Song:\n    \"\"\"\n    Search for a song on spotify using url.\n\n    ### Arguments\n    - url: The url to search.\n\n    ### Returns\n    - returns the first result as a Song object.\n    \"\"\"\n\n    return Song.from_url(url)\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.songs_from_url","title":"<code>songs_from_url(url)</code>","text":"<p>Search for a song, playlist, artist or album on spotify using url.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.songs_from_url--arguments","title":"Arguments","text":"<ul> <li>url: The url to search.</li> </ul>"},{"location":"reference/utils/web/#spotdl.utils.web.songs_from_url--returns","title":"Returns","text":"<ul> <li>returns a list with Song objects to be downloaded.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>@router.get(\"/api/url\", response_model=None)\ndef songs_from_url(url: str) -&gt; List[Song]:\n    \"\"\"\n    Search for a song, playlist, artist or album on spotify using url.\n\n    ### Arguments\n    - url: The url to search.\n\n    ### Returns\n    - returns a list with Song objects to be downloaded.\n    \"\"\"\n\n    if \"playlist\" in url:\n        playlist = Playlist.from_url(url)\n        return list(map(Song.from_url, playlist.urls))\n    if \"album\" in url:\n        album = Album.from_url(url)\n        return list(map(Song.from_url, album.urls))\n    if \"artist\" in url:\n        artist = Artist.from_url(url)\n        return list(map(Song.from_url, artist.urls))\n\n    return [Song.from_url(url)]\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.update_settings","title":"<code>update_settings(settings, client=Depends(get_client), state=Depends(get_current_state))</code>","text":"<p>Update client settings, and re-initialize downloader.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.update_settings--arguments","title":"Arguments","text":"<ul> <li>settings: The settings to change.</li> <li>client: The client's state.</li> <li>state: The application state.</li> </ul>"},{"location":"reference/utils/web/#spotdl.utils.web.update_settings--returns","title":"Returns","text":"<ul> <li>returns True if the settings were changed.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>@router.post(\"/api/settings/update\")\ndef update_settings(\n    settings: DownloaderOptionalOptions,\n    client: Client = Depends(get_client),\n    state: ApplicationState = Depends(get_current_state),\n) -&gt; DownloaderOptions:\n    \"\"\"\n    Update client settings, and re-initialize downloader.\n\n    ### Arguments\n    - settings: The settings to change.\n    - client: The client's state.\n    - state: The application state.\n\n    ### Returns\n    - returns True if the settings were changed.\n    \"\"\"\n\n    # Create shallow copy of settings\n    settings_cpy = client.downloader_settings.copy()\n\n    # Update settings with new settings that are not None\n    settings_cpy.update({k: v for k, v in settings.items() if v is not None})  # type: ignore\n\n    state.logger.info(f\"Applying settings: {settings_cpy}\")\n\n    new_settings = DownloaderOptions(**settings_cpy)  # type: ignore\n\n    # Re-initialize downloader\n    client.downloader_settings = new_settings\n    client.downloader = Downloader(\n        new_settings,\n        loop=state.loop,\n    )\n\n    return new_settings\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.version","title":"<code>version()</code>","text":"<p>Get the current version This method is created to ensure backward compatibility of the web app, as the web app is updated with the latest regardless of the backend version</p>"},{"location":"reference/utils/web/#spotdl.utils.web.version--returns","title":"Returns","text":"<ul> <li>returns the version of the app</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>@router.get(\"/api/version\", response_model=None)\ndef version() -&gt; str:\n    \"\"\"\n    Get the current version\n    This method is created to ensure backward compatibility of the web app,\n    as the web app is updated with the latest regardless of the backend version\n\n    ### Returns\n    -  returns the version of the app\n    \"\"\"\n\n    return __version__\n</code></pre>"},{"location":"reference/utils/web/#spotdl.utils.web.websocket_endpoint","title":"<code>websocket_endpoint(websocket, client_id)</code>  <code>async</code>","text":"<p>Websocket endpoint.</p>"},{"location":"reference/utils/web/#spotdl.utils.web.websocket_endpoint--arguments","title":"Arguments","text":"<ul> <li>websocket: The WebSocket instance.</li> </ul> Source code in <code>spotdl/utils/web.py</code> <pre><code>@router.websocket(\"/api/ws\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    \"\"\"\n    Websocket endpoint.\n\n    ### Arguments\n    - websocket: The WebSocket instance.\n    \"\"\"\n\n    await Client(websocket, client_id).connect()\n\n    try:\n        while True:\n            await websocket.receive_json()\n    except WebSocketDisconnect:\n        app_state.clients.pop(client_id, None)\n\n        if (\n            len(app_state.clients) == 0\n            and app_state.web_settings[\"keep_alive\"] is False\n        ):\n            app_state.logger.debug(\n                \"No active connections, waiting 1s before shutting down\"\n            )\n\n            await asyncio.sleep(1)\n\n            # Wait 1 second before shutting down\n            # This is to prevent the server from shutting down when a client\n            # disconnects and reconnects quickly (e.g. when refreshing the page)\n            if len(app_state.clients) == 0:\n                # Perform a clean exit\n                app_state.logger.info(\"Shutting down server, no active connections\")\n                app_state.server.force_exit = True\n                app_state.server.should_exit = True\n                await app_state.server.shutdown()\n</code></pre>"}]}